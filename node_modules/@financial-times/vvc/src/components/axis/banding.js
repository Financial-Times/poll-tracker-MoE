import React from 'react';
import { Group } from '@visx/group';
import { inferScaleType } from '@visx/scale';
import { axisBandingComponentDefaultProps } from '../default-props';

const AxisBanding = ({
  bandingScale,
  width,
  height,
  orientation,
  tickValues,
  structure,
  tickPositionVariable,
}) => {
  const scalePointOffset = inferScaleType(bandingScale) === 'point' ? bandingScale.step() / 2 : 0;

  const [minScale, maxScale] = bandingScale.domain();
  // Copy tickValues;
  let tickValuesForBanding = [...tickValues];

  // Maps custom tickValuesForBanding object to derive a simple array of tick values
  if (tickPositionVariable) {
    const newValues = tickValuesForBanding.map((d) => {
      return d[tickPositionVariable];
    });
    tickValuesForBanding = newValues;
  }

  let bands;
  // Builds bands structure if the scale passed down is ordinal
  if (structure === 'fixed' && isNaN(tickValuesForBanding[0])) {
    switch (orientation) {
      case 'top':
      case 'bottom':
        bands = tickValuesForBanding
          .map((d, i) => ({
            x: bandingScale(d) - scalePointOffset,
            y: 0,
            width: bandingScale.bandwidth() || bandingScale.step(),
            height,
          }))
          .filter((d, i) => i % 2 === 0);
        break;
      case 'left':
      case 'right':
        bands = tickValuesForBanding
          .map((d, i) => ({
            x: 0,
            y: bandingScale(d) - scalePointOffset,
            width,
            height: bandingScale.bandwidth() || bandingScale.step(),
          }))
          .filter((d, i) => i % 2 === 0);
        break;
      default:
        bands = [];
    }
  } else {
    /* If not an ordinal scale or custom ticks checks to see if the extent of the domain
      is greater than the extent of ticks allowing thin bands at the begining and end of the scale */
    if (structure === 'fixed') {
      // If first tick is less than the min value in the domain, add it to the front of the array
      if (minScale < tickValuesForBanding[0]) {
        tickValuesForBanding.unshift(minScale);
      }
      // If first tick is greater than the max value in the domain, add it to the end of the array
      if (maxScale > tickValuesForBanding[tickValuesForBanding.length - 1]) {
        tickValuesForBanding.push(maxScale);
      }
      // Removes last value if tickValuesForBanding array is uneven preventing NaN calculations
      if (tickValuesForBanding.length % 2 != 0) {
        tickValuesForBanding.pop();
      }
    }

    // Build bands structure if a scaleBanding is Linear
    switch (orientation) {
      case 'top':
      case 'bottom':
        bands = tickValuesForBanding
          .map((d, i) => ({
            label: d,
            x: bandingScale(d),
            y: 0,
            width: Math.abs(
              bandingScale(
                i < tickValuesForBanding.length - 1 ? tickValuesForBanding[i + 1] : maxScale
              ) - bandingScale(d)
            ),
            height,
          }))
          .filter((d, i) => i % 2 === 0);
        break;
      case 'left':
      case 'right':
        bands = tickValuesForBanding
          .map((d, i) => ({
            label: d,
            x: 0,
            y: bandingScale(tickValuesForBanding[structure === 'fixed' ? i + 1 : i]),
            width,
            height: Math.abs(
              bandingScale(
                i < tickValuesForBanding.length - 1 ? tickValuesForBanding[i + 1] : maxScale
              ) - bandingScale(d)
            ),
          }))
          .filter((d, i) => i % 2 === 0);
        break;
      default:
        bands = [];
    }
  }

  const renderedBands = bands.map((d, i) => {
    return <rect key={`band${i}`} x={d.x} y={d.y} width={d.width} height={d.height} />;
  });

  return (
    <Group className="visx-axis-banding" id="axisBanding">
      {renderedBands}
    </Group>
  );
};
AxisBanding.defaultProps = axisBandingComponentDefaultProps;

export default AxisBanding;
