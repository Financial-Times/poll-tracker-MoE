/**
 * @file
 * vv-axis
 */

import React, { useContext, useEffect } from 'react';
import PropTypes from 'prop-types';
import { Axis as VisxAxis, AxisTop, AxisRight, AxisBottom, AxisLeft } from '@visx/axis';
import { scaleOrdinal, inferScaleType } from '@visx/scale';
import { Group } from '@visx/group';
import { PlotContext } from '../chart-frame/plot-context';
import AxisArrows from './arrows';
import AxisBanding from './banding';
import {
  webAxisStyles,
  socialAxisStyles,
  videoAxisStyles,
  printAxisStyles,
  combineStyles,
} from './styles';
import { approximateTextSize } from '../../util/victory-textsize';
import { identity, getResponsiveValues } from '../../util';
import { axisComponentPropTypes } from '../prop-types';
import { axisComponentDefaultProps } from '../default-props';

const invertAxis = (invertScale, plotScale) => {
  const newScale = plotScale.copy();
  if (invertScale) {
    const newRange = plotScale.range().reverse();
    newScale.range(newRange);
    return newScale;
  }
  return plotScale;
};

const defaultTickComponent = ({ formattedValue, ...tickProps }) => {
  return <text {...tickProps}>{formattedValue}</text>;
};

defaultTickComponent.propTypes = {
  formattedValue: PropTypes.string,
};

defaultTickComponent.defaultProps = {
  formattedValue: '',
};

const Axis = ({
  additionalAxisStyles,
  automaticallyAddPaddingForTicks,
  automaticallySetRange,
  axisArrows,
  axisArrowsPadding,
  axisBanding,
  fullLengthTicks,
  hideAxisLine,
  hideEndTicks,
  hideTicks,
  invertScale,
  label,
  labelOffset,
  labelProps,
  numTicks,
  orientation,
  scale,
  tickComponent,
  tickFormat,
  tickLabelPadding = 10,
  tickLabelProps,
  tickLabelVariable,
  tickLengthOverride,
  tickPositionVariable,
  tickValues,
  additionalTickValues,
  type,
}) => {
  const { frameWidth, width, height, updatePadding } = useContext(PlotContext);

  // If using tickPositionVariable do not format the tick label
  const format = tickPositionVariable
    ? identity
    : // Otherwise use the passed tickFormat function or the tickFormat function already set in the scale
      tickFormat || (scale.tickFormat ? scale.tickFormat() : identity);

  // Combine tick values with additional tick values
  const allTickValues = additionalTickValues
    ? // Combine with additional tick values and get unique set
      [...new Set([...scale.ticks(), ...(additionalTickValues || [])])].sort((a, b) =>
        // Sort from largest to smallest and invert if the range is inverted
        scale.range()[0] < scale.range()[1] ? scale(a) - scale(b) : scale(b) - scale(a)
      )
    : tickValues;

  // Extract the labels and positions from the tickValues if tickPositionVariable is set
  const tickLabels = tickPositionVariable
    ? allTickValues.map((d) => d[tickLabelVariable])
    : allTickValues;
  const tickPositions = tickPositionVariable
    ? allTickValues.map((d) => d[tickPositionVariable])
    : allTickValues;
  // Only remove end ticks if prop set and no custom tick labels are being used
  const tickValuesToUse =
    tickLabels ||
    (hideEndTicks && scale.ticks().slice(1, -1)) ||
    (scale.ticks ? scale.ticks() : allTickValues) ||
    scale.domain();

  /* If tickPositionVariable is set, setup the ordinal scale to be used for tick positions instead.
    Use the passed scale to calculate the position of each tick from the extracted tick positions
  */
  const tickScale = tickPositionVariable
    ? scaleOrdinal({ domain: tickLabels, range: tickPositions.map((position) => scale(position)) })
    : scale;

  // Split the axis label into multiple lines
  const labelLines = label ? label.split('|').map((l) => l.trim()) : [];
  const numberOfLabelLines = labelLines.length;

  // Get responsive values for axis
  const { tickLength: responsiveTickLength, axisLabelStyle, tickLabelStyle } = getResponsiveValues(
    frameWidth
  );
  const tickLength =
    typeof tickLengthOverride === 'number' ? tickLengthOverride : responsiveTickLength;

  // Get an array of the tick labels to be used to calculate the max tick width
  const values = tickValuesToUse || (scale.ticks ? scale.ticks(numTicks) : scale.domain());

  // Calculate max tick width for left/right padding
  const maxTickWidth =
    Math.max(
      ...values
        .map((d, i) => format(d, i))
        .map(
          (d) =>
            approximateTextSize(d, {
              fontFamily: 'MetricWeb-Regular',
              fontSize: tickLabelStyle.fontSize,
            }).width
        )
    ) +
    // Tick length is ignored if using full length ticks
    (fullLengthTicks ? 0 : tickLength) +
    // This is â‰… 0.25em in VisX
    tickLabelPadding;

  /* VisX Axis components support passing a function, tickLabelProps, which can be used
    to set additional props for each tick label (based on the label text and index if required).
    We create a function which given a set of initial props for each tick label will return another
    function which combines those initial props, any responsive tick label styles from getResponsiveValues
    and any generated per tick label props from a tickLabelProps function if that prop is set
  */
  const calculateTickLabelProps = (initialProps) => (tickLabel, index) => {
    const generatedTickLabelProps = tickLabelProps
      ? tickLabelProps(tickLabel, index, tickLabelStyle)
      : {};
    return {
      // Include default props for tick label e.g. pass dx/dy for each axis orientation
      ...initialProps,
      style: {
        ...initialProps.style,
        ...tickLabelStyle,
      },
      ...generatedTickLabelProps,
    };
  };

  // Calculate the total height of the axis
  const heightOfTicksWithLabels = tickLabelStyle.fontSize + (fullLengthTicks ? 0 : tickLength);
  const heightOfAxisLabel = axisLabelStyle.fontSize * numberOfLabelLines;
  const totalAxisHeight =
    heightOfTicksWithLabels + (numberOfLabelLines > 0 ? (labelOffset || 0) + heightOfAxisLabel : 0);
  const totalAxisWidth =
    maxTickWidth + (numberOfLabelLines > 0 ? (labelOffset || 0) + heightOfAxisLabel : 0);

  // Get css for frame and combine with any passed additional axis styles
  let initialCss = webAxisStyles;
  switch (type) {
    case 'print':
      initialCss = printAxisStyles;
      break;
    case 'social':
      initialCss = socialAxisStyles;
      break;
    case 'video':
      initialCss = videoAxisStyles;
      break;
    case 'web':
    default:
      initialCss = webAxisStyles;
  }
  const css = additionalAxisStyles ? combineStyles(initialCss, additionalAxisStyles) : initialCss;

  // Update top or bottom padding
  useEffect(() => {
    if (automaticallyAddPaddingForTicks) {
      if (orientation === 'bottom') {
        updatePadding({ bottom: totalAxisHeight });
      }
      if (orientation === 'top') {
        updatePadding({ top: totalAxisHeight });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [automaticallyAddPaddingForTicks, orientation, totalAxisHeight]);

  // Update padding for ticks if left or right axis
  useEffect(() => {
    if (automaticallyAddPaddingForTicks) {
      if (orientation === 'left') {
        updatePadding({ left: totalAxisWidth });
      }
      if (orientation === 'right') {
        updatePadding({ right: totalAxisWidth });
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [automaticallyAddPaddingForTicks, maxTickWidth, orientation]);

  // Axis banding component is passed the same prop for all axis orientations
  const axisBandingElement = axisBanding ? (
    <AxisBanding
      bandingScale={scale}
      width={width}
      height={height}
      orientation={orientation}
      tickValues={tickValues || values}
      structure={tickPositionVariable ? 'custom' : 'fixed'}
      tickPositionVariable={tickPositionVariable}
    />
  ) : null;

  switch (orientation) {
    case 'top':
      if (automaticallySetRange && !tickPositionVariable) scale.range([0, width]);
      return (
        <Group css={css}>
          {axisBandingElement}
          <AxisTop
            top={fullLengthTicks ? height : 0}
            hideAxisLine={hideAxisLine || fullLengthTicks}
            hideTicks={hideTicks}
            scale={invertAxis(invertScale, tickScale || scale)}
            tickComponent={tickComponent || defaultTickComponent}
            tickFormat={format}
            tickLabelProps={calculateTickLabelProps({ dy: '-0.25em' })}
            tickLength={fullLengthTicks ? height : tickLength}
            tickValues={tickValuesToUse}
          />
          {label && (
            <Group
              className="visx-axis-label"
              top={
                axisLabelStyle.fontSize -
                (labelOffset || 0) -
                heightOfTicksWithLabels -
                heightOfAxisLabel
              }
              left={width / 2}
            >
              <text
                {...labelProps}
                style={{ fontSize: axisLabelStyle.fontSize, textAnchor: 'middle' }}
              >
                {labelLines.map((text, i) => (
                  <tspan key={`text_${text}`} x={0} dy={i === 0 ? 0 : axisLabelStyle.fontSize}>
                    {text}
                  </tspan>
                ))}
              </text>
            </Group>
          )}
          {axisArrows && (
            <Group className="visx-axis-arrows" top={labelOffset || 0}>
              <AxisArrows
                axisArrows={axisArrows}
                axisArrowsPadding={axisArrowsPadding}
                axisArrowsScale={scale}
                orientation={orientation}
              />
            </Group>
          )}
        </Group>
      );
    case 'right':
      if (automaticallySetRange && !tickPositionVariable && inferScaleType(scale) !== 'band')
        scale.range([height, 0]);
      if (automaticallySetRange && (tickPositionVariable || inferScaleType(scale) === 'band'))
        scale.range([0, height]);
      return (
        <Group css={css}>
          {axisBandingElement}
          <AxisRight
            left={fullLengthTicks ? 0 : width}
            hideAxisLine={hideAxisLine || fullLengthTicks}
            hideTicks={hideTicks}
            scale={invertAxis(invertScale, tickScale || scale)}
            tickComponent={tickComponent || defaultTickComponent}
            tickFormat={format}
            tickLabelProps={calculateTickLabelProps({ dx: '0.25em', dy: '0.25em' })}
            tickLength={fullLengthTicks ? width : tickLength}
            tickValues={tickValuesToUse}
          />
          {label && (
            <Group
              className="vx-axis-label"
              transform={`translate(${
                fullLengthTicks
                  ? maxTickWidth +
                    (labelOffset || 0) +
                    (numberOfLabelLines - 1) * axisLabelStyle.fontSize
                  : width +
                    maxTickWidth +
                    (labelOffset || 0) +
                    (numberOfLabelLines - 1) * axisLabelStyle.fontSize
              }, ${height / 2}) rotate(90)`}
            >
              <text
                {...labelProps}
                style={{ fontSize: axisLabelStyle.fontSize, textAnchor: 'middle' }}
              >
                {labelLines.map((text, i) => (
                  <tspan key={`text_${text}`} x={0} dy={i === 0 ? 0 : axisLabelStyle.fontSize}>
                    {text}
                  </tspan>
                ))}
              </text>
            </Group>
          )}
        </Group>
      );
    case 'bottom':
      if (automaticallySetRange && !tickPositionVariable) scale.range([0, width]);
      return (
        <Group css={css}>
          {axisBandingElement}
          <AxisBottom
            top={fullLengthTicks ? 0 : height}
            hideAxisLine={hideAxisLine || fullLengthTicks}
            hideTicks={hideTicks}
            scale={invertAxis(invertScale, tickScale || scale)}
            tickComponent={tickComponent || defaultTickComponent}
            tickFormat={format}
            tickLabelProps={calculateTickLabelProps({ dy: '0.25em' })}
            tickLength={fullLengthTicks ? height : tickLength}
            tickValues={tickValuesToUse}
          />
          {label && (
            <Group
              className="visx-axis-label"
              top={height + heightOfTicksWithLabels + (labelOffset || 0) + axisLabelStyle.fontSize}
              left={width / 2}
            >
              <text
                {...labelProps}
                style={{ fontSize: axisLabelStyle.fontSize, textAnchor: 'middle' }}
              >
                {labelLines.map((text, i) => (
                  <tspan key={`text_${text}`} x={0} dy={i === 0 ? 0 : axisLabelStyle.fontSize}>
                    {text}
                  </tspan>
                ))}
              </text>
            </Group>
          )}
          {axisArrows && (
            <Group className="visx-axis-arrows" top={height + (labelOffset || 0)}>
              <AxisArrows
                axisArrows={axisArrows}
                axisArrowsPadding={axisArrowsPadding}
                axisArrowsScale={scale}
                orientation={orientation}
              />
            </Group>
          )}
        </Group>
      );
    case 'left':
      if (automaticallySetRange && !tickPositionVariable && inferScaleType(scale) !== 'band')
        scale.range([height, 0]);
      if (automaticallySetRange && (tickPositionVariable || inferScaleType(scale) === 'band'))
        scale.range([0, height]);
      return (
        <Group css={css}>
          {axisBandingElement}
          <AxisLeft
            left={fullLengthTicks ? width : 0}
            hideAxisLine={hideAxisLine || fullLengthTicks}
            hideTicks={hideTicks}
            scale={invertAxis(invertScale, tickScale || scale)}
            tickComponent={tickComponent || defaultTickComponent}
            tickFormat={format}
            tickLabelProps={calculateTickLabelProps({ dx: '-0.25em', dy: '0.25em' })}
            tickLength={fullLengthTicks ? width : tickLength}
            tickValues={tickValuesToUse}
          />
          {label && (
            <Group
              className="vx-axis-label"
              transform={`translate(${
                -maxTickWidth -
                (labelOffset || 0) -
                (numberOfLabelLines - 1) * axisLabelStyle.fontSize
              }, ${height / 2}) rotate(-90)`}
            >
              <text
                {...labelProps}
                style={{ fontSize: axisLabelStyle.fontSize, textAnchor: 'middle' }}
              >
                {labelLines.map((text, i) => (
                  <tspan key={`text_${text}`} x={0} dy={i === 0 ? 0 : axisLabelStyle.fontSize}>
                    {text}
                  </tspan>
                ))}
              </text>
            </Group>
          )}
        </Group>
      );
    default:
      return (
        <Group css={css}>
          <VisxAxis
            tickComponent={tickComponent || defaultTickComponent}
            tickFormat={format}
            scale={scale}
          />
        </Group>
      );
  }
};

Axis.propTypes = axisComponentPropTypes;
Axis.defaultProps = axisComponentDefaultProps;

export default Axis;
