import { useCallback, useMemo } from 'react';
import { Delaunay } from 'd3-delaunay';
import localPoint from '@visx/event/lib/localPoint';
import { isZeroOrDefined } from '../../util';

export const useDelaunay = ({
  width,
  height,
  xScale,
  yScale,
  xVariable,
  yVariable,
  yTransformFunction,
  data,
  tooltipEvents,
  tooltipPositionOverride,
  hoverRadius,
  debug,
}) => {
  // Filter out data which is undefined
  const filteredData = useMemo(
    () => data.filter((d) => isZeroOrDefined(d[xVariable]) && isZeroOrDefined(d[yVariable])),
    [data, xVariable, yVariable]
  );

  // Generate Delaunay triangulation
  const delaunay = useMemo(
    () =>
      Delaunay.from(
        filteredData.filter((d) => isZeroOrDefined(d[xVariable]) && isZeroOrDefined(d[yVariable])),
        (d) => xScale(d[xVariable]),
        (d) => yScale(d[yVariable])
      ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [data, width, height, xScale, xVariable, yScale, yVariable]
  );

  // Generate path string for debugging if prop set
  const pathString = useMemo(() => debug && delaunay.render(), [debug, delaunay]);

  // Generate mouse move callback
  const onMouseMove = useCallback(
    (event, { top, left, height }) => {
      // Get the point from the mouse event
      const point = localPoint(event) || { x: 0, y: 0 };
      // Recalculate the coordinates using left and top offsets (sum of padding and margins)
      const [mx, my] = [point.x - left, point.y - top];
      // Find the closest point
      const pointIndex = delaunay.find(mx, my);
      // Get the data associated with that point
      const pointData = filteredData[pointIndex];
      // Calculate the distance between the mouse point and the closest point
      const pointDistance = Math.hypot(
        mx - xScale(pointData[xVariable]),
        my - yScale(pointData[yVariable])
      );

      let tooltipDataObject;
      let tooltipPosition;

      // If hover radius isn't set or the point distance is within the radius, update the state
      if (!hoverRadius || pointDistance <= hoverRadius) {
        const {
          isHighlighted,
          labelData: tooltipContent,
          seriesName,
          [yVariable]: dataY,
          [xVariable]: dataX,
        } = pointData;

        tooltipDataObject =
          // Check that highlighted lines are being used
          isHighlighted !== undefined
            ? isHighlighted
              ? // Set the state to a specific data point in the series
                {
                  content: tooltipContent,
                  dataYPosition: top + yScale(dataY),
                  // This is used to reposition the tooltip
                  maxOffsetY: top + height,
                  data: { y: dataY, x: dataX, seriesName },
                }
              : // Only set the seriesName in the state so that the whole line is selected
                { seriesName }
            : {
                content: tooltipContent,
              };

        tooltipPosition =
          tooltipPositionOverride &&
          tooltipPositionOverride({
            data: pointData,
            xScale: (x) => left + xScale(x),
            yScale: (y) => top + yScale(y),
          });
      }

      // Add the current mouse position to the state if in debug mode
      const { onMouseOver } = tooltipEvents(
        debug ? { ...tooltipDataObject, mousePoint: { mx, my } } : tooltipDataObject,
        tooltipPosition
      );

      // Call the mouse over event
      onMouseOver(event);
    },
    [
      debug,
      delaunay,
      filteredData,
      hoverRadius,
      tooltipEvents,
      tooltipPositionOverride,
      xScale,
      xVariable,
      yScale,
      yVariable,
    ]
  );

  // Setup mouse out callback (which hides the tooltip)
  const onMouseOut = useCallback(() => {
    const { onMouseOut } = tooltipEvents();
    // Call the mouse out event
    onMouseOut();
  }, [tooltipEvents]);

  return { onMouseMove, onMouseOut, pathString };
};

export default null;
