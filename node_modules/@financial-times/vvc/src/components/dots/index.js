import React, { useContext } from 'react';
import { Group } from '@visx/group';
import { Circle } from '@visx/shape';
import { inferScaleType } from '@visx/scale';
import { LinePathAnnotation } from '@visx/annotation';
import { PlotContext } from '../chart-frame/plot-context';
import { dotsComponentPropTypes } from '../prop-types';
import { dotsComponentDefaultProps } from '../default-props';
import { useTooltipEvents } from '../../util/hooks';

const LabelArrow = ({ x, y, width, fill, stroke, strokeWidth }) => {
  const halfWidth = (width + strokeWidth) / 2;
  return (
    <path
      d={`M${x - halfWidth},${y + halfWidth} L${x + halfWidth},${y + halfWidth} L${x},${
        y - halfWidth
      } Z`}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth / 2}
      strokeLinecap="round"
    />
  );
};

const DotLabel = ({
  label,
  labelFill,
  labelDy,
  labelStrokeColor,
  labelPoints,
  labelStrokeWidth,
  generatedLabelProps,
}) => (
  <Group>
    {labelStrokeColor && (
      <LinePathAnnotation
        className="highlighted-label"
        label={label}
        points={labelPoints}
        labelFill={labelStrokeColor}
        labelStroke={labelStrokeColor}
        labelStrokeWidth={labelStrokeWidth}
        labelDy={labelDy}
        {...generatedLabelProps}
      />
    )}
    <LinePathAnnotation
      className="highlighted-label"
      label={label}
      points={labelPoints}
      labelFill={labelFill}
      labelStroke="none"
      labelDy={labelDy}
      {...generatedLabelProps}
    />
  </Group>
);

const Dot = ({
  cx,
  cy,
  r,
  topSpacing, // Margin + Padding
  hollow,
  color,
  opacity,
  strokeColor,
  strokeWidth,
  tooltipFunctions,
  label,
  labelStrokeColor,
  labelStrokeWidth,
  labelColor,
  labelProps,
  offChartLabelPosition,
  yAxisIntersectionX,
}) => {
  // This positions the label at the same point as the circle
  const defaultLabelPoints = [{ x: cx, y: cy }];
  // Extract points from generated label props
  const { points, ...generatedLabelProps } =
    label && labelProps ? labelProps(cx, cy, r, color) : {};
  // If a set of points has been generated, use these rather than the default
  let labelPoints = points || defaultLabelPoints;

  // Extract y position of first label point
  const [{ y: yPositionOfFirstLabelPoint }] = labelPoints;
  const aboveTopOfChart = yPositionOfFirstLabelPoint < 0;
  if (aboveTopOfChart) {
    // If the label is above the top of the chart, extract the x position
    const [{ x }] = labelPoints;
    // Set the a new label position at the top of the chart above all other labels
    const labelDotDiameter = r * 2;
    const offChartLabelXPosition =
      offChartLabelPosition === 'end' ? x : yAxisIntersectionX + labelDotDiameter;
    // If the chart has a margin, position the label at the top of the margin
    const offChartLabelYPosition = topSpacing > 0 ? -topSpacing + labelDotDiameter : 0;
    labelPoints = [{ x: offChartLabelXPosition, y: offChartLabelYPosition }];
  }

  return (
    <>
      {!aboveTopOfChart && (
        <Circle
          className="dot"
          cx={cx}
          cy={cy}
          r={r}
          fill={hollow ? 'none' : color}
          stroke={strokeColor || (hollow || strokeWidth ? color : 'none')}
          strokeWidth={strokeWidth || 3}
          fillOpacity={opacity}
          {...tooltipFunctions}
        />
      )}
      {label && (
        <DotLabel
          label={label}
          labelFill={labelColor}
          labelStrokeColor={labelStrokeColor}
          labelPoints={labelPoints}
          labelStrokeWidth={labelStrokeWidth}
          generatedLabelProps={generatedLabelProps}
          aboveTopOfChart={aboveTopOfChart}
        />
      )}
      {aboveTopOfChart && (
        <LabelArrow
          x={labelPoints[0].x}
          y={labelPoints[0].y}
          width={r * 2}
          fill={labelColor}
          stroke={labelStrokeColor}
          strokeWidth={labelStrokeWidth}
        />
      )}
    </>
  );
};

const Dots = ({
  width,
  height,
  margin,
  padding,
  data,
  seriesNames,
  // Scales
  xVariable,
  yVariable,
  sizeVariable,
  colorVariable,
  xScale,
  yScale,
  yTransformFunction,
  sizeScale,
  colorScale,
  labelColorScale,
  // Dot config
  hollowDots,
  opacity,
  strokeWidth,
  strokeColor,
  // Tooltips
  tooltipEvents,
  customTooltipComponent,
  tooltipPositionOverride, // @TODO add to prop types
  // Labels
  labelVariable,
  labelProps, // @TODO is this well-named?
  labelStrokeColor,
  labelStrokeWidth,
  offChartLabelPosition,
}) => {
  xScale.range([0, width]);
  yScale.range([height, 0]);

  const { top: marginTop, left: marginLeft } = margin;
  const { top: paddingTop, left: paddingLeft } = padding;
  const topSpacing = marginTop + paddingTop;
  const leftSpacing = marginLeft + paddingLeft;

  const DotsForSeries = ({ data: dataForSeries, seriesName }) => (
    <Group>
      {dataForSeries.map((dotData, i) => {
        const cx = xScale(dotData[xVariable]);
        const cy = yScale(
          yTransformFunction ? yTransformFunction(dotData[yVariable]) : dotData[yVariable]
        );
        const r = sizeScale(dotData[sizeVariable]);
        const color = colorScale(dotData[colorVariable]);
        const labelColor = labelColorScale ? labelColorScale(dotData[colorVariable]) : color;
        const label =
          labelVariable === 'label'
            ? dotData[labelVariable]
            : dotData.label && dotData[labelVariable];
        const { yAxisIntersectionX } = dotData;
        const scaledYAxisIntersectionX = yAxisIntersectionX && xScale(yAxisIntersectionX);

        const tooltipPosition = tooltipPositionOverride
          ? tooltipPositionOverride({
              data: dotData,
              xScale: (x) => leftSpacing + xScale(x),
              yScale: (y) => topSpacing + yScale(y),
            })
          : // Default position is a diameter above the dot
            { x: cx + leftSpacing, y: cy + topSpacing - r * 2 };

        const tooltipFunctions = tooltipEvents
          ? tooltipEvents(
              { content: customTooltipComponent ? dotData : dotData[labelVariable] },
              tooltipPosition
            )
          : {};

        return (
          <Dot
            key={`series_${seriesName}_${cx}_${cy}_${i}`}
            cx={cx}
            cy={cy}
            r={r}
            topSpacing={topSpacing}
            color={color}
            hollow={hollowDots}
            opacity={opacity}
            strokeWidth={strokeWidth}
            strokeColor={strokeColor}
            tooltipFunctions={tooltipFunctions}
            labelProps={labelProps}
            labelColor={labelColor}
            labelStrokeColor={labelStrokeColor}
            labelStrokeWidth={labelStrokeWidth}
            label={label}
            offChartLabelXPosition={offChartLabelPosition}
            yAxisIntersectionX={scaledYAxisIntersectionX}
          />
        );
      })}
    </Group>
  );

  return seriesNames ? (
    <Group>
      {seriesNames.map((seriesName) => {
        const dataForSeries = data[seriesName];
        return <DotsForSeries data={dataForSeries} seriesName={seriesName} />;
      })}
    </Group>
  ) : (
    <DotsForSeries data={data} seriesName="dots" />
  );
};

const MemoisedDots = React.memo(
  Dots,
  (prevProps, nextProps) => JSON.stringify(prevProps) === JSON.stringify(nextProps)
);

const DotsWithHighlights = ({
  data,
  showTooltips,
  seriesNames,
  highlightDotsOnHover,
  hoveredDotsStrokeColor,
  hoveredDotsStrokeWidth,
  hoveredDotsColorScale,
  hoveredDotsLabelColorScale,
  ...props
}) => {
  const { width, height, margin, padding, hoveredSeries, hoveredData, updateTooltip } = useContext(
    PlotContext
  );
  const tooltipEvents = useTooltipEvents({ enabled: showTooltips, updateTooltip });

  const scaleProperties = {
    yScaleType: inferScaleType(props.yScale),
    yScaleDomain: props.yScale.domain(),
    yScaleRange: props.yScale.range(),
    xScaleType: inferScaleType(props.xScale),
    xScaleDomain: props.xScale.domain(),
    xScaleRange: props.xScale.range(),
  };

  return (
    <>
      <MemoisedDots
        {...props}
        data={data}
        width={width}
        height={height}
        margin={margin}
        padding={padding}
        tooltipEvents={tooltipEvents}
        seriesNames={seriesNames}
        // This should force the dots to rerender when the scale properties change
        {...scaleProperties}
      />
      {/* For hovering over data with series (e.g. line chart) */}
      {highlightDotsOnHover && hoveredSeries && (
        <MemoisedDots
          {...props}
          data={data}
          width={width}
          height={height}
          margin={margin}
          padding={padding}
          tooltipEvents={tooltipEvents}
          seriesNames={hoveredSeries ? [hoveredSeries] : hoveredSeries}
          colorScale={hoveredDotsColorScale}
          labelColorScale={hoveredDotsLabelColorScale}
          // This should force the dots to rerender when the scale properties change
          {...scaleProperties}
        />
      )}
      {/* For hovering over points without series (e.g. bubble chart) */}
      {highlightDotsOnHover && hoveredData && (
        <MemoisedDots
          {...props}
          data={data.length ? data.filter((d) => d.seriesName === hoveredData.seriesName) : []}
          strokeColor={hoveredDotsStrokeColor}
          strokeWidth={hoveredDotsStrokeWidth}
          opacity={0}
          width={width}
          height={height}
          margin={margin}
          padding={padding}
          tooltipEvents={tooltipEvents}
          colorScale={hoveredDotsColorScale}
          labelColorScale={hoveredDotsLabelColorScale}
          // This should force the dots to rerender when the scale properties change
          {...scaleProperties}
        />
      )}
    </>
  );
};

Dots.propTypes = dotsComponentPropTypes;
Dots.defaultProps = dotsComponentDefaultProps;

export { DotsWithHighlights as Dots };
export default null;
