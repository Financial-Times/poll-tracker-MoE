/**
 * @file
 * legend
 */

import React from 'react';
import { scaleSqrt, scaleThreshold, scaleOrdinal } from '@visx/scale';
import { Group } from '@visx/group';
import { Drag } from '@visx/drag';
import LegendCategorical from './legendCategorical.js';
import LegendThreshold from './legendThreshold.js';
import LegendMagnitude from './legendMagnitude.js';
import { legendComponentPropTypes } from '../prop-types';
import { legendComponentDefaultProps } from '../default-props';
import { legendCategoricalStyles, legendThresholdStyles, legendMagnitudeStyles } from './styles.js';
import { getResponsiveValues } from '../../util';
import legendCategoricalData from '../../sample-data/legendCategorical.js';

const Legend = ({
  legendWidth,
  legendHeight,
  posX,
  posY,
  legendType,
  scale: customScale,
  invert,
  geometry,
  orientation,
  seriesNames: customSeriesNames,
  median,
  label,
  draggable,
}) => {
  const { tickLabelStyle } = getResponsiveValues(legendWidth);
  let renderedLegend;
  let css;
  let scale = customScale;
  let seriesNames = customSeriesNames;

  if (legendType === 'magnitude') {
    css = legendMagnitudeStyles;
    if (!scale) {
      scale = scaleSqrt({
        domain: [0, 5, 20],
        range: [0, 50],
      });
    }

    if (!seriesNames) {
      seriesNames = scale.domain();
    }
    seriesNames = [...seriesNames]
      .sort((a, b) => {
        return a - b;
      })
      // removes zeroes
      .filter(d => {
        return Number(d);
      });

    renderedLegend = (
      <LegendMagnitude
        seriesNames={seriesNames}
        scale={scale}
        fontSize={tickLabelStyle.fontSize}
        label={label}
      />
    );
  }
  if (legendType === 'threshold') {
    css = legendThresholdStyles;
    if (!scale) {
      scale = scaleThreshold({
        domain: [1.6, 3.3, 4.3, 5.4, 7, 10.1, 14.8, 20.1],
        range: ['#d6d3ea', '#adb8e6', '#849cdb', '#5e82c8', '#3968ad', '#1b4f8d', '#0a3866'],
      });
    }
    if (!seriesNames) {
      seriesNames = scale.domain();
    }
    renderedLegend = (
      <LegendThreshold
        scale={scale}
        invert={invert}
        width={legendWidth}
        height={legendHeight}
        orientation={orientation}
        fontSize={tickLabelStyle.fontSize}
        median={median}
        seriesNames={seriesNames}
      />
    );
  } else if (legendType === 'categorical') {
    css = legendCategoricalStyles;
    if (!scale) {
      scale = scaleOrdinal({
        domain: Object.keys(legendCategoricalData),
        range: Object.values(legendCategoricalData),
      });
    }
    if (!seriesNames) {
      seriesNames = scale.domain();
    }
    if (invert) {
      seriesNames.reverse();
    }
    renderedLegend = (
      <LegendCategorical
        scale={scale}
        seriesNames={seriesNames}
        orientation={orientation}
        geometry={geometry}
        fontSize={tickLabelStyle.fontSize}
      />
    );
  }
  return (
    <Drag width={legendWidth} height={legendHeight}>
      {({ dragStart, dragEnd, dragMove, dx, dy }) => {
        return (
          <Group
            id={legendType}
            css={css}
            onMouseMove={dragMove}
            onMouseUp={dragEnd}
            onMouseDown={dragStart}
            onTouchStart={dragStart}
            onTouchMove={dragMove}
            onTouchEnd={dragEnd}
            transform={
              // if position is pinned, then use that position and disable dragging
              // if position is not pinned, then allow dragging if draggable is true
              draggable ? `translate(${dx}, ${dy})` : `translate(${posX}, ${posY})`
            }
          >
            {renderedLegend}
          </Group>
        );
      }}
    </Drag>
  );
};

Legend.propTypes = legendComponentPropTypes;
Legend.defaultProps = legendComponentDefaultProps;

export default Legend;
