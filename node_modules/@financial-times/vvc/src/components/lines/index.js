/**
 * @file
 * Lines geometry
 */

import React, { useContext } from 'react';
import { LinePath } from '@visx/shape';
import { Group } from '@visx/group';
import { inferScaleType } from '@visx/scale';
import { PlotContext } from '../chart-frame/plot-context';
import { lineComponentPropTypes, linesComponentPropTypes } from '../prop-types';
import { lineComponentDefaultProps, linesComponentDefaultProps } from '../default-props';
import { isZeroOrDefined } from '../../util';

// Original line component
const LineWithContext = ({
  data,
  xVariable,
  yVariable,
  color, // @TODO This is a weird API. Should be like <Dots />
  xScale,
  yScale,
  yTransformFunction,
  yAccessor,
  xAccessor,
  width: propWidth,
  height: propHeight,
  strokeWidth,
  defined,
}) => {
  const { width, height } = useContext(PlotContext);

  xScale.rangeRound([0, propWidth || width]);
  yScale.rangeRound([propHeight || height, 0]);

  const xPosition = xAccessor || ((datum) => xScale(datum[xVariable]));
  const yPosition =
    yAccessor ||
    ((datum) =>
      yScale(yTransformFunction ? yTransformFunction(datum[yVariable]) : datum[yVariable]));

  return (
    <LinePath
      defined={defined}
      data={data}
      x={(datum) => datum && xPosition(datum)}
      y={(datum) => datum && yPosition(datum)}
      stroke={color}
      strokeWidth={strokeWidth}
      strokeLinecap="square"
      strokeLinejoin="round"
    />
  );
};

// Single line
const Line = ({ data, xPosition, yPosition, color, strokeWidth, defined }) => (
  <LinePath
    defined={defined}
    data={data}
    x={(datum) => datum && xPosition(datum)}
    y={(datum) => datum && yPosition(datum)}
    stroke={color}
    strokeWidth={strokeWidth}
    strokeLinecap="square"
    strokeLinejoin="round"
  />
);

// Series of lines
const Lines = ({
  width,
  height,
  seriesNames,
  data,
  xScale,
  xVariable,
  yScale,
  yTransformFunction,
  colorScale,
  strokeWidth,
  defined,
  highlightedLineOutlineWidth,
  highlightedLineOutlineColor,
}) => {
  xScale.rangeRound([0, width]);
  yScale.rangeRound([height, 0]);

  const xPosition = (datum) => xScale(datum[xVariable]);
  // yVariable is the seriesName
  const yPosition = (yVariable) => (datum) =>
    yScale(yTransformFunction ? yTransformFunction(datum[yVariable]) : datum[yVariable]);

  return seriesNames.map((seriesName) => (
    <Group key={`series_${seriesName}`}>
      {highlightedLineOutlineWidth > 0 && (
        <Line
          width={width}
          height={height}
          data={data.filter((d) => isZeroOrDefined(d[seriesName]))}
          xPosition={xPosition}
          yPosition={yPosition(seriesName)}
          color={highlightedLineOutlineColor}
          strokeWidth={highlightedLineOutlineWidth}
          defined={defined}
        />
      )}
      <Line
        width={width}
        height={height}
        data={data.filter((d) => isZeroOrDefined(d[seriesName]))}
        xPosition={xPosition}
        yPosition={yPosition(seriesName)}
        color={colorScale(seriesName)}
        strokeWidth={strokeWidth}
        defined={defined}
      />
    </Group>
  ));
};

const MemoisedLines = React.memo(
  Lines,
  (prevProps, nextProps) => JSON.stringify(prevProps) === JSON.stringify(nextProps)
);

const LinesWithContext = ({
  data,
  width: propWidth,
  height: propHeight,
  highlightLinesOnHover,
  hoveredLineStrokeWidth,
  hoveredLinesColorScale,
  highlightedLineOutlineWidth,
  ...props
}) => {
  const { width, height, hoveredSeries } = useContext(PlotContext);

  const scaleProperties = {
    yScaleType: inferScaleType(props.yScale),
    yScaleDomain: props.yScale.domain(),
    yScaleRange: props.yScale.range(),
    xScaleType: inferScaleType(props.xScale),
    xScaleDomain: props.xScale.domain(),
    xScaleRange: props.xScale.range(),
  };

  return (
    <Group>
      <MemoisedLines
        {...props}
        data={data}
        width={propWidth || width}
        height={propHeight || height}
        // This should force the lines to rerender when the scale properties change
        {...scaleProperties}
        highlightedLineOutlineWidth={highlightLinesOnHover ? 0 : highlightedLineOutlineWidth}
      />
      <MemoisedLines
        {...props}
        data={data}
        width={propWidth || width}
        height={propHeight || height}
        // This should force the lines to rerender when the scale properties change
        {...scaleProperties}
        strokeWidth={hoveredLineStrokeWidth}
        colorScale={hoveredLinesColorScale}
        seriesNames={highlightLinesOnHover ? [hoveredSeries] : []}
        highlightedLineOutlineWidth={highlightedLineOutlineWidth}
      />
    </Group>
  );
};

LineWithContext.propTypes = lineComponentPropTypes;
LineWithContext.defaultProps = lineComponentDefaultProps;
LinesWithContext.propTypes = linesComponentPropTypes;
LinesWithContext.defaultProps = linesComponentDefaultProps;

export { LineWithContext as Line, LinesWithContext as Lines };
export default null;
