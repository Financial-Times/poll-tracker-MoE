/**
 * @file
 * Line chart template
 */

import React from 'react';
import { scaleLinear, scaleTime, scaleOrdinal, scaleLog } from '@visx/scale';
import { extent } from 'd3-array';
import * as GChartcolour from 'g-chartcolour';
import { Group } from '@visx/group';
import { formatData, getSeriesNames, extentMulti } from '../../util/parseData';
import Legend from '../../components/legend';
import ChartFrame from '../../components/chart-frame';
import { Lines } from '../../components/lines';
import Axis from '../../components/axis';
import { Dots } from '../../components/dots';
import { lineChartPropTypes } from '../../components/prop-types';
import { lineChartDefaultProps } from '../../components/default-props';
import { isZeroOrDefined, identity } from '../../util';
import Delaunay from '../../components/delaunay';
import AxisFade from './axis-fade';

const LineChart = (props) => {
  const {
    data: rawData,
    // Axis and scale
    xAxisOrientation,
    yAxisOrientation,
    logScale,
    yTickValues,
    additionalYTickValues,
    yTickFormat,
    yFullLengthTicks,
    yMin: yMinOverride,
    yMax: yMaxOverride,
    xScaleType,
    xTickValues,
    xTickFormat,
    xFullLengthTicks,
    xMin: xMinOverride,
    xMax: xMaxOverride,
    yTransformFunction,
    hideEndTicks,
    additionalAxisStyles,
    xAxisLabel,
    xAxisLabelOffset,
    xAxisLabelProps,
    // Base
    height,
    margin,
    width,
    // <ChartFrame />
    type,
    hideTopper,
    hideFooter,
    hideTitleTooltip,
    stabRule,
    description,
    // Lines
    xVariable,
    yVariable,
    // Legend
    showLegend,
    // Line end dots
    showLineEndDots,
    labelStrokeColor,
    labelStrokeWidth,
    // Highlights
    seriesToHighlight,
    // Tooltips
    showTooltips,
    tooltipStyle,
    tooltipComponent,
    showTooltipLine,
    allLinesHoverable,
    hoverRadius,
    // Color palettes
    lineColorPalette,
    labelColorPalette,
    ghostLineColor,
    ghostLineHoverColorScale,
    ghostLineHoverLabelColorScale,
    // Line outline/halo
    highlightedLineOutlineWidth,
    // Y-Axis fade
    showYAxisFade,
  } = props;
  const data = xScaleType === 'time' ? formatData(rawData, '%-d/%-m/%Y') : rawData;
  const seriesNames = Array.isArray(data) && data.length ? getSeriesNames(data) : [];

  const yValueExtent = extentMulti(data, seriesNames);
  // yMin cannot be zero for a log scale
  const yMin = isZeroOrDefined(yMinOverride)
    ? yMinOverride
    : logScale && yValueExtent[0] === 0
    ? 1
    : yValueExtent[0];
  const yMax = yMaxOverride || yValueExtent[1];
  const transformedYMin = yTransformFunction ? yTransformFunction(yMin) : yMin;
  const transformedYMax = yTransformFunction ? yTransformFunction(yMax) : yMax;
  const yScale = logScale
    ? scaleLog({ domain: [transformedYMin, transformedYMax] })
    : scaleLinear({
        domain: [transformedYMin, transformedYMax],
      });

  const xValueExtent = extent(data, (d) => d[xVariable]);
  const xMin = xMinOverride || xValueExtent[0];
  const xMax = xMaxOverride || xValueExtent[1];
  const xScale =
    xScaleType === 'time'
      ? scaleTime({
          domain: [xMin, xMax],
        })
      : scaleLinear({ domain: [xMin, xMax] });

  if (hideEndTicks) {
    // Before we hide the last tick, make sure the scale is rounded out
    xScale.nice();
  }

  /* eslint-disable no-nested-ternary */
  const colorScaleDomain = yVariable.length
    ? yVariable
    : seriesToHighlight.length
    ? seriesToHighlight
    : seriesNames;
  const colorScaleDefaultRange =
    type === 'print'
      ? GChartcolour.linePrint
      : type === 'social' || type === 'video'
      ? GChartcolour.lineSocial
      : GChartcolour.lineWeb;
  /* eslint-enable no-nested-ternary */

  const lineColorScale = scaleOrdinal({
    domain: colorScaleDomain,
    range: lineColorPalette || colorScaleDefaultRange,
  });

  const labelColorScale = labelColorPalette
    ? scaleOrdinal({ domain: colorScaleDomain, range: labelColorPalette })
    : lineColorScale;

  const nonEmptyYVariable = Array.isArray(yVariable) && yVariable.length;
  const seriesToShow = nonEmptyYVariable ? yVariable : seriesNames;

  const nonEmptySeriesToHighlight = Array.isArray(seriesToHighlight) && seriesToHighlight.length;
  // Generate line end dot for each line
  const lineEndDots = showLineEndDots
    ? seriesNames.reduce((acc, series) => {
        const sortedData = [...data].sort((a, b) => a[xVariable] - b[xVariable]);
        const reverseSortedData = [...sortedData].reverse();
        const endEntry = reverseSortedData.find((d) => isZeroOrDefined(d[series]));
        // Find the first entry that is greater than yMax
        const firstIntersectionEntry = sortedData.find(
          (d) => isZeroOrDefined(d[series]) && d[series] > yMax
        );

        return {
          ...acc,
          [series]: [
            {
              color: series,
              x: endEntry[xVariable],
              y: endEntry[series],
              yAxisIntersectionX: firstIntersectionEntry && firstIntersectionEntry[xVariable],
              label: true,
              labelText: series,
            },
          ],
        };
      }, {})
    : {};

  // Filter out highlights from main array so we don't draw them twice
  const seriesToShowFiltered = nonEmptySeriesToHighlight
    ? seriesToShow.filter((s) => !seriesToHighlight.includes(s))
    : seriesToShow;

  const showAllSeriesAsGhostLines = nonEmptyYVariable && nonEmptySeriesToHighlight === 0;

  // Format data for voronoi
  const voronoiData = allLinesHoverable
    ? data.flatMap((d) =>
        seriesNames.map((e) => ({
          [xVariable]: d[xVariable],
          y: d[e],
          seriesName: e,
          labelData: { seriesName: e, yValue: d[e], xValue: d[xVariable] },
          isHighlighted: seriesToHighlight.includes(e),
        }))
      )
    : nonEmptySeriesToHighlight
    ? data
        .filter((d) => seriesToHighlight.some((seriesName) => isZeroOrDefined(d[seriesName]))) // Or empty string
        .flatMap((d) =>
          seriesToHighlight.map((e) => ({
            [xVariable]: d[xVariable],
            y: d[e],
            seriesName: e,
            labelData: { seriesName: e, yValue: d[e], xValue: d[xVariable] },
            isHighlighted: seriesToHighlight.includes(e),
          }))
        )
    : [];

  return (
    <ChartFrame
      type={type}
      width={width}
      height={height}
      margin={margin}
      stabRule={stabRule}
      description={description}
      tooltipStyle={tooltipStyle}
      tooltipComponent={tooltipComponent}
      hideTopper={hideTopper}
      hideFooter={hideFooter}
      hideTitleTooltip={hideTitleTooltip}
    >
      {/* x-axis */}
      <Axis
        orientation={xAxisOrientation}
        scale={xScale}
        fullLengthTicks={xFullLengthTicks}
        hideEndTicks={hideEndTicks}
        additionalAxisStyles={additionalAxisStyles}
        label={xAxisLabel}
        labelOffset={xAxisLabelOffset}
        labelProps={xAxisLabelProps}
        tickValues={xTickValues}
        tickFormat={xTickFormat}
      />

      {/* y-axis */}
      <Axis
        orientation={yAxisOrientation}
        scale={yScale}
        tickValues={yTickValues}
        additionalTickValues={additionalYTickValues}
        // Use custom y tick format if set, if log scale default to identity function
        tickFormat={yTickFormat || (logScale && identity)}
        fullLengthTicks={yFullLengthTicks}
        additionalAxisStyles={additionalAxisStyles}
      />

      {showYAxisFade && <AxisFade orientation="vertical" id="gradientMask" />}

      {showLegend && <Legend {...props} scale={lineColorScale} shape="line" />}

      <Group id="lines" mask={showYAxisFade && `url(#gradientMask)`}>
        <Group id="background-lines">
          <Lines
            seriesNames={seriesToShowFiltered}
            data={data}
            xScale={xScale}
            xVariable={xVariable}
            yScale={yScale}
            yTransformFunction={yTransformFunction}
            colorScale={
              nonEmptySeriesToHighlight || showAllSeriesAsGhostLines
                ? () => ghostLineColor
                : lineColorScale
            }
            strokeWidth={nonEmptySeriesToHighlight || showAllSeriesAsGhostLines ? 1 : 3}
            highlightLinesOnHover={allLinesHoverable}
            hoveredLinesColorScale={ghostLineHoverColorScale}
            highlightedLineOutlineWidth={highlightedLineOutlineWidth}
          />
        </Group>
        <Group id="highlighted-lines">
          {nonEmptySeriesToHighlight && (
            <Lines
              seriesNames={seriesToHighlight}
              data={data}
              xScale={xScale}
              xVariable={xVariable}
              yScale={yScale}
              yTransformFunction={yTransformFunction}
              colorScale={lineColorScale}
              highlightedLineOutlineWidth={highlightedLineOutlineWidth}
            />
          )}
        </Group>
      </Group>

      {showLineEndDots && (
        <Dots
          seriesNames={seriesToHighlight}
          data={lineEndDots}
          xScale={xScale}
          xVariable="x"
          yScale={yScale}
          yTransformFunction={yTransformFunction}
          yVariable="y"
          colorScale={lineColorScale}
          colorVariable="color"
          labelVariable="labelText"
          labelColorScale={labelColorScale}
          labelProps={(cx, cy, r, color) => ({
            labelAnchor: 'start',
            points: [{ x: cx, y: cy }],
            // @TODO change to scaled font value
            labelFontSize: 18,
            labelDx: 2 * r,
            labelDy: r,
          })}
          strokeColor="#fff1e5"
          strokeWidth={1}
          labelStrokeColor={labelStrokeColor}
          labelStrokeWidth={labelStrokeWidth}
          highlightDotsOnHover={allLinesHoverable}
          hoveredDotsColorScale={ghostLineHoverColorScale}
          hoveredDotsLabelColorScale={ghostLineHoverLabelColorScale}
        />
      )}

      {showTooltips &&
        ((showAllSeriesAsGhostLines && allLinesHoverable) || nonEmptySeriesToHighlight) && (
          <Delaunay
            xScale={xScale}
            yScale={yScale}
            colorScale={lineColorScale}
            xVariable={xVariable}
            yVariable="y"
            data={voronoiData}
            yTransformFunction={yTransformFunction}
            tooltipPositionOverride={({ data, xScale, yScale }) => ({
              x: xScale(data.date),
              y: yScale(yMax),
            })}
            showLine={showTooltipLine}
            showCircle={showTooltipLine}
            lineConfig={{
              stroke: '#33302e',
              strokeDasharray: '3, 1',
            }}
            circleConfig={{
              r: 5,
              stroke: '#fff1e5',
              strokeWidth: 1,
            }}
            hoverRadius={hoverRadius}
            // debug
          />
        )}
    </ChartFrame>
  );
};

LineChart.propTypes = lineChartPropTypes;
LineChart.defaultProps = lineChartDefaultProps;

export default LineChart;
