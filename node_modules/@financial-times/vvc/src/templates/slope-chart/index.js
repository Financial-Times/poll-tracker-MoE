/**
 * @file
 * Slope chart template
 */

import React, { useContext } from 'react';
import PropTypes from 'prop-types';
import { scalePoint, scaleLinear } from '@visx/scale';
import { css } from '@emotion/core';
import { Group } from '@visx/group';
import { uk } from '@financial-times/politics';
import { Line } from '../../components/lines';
import ChartFrame from '../../components/chart-frame';
import { PlotContext } from '../../components/chart-frame/plot-context';

const sortTwoDateStringsAsc = (a, b) => new Date(a).valueOf() - new Date(b).valueOf();
const getLastValue = (arr) =>
  [...arr].sort(({ date: a }, { date: b }) => new Date(a).valueOf() - new Date(b).valueOf()).pop()
    .value;

export const Slopes = ({
  data,
  electionDates,
  circRadius,
  maxLabelLength,
  independentOverrides,
}) => {
  const { width, height } = useContext(PlotContext);
  const byelectionDates = Object.entries(data)
    .filter(
      ([date, parties]) => !electionDates.includes(date) && Object.values(parties).some((i) => i)
    )
    .map(([date]) => date);

  // Find the date of the last complete election
  const [lastElection] = Object.keys(data).sort(
    (a, b) => new Date(b).valueOf() - new Date(a).valueOf()
  );
  const [winnerVotePctLastElection] = Object.values(data[lastElection]).sort((a, b) => b - a);
  const hadByElection = byelectionDates.length > 0;

  const groups = Object.entries(data).reduce((acc, [date, parties]) => {
    Object.entries(parties).forEach(([p, value]) => {
      try {
        const { shortName } = uk.getPartyInfo(p); // Will throw if unknown party
        // Use full independent name if in parantheses
        const identifier = shortName === 'Ind' && /Independent\s?\(.+?\)/.test(p) ? p : shortName;
        const dates = acc.get(identifier) || [];
        acc.set(identifier, [...dates, { date, value }]);
      } catch (e) {
        // Show other other parties if within 25% of leader
        if (winnerVotePctLastElection - value <= 25 || independentOverrides.includes(p)) {
          const dates = acc.get(p) || [];
          acc.set(p, [...dates, { date, value }]);
        }
      }
    });

    return acc;
  }, new Map());

  const xScale = scalePoint({
    domain: [...byelectionDates, ...electionDates].sort(sortTwoDateStringsAsc),
    range: [0, width],
    round: true,
  });

  const maxValue = Math.max(...[...groups.values()].flat().map((d) => d.value));
  const yScale = scaleLinear({
    domain: [0, maxValue < 90 ? maxValue + 10 : maxValue],
    range: [height, 0],
    round: true,
  });

  const minLabelDist = 15;
  const positionLabels = (labels, spacing, alpha) => {
    labels.forEach((d1) => {
      if (!d1.some((d) => d.date === lastElection)) return;
      if (!d1.position) d1.position = yScale(getLastValue(d1)); // eslint-disable-line no-param-reassign
      const y1 = d1.position;
      const a1 = getLastValue(d1);
      labels.forEach((d2) => {
        if (!d2.some((d) => d.date === lastElection)) return;
        if (!d2.position) d2.position = yScale(getLastValue(d2)); // eslint-disable-line no-param-reassign
        const y2 = d2.position;
        const a2 = getLastValue(d2);

        /* Difference between current averages for each party
          This ensures the parties are always in the correct order */
        const deltaA = a1 - a2;

        /* Difference between current positions
          When this is below the required minimum spacing the positioning
          algorithm should stop */
        const deltaY = y1 - y2;

        if (d1 !== d2 && Math.abs(deltaY) <= spacing) {
          const sign = deltaA > 0 ? -1 : 1;
          const adjust = sign * alpha;

          d1.position = +y1 + adjust; // eslint-disable-line no-param-reassign
          d2.position = +y2 - adjust; // eslint-disable-line no-param-reassign

          positionLabels(labels, spacing, alpha);
        }
      });
    });
  };

  positionLabels(groups, minLabelDist, 1);

  return (
    <Group top={20}>
      <Group left={width + 20} className="slope-chart__legend legend">
        {[...groups.entries()].map(([groupName, group], idx, arr) => {
          const lastValue = getLastValue(group);
          // Make sure it's been in the last election
          if (!group.some((d) => d.date === lastElection) || !lastValue) return null;
          const isFrontrunner = arr.every(([, val]) => lastValue >= getLastValue(val));
          // Check if it's a special independent (name is in parenthesis)
          const specialInd = /Independent\s?\(/.test(groupName);
          const [, nameInParenthOriginal] = groupName.match(/\((.+?)\)/) || [];
          const nameInParenth = nameInParenthOriginal
            ? nameInParenthOriginal.split(' ').reverse()[0]
            : '';
          const partyFill = (() => {
            try {
              return uk.getPartyInfo(groupName).color;
            } catch (e) {
              return uk.getPartyInfo('Others').color;
            }
          })();
          const labelValue = (() => {
            try {
              return specialInd ? nameInParenth : uk.getPartyInfo(groupName).shortName;
            } catch (e) {
              return `${groupName.slice(0, maxLabelLength)}...`;
            }
          })();

          return (
            <Group key={groupName} top={group.position}>
              <rect
                width={5}
                height={12}
                fill={partyFill}
                stroke={groupName === 'Speaker' ? '#B2AFAD' : 'none'}
              />
              <text fill="#33302e" dx={12} dy={11}>
                <tspan
                  css={css`
                    font-weight: ${isFrontrunner ? 600 : 400};
                    font-size: 16px;
                  `}
                >
                  {+lastValue.toFixed(1)}% {labelValue}
                </tspan>
              </text>
            </Group>
          );
        })}
      </Group>
      <Group className="slope-chart__axes axis">
        {electionDates.map((d) => {
          const [year] = d.split('-');
          return (
            <Group key={d} left={xScale(d)}>
              <text
                stroke="#33302e"
                style={{ fontFamily: 'MetricWeb', fontWeight: 100, fontSize: '14px' }}
                textAnchor="middle"
              >
                {year}
              </text>
              <line stroke="#b3a9a0" x1="0" x2="0" y1="5" y2={height} />
            </Group>
          );
        })}
        {hadByElection &&
          byelectionDates.map((d) => {
            const pad = 16;
            // const [year] = d.split('-');
            return (
              <Group key={d} left={xScale(d)} top={Number(`-${pad}`)}>
                <text
                  stroke="#33302e"
                  style={{
                    textTransform: 'uppercase',
                    fontFamily: 'MetricWeb',
                    fontWeight: 100,
                    fontSize: '12px',
                  }}
                  textAnchor="middle"
                >
                  {/* By-Election ({year}) */}
                  By-Election
                </text>
                <line
                  stroke="#b3a9a0"
                  strokeDasharray="5, 5"
                  x1="0"
                  x2="0"
                  y1="5"
                  y2={height + pad}
                />
              </Group>
            );
          })}
      </Group>
      <Group className="slope-chart__lines lines" top={10}>
        {[...groups.entries()]
          .sort(([, a], [, b]) => {
            const lastElectionA = a.find((d) => d.date === lastElection) || {};
            const lastElectionB = b.find((d) => d.date === lastElection) || {};
            return lastElectionA.value - lastElectionB.value;
          })
          .map(([groupName, group]) => {
            const partyFill = (() => {
              try {
                return uk.getPartyInfo(groupName).color;
              } catch (e) {
                return uk.getPartyInfo('Others').color;
              }
            })();
            return (
              <Line
                key={groupName}
                color={partyFill}
                xVariable="date"
                yVariable="value"
                defined={(d) => d.value !== null}
                xScale={xScale}
                yScale={yScale}
                data={[...group].sort(
                  ({ date: dateA }, { date: dateB }) =>
                    new Date(dateB).valueOf() - new Date(dateA).valueOf()
                )}
                width={width}
                height={height - 10}
              />
            );
          })}
      </Group>
      <Group className="slope-chart__dots dots" top={10}>
        {[...groups.entries()]
          .sort(([, a], [, b]) => {
            const lastElectionA = a.find((d) => d.date === lastElection) || {};
            const lastElectionB = b.find((d) => d.date === lastElection) || {};
            return lastElectionA.value - lastElectionB.value;
          })
          .map(([groupName, group]) => {
            const circX = xScale.copy().rangeRound([0, width]);
            const circY = yScale.copy().rangeRound([height - 10, 0]);
            const partyFill = (() => {
              try {
                return uk.getPartyInfo(groupName).color;
              } catch (e) {
                return uk.getPartyInfo('Others').color;
              }
            })();
            const stroke = groupName === 'Speaker' ? '#B2AFAD' : 'none';

            return [...group]
              .sort((a, b) => b.value - a.value)
              .map(
                (g) =>
                  g.value && (
                    <circle
                      r={circRadius}
                      fill={partyFill}
                      cx={circX(g.date)}
                      cy={circY(g.value)}
                      stroke={stroke}
                    />
                  )
              );
          })}
      </Group>
    </Group>
  );
};

const SlopeChart = ({ type, ...props }) => {
  switch (type) {
    case 'social':
      return (
        <ChartFrame
          css={css`
            .axis text,
            .axis line {
              stroke: white;
            }
          `}
          padding={{ top: 0, right: 200, bottom: 0, left: 30 }}
          subtitle="Total votes"
          {...props}
        >
          <Slopes {...props} />
        </ChartFrame>
      );
    default:
      break;
  }
  return (
    <ChartFrame {...props} padding={{ top: 0, left: 30, bottom: 0, right: 200 }}>
      <Slopes {...props} />
    </ChartFrame>
  );
};

Slopes.defaultProps = {
  data: {},
  electionDates: ['2015-05-07', '2017-06-08', '2019-12-12'],
  circRadius: 5,
  maxLabelLength: 15,
  independentOverrides: [],
};

Slopes.propTypes = {
  data: PropTypes.shape({
    '2015-05-07': PropTypes.object.isRequired,
    '2017-06-08': PropTypes.object.isRequired,
  }),
  electionDates: PropTypes.arrayOf(PropTypes.any),
  circRadius: PropTypes.number,
  maxLabelLength: PropTypes.number,
  independentOverrides: PropTypes.arrayOf(PropTypes.string),
};

SlopeChart.propTypes = {
  type: PropTypes.oneOf(['social']),
  independentOverrides: PropTypes.arrayOf(PropTypes.string),
};

SlopeChart.defaultProps = {
  type: undefined,
  independentOverrides: [],
};

export default SlopeChart;
