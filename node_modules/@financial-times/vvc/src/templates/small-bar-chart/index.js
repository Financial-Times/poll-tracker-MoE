/**
 * @file
 * Small bar chart template
 */

import React, { useContext } from 'react';
import { scaleBand, scaleLinear } from '@visx/scale';
import { Group } from '@visx/group';
import { max } from 'd3-array';
import { approximateTextSize } from '../../util/victory-textsize';
import ChartFrame from '../../components/chart-frame';
import { PlotContext } from '../../components/chart-frame/plot-context';
import Bars from '../../components/bars';
import { smallBarChartPropTypes } from '../../components/prop-types';
import { smallBarChartDefaultProps } from '../../components/default-props';

const chartTopperConfig = {
  stabRule: false,
  titleStyle: {
    fontSize: 18,
    fontWeight: 600,
  },
  titlePosition: {
    x: 1,
    y: 18,
  },
  subtitle: false,
};

const chartFooterConfig = {
  sourceFontSize: 14,
  sourcePosition: {
    x: 1,
  },
  sourcePlotYOffset: 0,
  copyright: false,
};

const SmallBars = ({
  paddingBetweenLabels,
  paddingAfterLabels,
  // <Bars />
  data,
  xVariable,
  yVariable,
  colorScale,
  colorVariable,
  // base
  ...props
}) => {
  const { height, padding, updatePadding } = useContext(PlotContext);
  // Construct scales *without* specifying ranges. Components that receive scales as props will specify their own ranges based on the width/height props they receive (directly or via <ChartFrame />)
  const xScale = scaleLinear({
    domain: [0, max(data, d => d[xVariable])],
  });
  const yScale = scaleBand({
    domain: data.map(d => d[yVariable]),
    padding: 0.4,
    range: [height, 0],
  });

  const maxYVariableTextSize = Math.max(
    ...data
      .map(d => d[yVariable].toUpperCase())
      .map(
        d =>
          approximateTextSize(d, {
            fontFamily: 'MetricWeb-Regular',
            fontSize: 14,
          }).width
      )
  );

  const maxXVariableTextSize = Math.max(
    ...data
      .map(d => `${d[xVariable]}%`.toUpperCase())
      .map(
        d =>
          approximateTextSize(d, {
            fontFamily: 'MetricWeb',
            fontWeight: 600,
            fontSize: 16,
          }).width
      )
  );

  const totalLabelSize =
    maxYVariableTextSize + maxXVariableTextSize + paddingBetweenLabels + paddingAfterLabels;

  if (padding.right === 50) updatePadding({ left: totalLabelSize, right: 0 });

  return (
    <Group>
      <Bars
        {...props}
        data={data}
        colorScale={colorScale}
        colorVariable={colorVariable}
        xScale={xScale}
        xVariable={xVariable}
        yScale={yScale}
        yVariable={yVariable}
      />
      <Group>
        {data.map(d => (
          <Group
            key={`label__${d[yVariable]}`}
            left={-totalLabelSize}
            top={yScale(d[yVariable]) + yScale.bandwidth() - (18 - yScale.bandwidth())}
          >
            <text fontSize={14}>{d[yVariable].toUpperCase()}</text>
            <text
              textAnchor="end"
              x={totalLabelSize - paddingAfterLabels}
              fontWeight={600}
            >{`${d[xVariable]}%`}</text>
          </Group>
        ))}
      </Group>
    </Group>
  );
};

const SmallBarChart = props => {
  return (
    <ChartFrame type="web" {...props} {...chartTopperConfig} {...chartFooterConfig}>
      <SmallBars {...props} />
    </ChartFrame>
  );
};

SmallBars.propTypes = smallBarChartPropTypes;
SmallBars.defaultProps = smallBarChartDefaultProps;

export default SmallBarChart;
