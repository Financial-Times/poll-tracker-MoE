/**
 * @file
 * Waffle chart template
 */

import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import { Group } from '@visx/group';
import { scaleLinear } from '@visx/scale';
import { uk } from '@financial-times/politics';
import ChartFrame from '../../components/chart-frame';

const { getPartyInfo } = uk;

const WaffleAxis = ({ width, ...props }) => {
  const scale = scaleLinear({
    range: [0, width],
    domain: [0, 30],
  });
  return (
    <Group className="waffle--axis">
      <Group className="waffle--axis__labels">
        <text x={0} textAnchor="beginning" fontSize={13} fill="#33302E" letterSpacing="0.3">
          MORE VULNERABLE SEATS
        </text>
        <text x={width} textAnchor="end" fontSize={13} fill="#33302E" letterSpacing="0.3">
          SAFER SEATS
        </text>
      </Group>
      <path
        className="waffle--axis__arrows"
        stroke="#66605C"
        fill="#66605C"
        transform="translate(0,8)"
        d={`M8,4 L8,0 L0,4 L8,8 L8,4 L${width - 8},4 L${width - 8},0 L${width},4 L${width -
          8},8 L${width - 8},4`}
      />
      <Group top="12" className="waffle--axis__ticks">
        {Array(6)
          .fill(null)
          .map((d, i) => {
            return (
              <>
                {i && <line x1={scale(i * 5)} x2={scale(i * 5)} y1="0" y2="8" stroke="#66605C" />}
                <text
                  x={scale(i * 5)}
                  dx="0"
                  y="24"
                  fill="#66605C"
                  textAnchor={i === 0 ? 'start' : 'middle'}
                >
                  {i * 5}
                  {i * 5 === 25 ? '%+' : '%'}
                </text>
              </>
            );
          })}
      </Group>
    </Group>
  );
};

WaffleAxis.propTypes = {
  width: PropTypes.number.isRequired,
  margin: PropTypes.shape({
    left: PropTypes.number,
    top: PropTypes.number,
    right: PropTypes.number,
    bottom: PropTypes.number,
  }),
};

WaffleAxis.defaultProps = {
  margin: {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
  },
};

const WafflePartyRow = ({
  tileHeight,
  tilePadding,
  width,
  columnsPerSegment,
  data,
  top,
  diff,
  onSelect,
  onDeselect,
  order,
}) => {
  const [partyName, results = []] = data;
  return (
    <Group className="waffle--row" transform={`translate(0, ${top})`}>
      {order && <line x1={0} x2={width} y1={-16} y2={-16} stroke="#CCC1B7" />}
      <text>
        <tspan style={{ fontWeight: 500, fontSize: '14px', letterSpacing: '0.3', fill: '#66605C' }}>
          {getPartyInfo(partyName).formattedName.toUpperCase()}
        </tspan>{' '}
        {/* eslint-disable-next-line no-nested-ternary */}
        {diff ? `(${Math.abs(diff)} seats ${diff === 0 ? 'held' : diff > 0 ? 'won' : 'lost'})` : ''}
      </text>
      {results.map((segment = [], colIdx) => {
        const colWidth = width / 6;
        const leftOffset = colWidth * colIdx;
        return (
          <Group top="10">
            {[...segment]
              .sort((a, b) => +a.margin2017 - +b.margin2017)
              .map(({ constituencyPartyWinning, ...d }, idx) => {
                const x = idx % columnsPerSegment;
                const y = Math.floor(idx / columnsPerSegment);
                return (
                  <rect
                    onMouseOver={({ clientX, clientY }) => onSelect([d, { clientX, clientY }])}
                    onFocus={({ clientX, clientY }) => onSelect([d, { clientX, clientY }])}
                    onTouchStart={({ clientX, clientY }) => onSelect([d, { clientX, clientY }])}
                    onMouseOut={() => onDeselect([{}, null])}
                    onBlur={() => onDeselect([{}, null])}
                    width={tileHeight}
                    height={tileHeight}
                    strokeWidth={constituencyPartyWinning === 'The Speaker' ? '1px' : tilePadding}
                    stroke={constituencyPartyWinning === 'The Speaker' ? '#B2AFAD' : 'transparent'}
                    x={leftOffset + x * (tileHeight + tilePadding)}
                    y={y * (tileHeight + tilePadding)}
                    fill={
                      constituencyPartyWinning
                        ? getPartyInfo(constituencyPartyWinning).color
                        : '#fcd0b1'
                    }
                  />
                );
              })}
          </Group>
        );
      })}
    </Group>
  );
};

WafflePartyRow.propTypes = {
  width: PropTypes.number.isRequired,
  columnsPerSegment: PropTypes.number.isRequired,
  data: PropTypes.arrayOf(PropTypes.any).isRequired,
  top: PropTypes.number.isRequired,
  diff: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]).isRequired,
  onSelect: PropTypes.func,
  onDeselect: PropTypes.func,
  tileHeight: PropTypes.number,
  tilePadding: PropTypes.number,
  order: PropTypes.number.isRequired,
};

WafflePartyRow.defaultProps = {
  onSelect: () => {},
  onDeselect: () => {},
  tileHeight: 8,
  tilePadding: 2,
};

export const WaffleChart = ({
  eventCallback,
  data,
  filterKeys,
  columnsPerSegment,
  tileHeight,
  subtitle,
  ...props
}) => {
  const parties = useMemo(
    () =>
      [
        ...data
          .reduce(
            (a, d) =>
              a.set(d.constituencyPartySittingLastElection, [
                ...(a.get(d.constituencyPartySittingLastElection) || []),
                d,
              ]),
            new Map()
          )
          .entries(),
      ]
        .filter(([key]) => filterKeys.includes(key))
        .sort(([, valuesA], [, valuesB]) => valuesB.length - valuesA.length)
        .map(([key, values]) => {
          return [
            key,
            [
              ...values
                .reduce((a, c) => {
                  if (c.constituencyMarginLastElection >= 25) {
                    return a.set(25, [...(a.get(25) || []), c]);
                  }
                  if (c.constituencyMarginLastElection >= 20) {
                    return a.set(20, [...(a.get(20) || []), c]);
                  }
                  if (c.constituencyMarginLastElection >= 15) {
                    return a.set(15, [...(a.get(15) || []), c]);
                  }
                  if (c.constituencyMarginLastElection >= 10) {
                    return a.set(10, [...(a.get(10) || []), c]);
                  }
                  if (c.constituencyMarginLastElection >= 5) {
                    return a.set(5, [...(a.get(5) || []), c]);
                  }
                  return a.set(0, [...(a.get(0) || []), c]);
                }, new Map([[0], [5], [10], [15], [20], [25]]))
                .values(),
            ],
          ];
        }),
    [data, filterKeys]
  );

  const offsetHeights = useMemo(
    () =>
      parties.map((d, i, arr) =>
        arr
          .slice(0, i)
          .map(
            ([, segments]) =>
              ([...segments].sort((a, b) => b.length - a.length)[0].length / columnsPerSegment) *
              tileHeight
          )
          .reduce((a, b) => a + b, 0)
      ),
    [columnsPerSegment, parties, tileHeight]
  );

  const titleHeightPlusBottomPadding = 72;
  const axisHeight = 72;

  // Calculation used for determining margin top
  // if subtitle is explicitly empty, then assume 0 line subhead
  // if subtitle is not filled in, then assume 1 line subhead (default value from chart frame)
  // if subtitle has content, count number of pipes to get number of lines
  let subtitleLines = 1;
  if (subtitle === '') {
    subtitleLines = 0;
  } else if (subtitle) {
    subtitleLines = subtitle.split('').filter(a => a === '|').length + 1;
  }

  return (
    <ChartFrame
      {...props}
      subtitle={subtitle}
      margin={{ top: 80 + subtitleLines * 20, right: 0, left: 0, bottom: 105 }}
      padding={{ top: 0, right: 2, bottom: 0, left: 2 }}
    >
      <WaffleAxis />
      {parties.map((party, i) => (
        <WafflePartyRow
          onSelect={eventCallback}
          onDeselect={eventCallback}
          columnsPerSegment={columnsPerSegment}
          top={i * titleHeightPlusBottomPadding + offsetHeights[i] + axisHeight}
          data={party}
          order={i}
        />
      ))}
    </ChartFrame>
  );
};

WaffleChart.propTypes = {
  data: PropTypes.arrayOf(
    PropTypes.shape({
      type: PropTypes.string.isRequired,
      constituencyName: PropTypes.string.isRequired,
      constituencyCode: PropTypes.string.isRequired,
      constituencyPartySitting: PropTypes.string.isRequired,
      constituencyPartySittingLastElection: PropTypes.string.isRequired,
      constituencyMarginLastElection: PropTypes.number.isRequired,
      constituencyPartyWinning: PropTypes.string,
      constituencyTimeChangedFirst: PropTypes.string,
      constituencyTimeChangedLast: PropTypes.string,
      constituencyTimeDeclared: PropTypes.string,
    })
  ).isRequired,
  filterKeys: PropTypes.arrayOf(PropTypes.string),
  columnsPerSegment: PropTypes.number,
  tileHeight: PropTypes.number,
  eventCallback: PropTypes.func,
};
WaffleChart.defaultProps = {
  filterKeys: [],
  columnsPerSegment: 10,
  tileHeight: 8,
  eventCallback: console.log, // eslint-disable-line
};

export default WaffleChart;
