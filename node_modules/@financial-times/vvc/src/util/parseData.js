/**
 * General data munging functionality
 */

import { extent } from 'd3-array';
import { timeParse } from 'd3-time-format';

/**
 * Returns dataset with date types in date column
 * @param  {[type]} data       [description]
 * @param  {[type]} dateFormat [description]
 * @return {[type]}            [description]
 */
export function formatData(data, dateFormat) {
  const parseDate = timeParse(dateFormat);
  // eslint-disable-next-line no-prototype-builtins
  if (data[0].hasOwnProperty('date')) {
    return data.map(point => ({
      ...point,
      date: parseDate(point.date),
    }));
  }
  return data;
}

/**
 * Returns the seriesNames from the the dataset, excluding specified
 * @param  {[type]} data    [description]
 * @return {[type]}         [description]
 */
export function getSeriesNames(data, excludeColumns) {
  const exclude = excludeColumns || ['date', 'label', 'annotate', 'highlight', 'type'];
  const allSeriesNames = (Array.isArray(data)
    ? data.reduce((acc, curr) => [...acc, ...Object.keys(curr)], [])
    : Object.keys(data)
  ).filter(d => !exclude.includes(d));
  return [...new Set(allSeriesNames)];
}

/**
 * Calculates the extent of multiple columns
 * @param  {[type]} d       [description]
 * @param  {[type]} columns [description]
 * @param  {[type]} yMin    [description]
 * @return {[type]}         [description]
 */
export function extentMulti(d, columns, yMin) {
  const ext = d.reduce((acc, row) => {
    const values = columns
      .map(key => row[key])
      .map(item => {
        if (item !== 0 && (!item || item === '*')) {
          return yMin;
        }
        return Number(item);
      });
    const rowExtent = extent(values);
    if (!acc.max) {
      acc.max = rowExtent[1];
      acc.min = rowExtent[0];
    } else {
      acc.max = Math.max(acc.max, rowExtent[1]);
      acc.min = Math.min(acc.min, rowExtent[0]);
    }
    return acc;
  }, {});
  return [ext.min, ext.max];
}
