(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.createChartLayout = factory());
}(this, (function () { 'use strict';

	function fillInDefaults(target, defaults) {
		Object.keys(defaults).forEach(function(key) {
			if (target[key] === undefined) target[key] = defaults[key];
		});
		return target;
	}

	var X_DEFAULTS = Object.freeze({
		axis_position: "bottom",
		y_axis_position: "",

		numeric_scale_type: "linear",
		nice: true,
		flip: false,
		zero_axis: "auto",
		linear_min: null,
		linear_max: null,
		log_min: null,
		log_max: null,
		datetime_min: "",
		datetime_max: "",

		line_visible: true,
		line_and_tick_color: "#eeeeee",
		line_and_tick_width: 0.1,

		tick_side: "out",
		tick_mode: "auto",
		tick_number: 5,
		tick_custom: "",
		tick_length: 0.5,
		tick_padding: 0.25,
		edge_padding: 50,

		tick_label_position: "default",
		tick_label_size: 0.9,
		tick_label_color: "#aaaaaa",
		tick_label_angle: "45",
		tick_label_weight: "normal",
		tick_label_space_mode: "auto",
		tick_label_space: 10,
		tick_label_max_lines: 2,
		// Perhaps this should be nullable; then if you null it
		// it is set to 1 for continuous scales and in discrete scales
		// we do set it automatically to Math.floor(step/line_height).
		// This way we'd always favour showing more discrete ticks over
		// adding new lines.
		tick_label_line_height: 1.1,

		gridlines_visible: false,
		gridline_color: "#eeeeee",
		gridline_width: 0.1,
		gridline_style: "solid",
		gridline_category_dividers: false,
		gridline_category_dividers_extend: false,

		title_mode: "auto",
		title: "",
		title_color: "#aaaaaa",
		title_size: 1.1,
		title_weight: "normal",
		title_padding: 0.6
	});

	var Y_DEFAULTS = Object.freeze({
		axis_visible: true,

		numeric_scale_type: "linear",
		nice: true,
		flip: false,
		zero_axis: "auto",
		linear_min: null,
		linear_max: null,
		log_min: null,
		log_max: null,
		datetime_min: "",
		datetime_max: "",

		line_visible: true,
		line_and_tick_color: "#eeeeee",
		line_and_tick_width: 0.1,

		tick_side: "out",
		tick_mode: "auto",
		tick_number: 5,
		tick_custom: "",
		tick_length: 0.5,
		tick_padding: 0.25,
		edge_padding: 50,

		tick_label_position: "default",
		tick_label_size: 0.9,
		tick_label_color: "#aaaaaa",
		tick_label_angle: "0",
		tick_label_weight: "normal",
		tick_label_space_mode: "auto",
		tick_label_space: 10,
		tick_label_max_lines: 2,
		tick_label_line_height: 1.1,

		gridlines_visible: true,
		gridline_color: "#eeeeee",
		gridline_width: 0.1,
		gridline_style: "solid",
		gridline_category_dividers: false,
		gridline_category_dividers_extend: false,

		title_mode: "auto",
		title: "",
		title_color: "#aaaaaa",
		title_size: 1.1,
		title_weight: "normal",
		title_padding: 0.6
	});


	var Y2_DEFAULTS = Object.freeze(
		fillInDefaults({ axis_visible: false }, Y_DEFAULTS)
	);

	var BACKGROUND_DEFAULTS = Object.freeze({
		background_color_enabled: false,
		background_color: "#f5f5f5",
		background_image_enabled: false,
		background_image_src: "",
		background_image_size: "stretch",
		background_image_position: "xMidYMid",
	});

	function _assignProperties(state, obj_name, default_obj) {
		if (!state[obj_name]) state[obj_name] = {};
		fillInDefaults(state[obj_name], default_obj);
	}


	function prepareState(state) {
		state = state || {};
		var assignProperties = _assignProperties.bind(null, state);
		assignProperties("x", X_DEFAULTS);
		assignProperties("y", Y_DEFAULTS);
		assignProperties("y2", Y2_DEFAULTS);
		assignProperties("background", BACKGROUND_DEFAULTS);
		return state;
	}

	var xhtml = "http://www.w3.org/1999/xhtml";

	var namespaces = {
	  svg: "http://www.w3.org/2000/svg",
	  xhtml: xhtml,
	  xlink: "http://www.w3.org/1999/xlink",
	  xml: "http://www.w3.org/XML/1998/namespace",
	  xmlns: "http://www.w3.org/2000/xmlns/"
	};

	function namespace(name) {
	  var prefix = name += "", i = prefix.indexOf(":");
	  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
	}

	function creatorInherit(name) {
	  return function() {
	    var document = this.ownerDocument,
	        uri = this.namespaceURI;
	    return uri === xhtml && document.documentElement.namespaceURI === xhtml
	        ? document.createElement(name)
	        : document.createElementNS(uri, name);
	  };
	}

	function creatorFixed(fullname) {
	  return function() {
	    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
	  };
	}

	function creator(name) {
	  var fullname = namespace(name);
	  return (fullname.local
	      ? creatorFixed
	      : creatorInherit)(fullname);
	}

	function none() {}

	function selector(selector) {
	  return selector == null ? none : function() {
	    return this.querySelector(selector);
	  };
	}

	function selection_select(select) {
	  if (typeof select !== "function") select = selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function array(x) {
	  return typeof x === "object" && "length" in x
	    ? x // Array, TypedArray, NodeList, array-like
	    : Array.from(x); // Map, Set, iterable, string, or anything else
	}

	function empty() {
	  return [];
	}

	function selectorAll(selector) {
	  return selector == null ? empty : function() {
	    return this.querySelectorAll(selector);
	  };
	}

	function arrayAll(select) {
	  return function() {
	    var group = select.apply(this, arguments);
	    return group == null ? [] : array(group);
	  };
	}

	function selection_selectAll(select) {
	  if (typeof select === "function") select = arrayAll(select);
	  else select = selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        subgroups.push(select.call(node, node.__data__, i, group));
	        parents.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, parents);
	}

	function matcher(selector) {
	  return function() {
	    return this.matches(selector);
	  };
	}

	function childMatcher(selector) {
	  return function(node) {
	    return node.matches(selector);
	  };
	}

	var find = Array.prototype.find;

	function childFind(match) {
	  return function() {
	    return find.call(this.children, match);
	  };
	}

	function childFirst() {
	  return this.firstElementChild;
	}

	function selection_selectChild(match) {
	  return this.select(match == null ? childFirst
	      : childFind(typeof match === "function" ? match : childMatcher(match)));
	}

	var filter = Array.prototype.filter;

	function children() {
	  return this.children;
	}

	function childrenFilter(match) {
	  return function() {
	    return filter.call(this.children, match);
	  };
	}

	function selection_selectChildren(match) {
	  return this.selectAll(match == null ? children
	      : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
	}

	function selection_filter(match) {
	  if (typeof match !== "function") match = matcher(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function sparse(update) {
	  return new Array(update.length);
	}

	function selection_enter() {
	  return new Selection(this._enter || this._groups.map(sparse), this._parents);
	}

	function EnterNode(parent, datum) {
	  this.ownerDocument = parent.ownerDocument;
	  this.namespaceURI = parent.namespaceURI;
	  this._next = null;
	  this._parent = parent;
	  this.__data__ = datum;
	}

	EnterNode.prototype = {
	  constructor: EnterNode,
	  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
	  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
	  querySelector: function(selector) { return this._parent.querySelector(selector); },
	  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
	};

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function bindIndex(parent, group, enter, update, exit, data) {
	  var i = 0,
	      node,
	      groupLength = group.length,
	      dataLength = data.length;

	  // Put any non-null nodes that fit into update.
	  // Put any null nodes into enter.
	  // Put any remaining data into enter.
	  for (; i < dataLength; ++i) {
	    if (node = group[i]) {
	      node.__data__ = data[i];
	      update[i] = node;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Put any non-null nodes that don’t fit into exit.
	  for (; i < groupLength; ++i) {
	    if (node = group[i]) {
	      exit[i] = node;
	    }
	  }
	}

	function bindKey(parent, group, enter, update, exit, data, key) {
	  var i,
	      node,
	      nodeByKeyValue = new Map,
	      groupLength = group.length,
	      dataLength = data.length,
	      keyValues = new Array(groupLength),
	      keyValue;

	  // Compute the key for each node.
	  // If multiple nodes have the same key, the duplicates are added to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if (node = group[i]) {
	      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
	      if (nodeByKeyValue.has(keyValue)) {
	        exit[i] = node;
	      } else {
	        nodeByKeyValue.set(keyValue, node);
	      }
	    }
	  }

	  // Compute the key for each datum.
	  // If there a node associated with this key, join and add it to update.
	  // If there is not (or the key is a duplicate), add it to enter.
	  for (i = 0; i < dataLength; ++i) {
	    keyValue = key.call(parent, data[i], i, data) + "";
	    if (node = nodeByKeyValue.get(keyValue)) {
	      update[i] = node;
	      node.__data__ = data[i];
	      nodeByKeyValue.delete(keyValue);
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Add any remaining nodes that were not bound to data to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
	      exit[i] = node;
	    }
	  }
	}

	function datum(node) {
	  return node.__data__;
	}

	function selection_data(value, key) {
	  if (!arguments.length) return Array.from(this, datum);

	  var bind = key ? bindKey : bindIndex,
	      parents = this._parents,
	      groups = this._groups;

	  if (typeof value !== "function") value = constant(value);

	  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
	    var parent = parents[j],
	        group = groups[j],
	        groupLength = group.length,
	        data = array(value.call(parent, parent && parent.__data__, j, parents)),
	        dataLength = data.length,
	        enterGroup = enter[j] = new Array(dataLength),
	        updateGroup = update[j] = new Array(dataLength),
	        exitGroup = exit[j] = new Array(groupLength);

	    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

	    // Now connect the enter nodes to their following update node, such that
	    // appendChild can insert the materialized enter node before this node,
	    // rather than at the end of the parent node.
	    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
	      if (previous = enterGroup[i0]) {
	        if (i0 >= i1) i1 = i0 + 1;
	        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
	        previous._next = next || null;
	      }
	    }
	  }

	  update = new Selection(update, parents);
	  update._enter = enter;
	  update._exit = exit;
	  return update;
	}

	function selection_exit() {
	  return new Selection(this._exit || this._groups.map(sparse), this._parents);
	}

	function selection_join(onenter, onupdate, onexit) {
	  var enter = this.enter(), update = this, exit = this.exit();
	  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
	  if (onupdate != null) update = onupdate(update);
	  if (onexit == null) exit.remove(); else onexit(exit);
	  return enter && update ? enter.merge(update).order() : update;
	}

	function selection_merge(selection) {
	  if (!(selection instanceof Selection)) throw new Error("invalid merge");

	  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Selection(merges, this._parents);
	}

	function selection_order() {

	  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
	    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
	      if (node = group[i]) {
	        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
	        next = node;
	      }
	    }
	  }

	  return this;
	}

	function selection_sort(compare) {
	  if (!compare) compare = ascending;

	  function compareNode(a, b) {
	    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
	  }

	  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        sortgroup[i] = node;
	      }
	    }
	    sortgroup.sort(compareNode);
	  }

	  return new Selection(sortgroups, this._parents).order();
	}

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function selection_call() {
	  var callback = arguments[0];
	  arguments[0] = this;
	  callback.apply(null, arguments);
	  return this;
	}

	function selection_nodes() {
	  return Array.from(this);
	}

	function selection_node() {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
	      var node = group[i];
	      if (node) return node;
	    }
	  }

	  return null;
	}

	function selection_size() {
	  let size = 0;
	  for (const node of this) ++size; // eslint-disable-line no-unused-vars
	  return size;
	}

	function selection_empty() {
	  return !this.node();
	}

	function selection_each(callback) {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
	      if (node = group[i]) callback.call(node, node.__data__, i, group);
	    }
	  }

	  return this;
	}

	function attrRemove(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant(name, value) {
	  return function() {
	    this.setAttribute(name, value);
	  };
	}

	function attrConstantNS(fullname, value) {
	  return function() {
	    this.setAttributeNS(fullname.space, fullname.local, value);
	  };
	}

	function attrFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttribute(name);
	    else this.setAttribute(name, v);
	  };
	}

	function attrFunctionNS(fullname, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
	    else this.setAttributeNS(fullname.space, fullname.local, v);
	  };
	}

	function selection_attr(name, value) {
	  var fullname = namespace(name);

	  if (arguments.length < 2) {
	    var node = this.node();
	    return fullname.local
	        ? node.getAttributeNS(fullname.space, fullname.local)
	        : node.getAttribute(fullname);
	  }

	  return this.each((value == null
	      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
	      ? (fullname.local ? attrFunctionNS : attrFunction)
	      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
	}

	function defaultView(node) {
	  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
	      || (node.document && node) // node is a Window
	      || node.defaultView; // node is a Document
	}

	function styleRemove(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant(name, value, priority) {
	  return function() {
	    this.style.setProperty(name, value, priority);
	  };
	}

	function styleFunction(name, value, priority) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.style.removeProperty(name);
	    else this.style.setProperty(name, v, priority);
	  };
	}

	function selection_style(name, value, priority) {
	  return arguments.length > 1
	      ? this.each((value == null
	            ? styleRemove : typeof value === "function"
	            ? styleFunction
	            : styleConstant)(name, value, priority == null ? "" : priority))
	      : styleValue(this.node(), name);
	}

	function styleValue(node, name) {
	  return node.style.getPropertyValue(name)
	      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
	}

	function propertyRemove(name) {
	  return function() {
	    delete this[name];
	  };
	}

	function propertyConstant(name, value) {
	  return function() {
	    this[name] = value;
	  };
	}

	function propertyFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) delete this[name];
	    else this[name] = v;
	  };
	}

	function selection_property(name, value) {
	  return arguments.length > 1
	      ? this.each((value == null
	          ? propertyRemove : typeof value === "function"
	          ? propertyFunction
	          : propertyConstant)(name, value))
	      : this.node()[name];
	}

	function classArray(string) {
	  return string.trim().split(/^|\s+/);
	}

	function classList(node) {
	  return node.classList || new ClassList(node);
	}

	function ClassList(node) {
	  this._node = node;
	  this._names = classArray(node.getAttribute("class") || "");
	}

	ClassList.prototype = {
	  add: function(name) {
	    var i = this._names.indexOf(name);
	    if (i < 0) {
	      this._names.push(name);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  remove: function(name) {
	    var i = this._names.indexOf(name);
	    if (i >= 0) {
	      this._names.splice(i, 1);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  contains: function(name) {
	    return this._names.indexOf(name) >= 0;
	  }
	};

	function classedAdd(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.add(names[i]);
	}

	function classedRemove(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.remove(names[i]);
	}

	function classedTrue(names) {
	  return function() {
	    classedAdd(this, names);
	  };
	}

	function classedFalse(names) {
	  return function() {
	    classedRemove(this, names);
	  };
	}

	function classedFunction(names, value) {
	  return function() {
	    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
	  };
	}

	function selection_classed(name, value) {
	  var names = classArray(name + "");

	  if (arguments.length < 2) {
	    var list = classList(this.node()), i = -1, n = names.length;
	    while (++i < n) if (!list.contains(names[i])) return false;
	    return true;
	  }

	  return this.each((typeof value === "function"
	      ? classedFunction : value
	      ? classedTrue
	      : classedFalse)(names, value));
	}

	function textRemove() {
	  this.textContent = "";
	}

	function textConstant(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.textContent = v == null ? "" : v;
	  };
	}

	function selection_text(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? textRemove : (typeof value === "function"
	          ? textFunction
	          : textConstant)(value))
	      : this.node().textContent;
	}

	function htmlRemove() {
	  this.innerHTML = "";
	}

	function htmlConstant(value) {
	  return function() {
	    this.innerHTML = value;
	  };
	}

	function htmlFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.innerHTML = v == null ? "" : v;
	  };
	}

	function selection_html(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? htmlRemove : (typeof value === "function"
	          ? htmlFunction
	          : htmlConstant)(value))
	      : this.node().innerHTML;
	}

	function raise() {
	  if (this.nextSibling) this.parentNode.appendChild(this);
	}

	function selection_raise() {
	  return this.each(raise);
	}

	function lower() {
	  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
	}

	function selection_lower() {
	  return this.each(lower);
	}

	function selection_append(name) {
	  var create = typeof name === "function" ? name : creator(name);
	  return this.select(function() {
	    return this.appendChild(create.apply(this, arguments));
	  });
	}

	function constantNull() {
	  return null;
	}

	function selection_insert(name, before) {
	  var create = typeof name === "function" ? name : creator(name),
	      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
	  return this.select(function() {
	    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
	  });
	}

	function remove() {
	  var parent = this.parentNode;
	  if (parent) parent.removeChild(this);
	}

	function selection_remove() {
	  return this.each(remove);
	}

	function selection_cloneShallow() {
	  var clone = this.cloneNode(false), parent = this.parentNode;
	  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
	}

	function selection_cloneDeep() {
	  var clone = this.cloneNode(true), parent = this.parentNode;
	  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
	}

	function selection_clone(deep) {
	  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
	}

	function selection_datum(value) {
	  return arguments.length
	      ? this.property("__data__", value)
	      : this.node().__data__;
	}

	function contextListener(listener) {
	  return function(event) {
	    listener.call(this, event, this.__data__);
	  };
	}

	function parseTypenames(typenames) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    return {type: t, name: name};
	  });
	}

	function onRemove(typename) {
	  return function() {
	    var on = this.__on;
	    if (!on) return;
	    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
	      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.options);
	      } else {
	        on[++i] = o;
	      }
	    }
	    if (++i) on.length = i;
	    else delete this.__on;
	  };
	}

	function onAdd(typename, value, options) {
	  return function() {
	    var on = this.__on, o, listener = contextListener(value);
	    if (on) for (var j = 0, m = on.length; j < m; ++j) {
	      if ((o = on[j]).type === typename.type && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.options);
	        this.addEventListener(o.type, o.listener = listener, o.options = options);
	        o.value = value;
	        return;
	      }
	    }
	    this.addEventListener(typename.type, listener, options);
	    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
	    if (!on) this.__on = [o];
	    else on.push(o);
	  };
	}

	function selection_on(typename, value, options) {
	  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

	  if (arguments.length < 2) {
	    var on = this.node().__on;
	    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
	      for (i = 0, o = on[j]; i < n; ++i) {
	        if ((t = typenames[i]).type === o.type && t.name === o.name) {
	          return o.value;
	        }
	      }
	    }
	    return;
	  }

	  on = value ? onAdd : onRemove;
	  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
	  return this;
	}

	function dispatchEvent(node, type, params) {
	  var window = defaultView(node),
	      event = window.CustomEvent;

	  if (typeof event === "function") {
	    event = new event(type, params);
	  } else {
	    event = window.document.createEvent("Event");
	    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
	    else event.initEvent(type, false, false);
	  }

	  node.dispatchEvent(event);
	}

	function dispatchConstant(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params);
	  };
	}

	function dispatchFunction(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params.apply(this, arguments));
	  };
	}

	function selection_dispatch(type, params) {
	  return this.each((typeof params === "function"
	      ? dispatchFunction
	      : dispatchConstant)(type, params));
	}

	function* selection_iterator() {
	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
	      if (node = group[i]) yield node;
	    }
	  }
	}

	var root = [null];

	function Selection(groups, parents) {
	  this._groups = groups;
	  this._parents = parents;
	}

	function selection() {
	  return new Selection([[document.documentElement]], root);
	}

	function selection_selection() {
	  return this;
	}

	Selection.prototype = selection.prototype = {
	  constructor: Selection,
	  select: selection_select,
	  selectAll: selection_selectAll,
	  selectChild: selection_selectChild,
	  selectChildren: selection_selectChildren,
	  filter: selection_filter,
	  data: selection_data,
	  enter: selection_enter,
	  exit: selection_exit,
	  join: selection_join,
	  merge: selection_merge,
	  selection: selection_selection,
	  order: selection_order,
	  sort: selection_sort,
	  call: selection_call,
	  nodes: selection_nodes,
	  node: selection_node,
	  size: selection_size,
	  empty: selection_empty,
	  each: selection_each,
	  attr: selection_attr,
	  style: selection_style,
	  property: selection_property,
	  classed: selection_classed,
	  text: selection_text,
	  html: selection_html,
	  raise: selection_raise,
	  lower: selection_lower,
	  append: selection_append,
	  insert: selection_insert,
	  remove: selection_remove,
	  clone: selection_clone,
	  datum: selection_datum,
	  on: selection_on,
	  dispatch: selection_dispatch,
	  [Symbol.iterator]: selection_iterator
	};

	function select(selector) {
	  return typeof selector === "string"
	      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
	      : new Selection([[selector]], root);
	}

	function isSvg(node) {
		return node.tagName.toLowerCase() === "svg";
	}


	function getContainers(target) {
		var container;
		if (target && target.select && target.selectAll) {
			container = select(target.node()); // Make sure we have a select not selectAll
		}
		else container = select(target);
		var container_node = container.node();
		if (!container_node) throw new Error("Chart layout instance must have a target");
		var container_is_svg = isSvg(container_node);

		var getSvg = function() {
			if (container_is_svg) return container;
			var current_node = container_node.parentElement;
			while (current_node && !isSvg(current_node)) current_node = current_node.parentElement;
			if (!isSvg(current_node)) throw new Error("target must be an SVG or a descendant of an SVG");
			return select(current_node);
		};

		return { container: container, getSvg: getSvg };
	}

	function addDebugRectangle(chart) {
		chart.append("rect")
			.attr("class", "fl-chart-debug-rectangle")
			.attr("x", 0)
			.attr("y", 0)
			.style("stroke-width", "1px")
			.style("fill", "none")
			.style("display", "none");
	}

	function addBackground(chart) {
		var background = chart.append("g").attr("class", "fl-chart-background");
		background.append("rect").attr("class", "fl-chart-fill");
		background.append("image").attr("class", "fl-chart-image");
		background.append("rect").attr("class", "fl-chart-interaction")
			.style("opacity", 0);
	}

	function addGridlines(chart) {
		var gridlines_container = chart.append("g").attr("class", "fl-gridlines").style("pointer-events", "none");
		gridlines_container.append("g").attr("class", "fl-gridlines-vertical");
		gridlines_container.append("g").attr("class", "fl-gridlines-horizontal");
	}

	function addAxes(chart) {
		var axes_container = chart.append("g").attr("class", "fl-axes");
		var x_axes = axes_container.append("g").attr("class", "fl-x-axes");
		var y_axes = axes_container.append("g").attr("class", "fl-y-axes");

		var bottom = x_axes.append("g").attr("class", "fl-axis fl-x-axis fl-bottom-axis");
		bottom.append("g").attr("class", "fl-axis-line");
		bottom.append("g").attr("class", "fl-axis-ticks");
		bottom.append("g").attr("class", "fl-axis-title");

		var top = x_axes.append("g").attr("class", "fl-axis fl-x-axis fl-top-axis");
		top.append("g").attr("class", "fl-axis-line");
		top.append("g").attr("class", "fl-axis-ticks");
		top.append("g").attr("class", "fl-axis-title");

		var left = y_axes.append("g").attr("class", "fl-axis fl-y-axis fl-left-axis");
		left.append("g").attr("class", "fl-axis-line");
		left.append("g").attr("class", "fl-axis-ticks");
		left.append("g").attr("class", "fl-axis-title");

		var right = y_axes.append("g").attr("class", "fl-axis fl-y-axis fl-right-axis");
		right.append("g").attr("class", "fl-axis-line");
		right.append("g").attr("class", "fl-axis-ticks");
		right.append("g").attr("class", "fl-axis-title");
	}

	function addChart(instance) {
		var chart = instance.container.append("g").attr("class", "fl-chart");
		addDebugRectangle(chart);

		chart.append("clipPath").attr("class", "fl-data-clip-path").append("rect");
		chart.append("clipPath").attr("class", "fl-grid-clip-path").append("rect");
		addBackground(chart);
		chart.append("g").attr("class", "fl-data-background");
		addGridlines(chart);
		addAxes(chart);
		chart.append("g").attr("class", "fl-data-foreground");

		return chart;
	}

	var counter = 0;

	function initIdentifier(instance) {
		var identifier = "fl-chart-layout-" + counter++;

		return function(value) {
			if (value === undefined) return identifier;
			identifier = value;
			return instance;
		};
	}

	function initDebug(instance) {
		let debug = false;

		return function(value) {
			if (value === undefined) return debug;
			debug = !!value;
			return instance;
		};
	}


	function initDebugColor(instance) {
		let color = "red";

		return function(value) {
			if (value === undefined) return color;
			color = value;
			return instance;
		};
	}

	var ALL_TRUE = Object.freeze({ left: true, top: true, right: true, bottom: true });
	var ALL_FALSE = Object.freeze({ left: false, top: false, right: false, bottom: false });


	function initClip(instance) {
		var clip = ALL_TRUE;

		return function(value) {
			if (value === undefined) return clip;
			if (!value) clip = ALL_FALSE;
			else if (typeof value !== "object") clip = ALL_TRUE;
			else {
				clip = Object.freeze({
					left: !!value.left,
					top: !!value.top,
					right: !!value.right,
					bottom: !!value.bottom
				});
			}
			return instance;
		};
	}

	var noop = {value: () => {}};

	function dispatch() {
	  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
	    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
	    _[t] = [];
	  }
	  return new Dispatch(_);
	}

	function Dispatch(_) {
	  this._ = _;
	}

	function parseTypenames$1(typenames, types) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
	    return {type: t, name: name};
	  });
	}

	Dispatch.prototype = dispatch.prototype = {
	  constructor: Dispatch,
	  on: function(typename, callback) {
	    var _ = this._,
	        T = parseTypenames$1(typename + "", _),
	        t,
	        i = -1,
	        n = T.length;

	    // If no callback was specified, return the callback of the given type and name.
	    if (arguments.length < 2) {
	      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
	      return;
	    }

	    // If a type was specified, set the callback for the given type and name.
	    // Otherwise, if a null callback was specified, remove callbacks of the given name.
	    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
	    while (++i < n) {
	      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
	      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
	    }

	    return this;
	  },
	  copy: function() {
	    var copy = {}, _ = this._;
	    for (var t in _) copy[t] = _[t].slice();
	    return new Dispatch(copy);
	  },
	  call: function(type, that) {
	    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  },
	  apply: function(type, that, args) {
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  }
	};

	function get(type, name) {
	  for (var i = 0, n = type.length, c; i < n; ++i) {
	    if ((c = type[i]).name === name) {
	      return c.value;
	    }
	  }
	}

	function set(type, name, callback) {
	  for (var i = 0, n = type.length; i < n; ++i) {
	    if (type[i].name === name) {
	      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
	      break;
	    }
	  }
	  if (callback != null) type.push({name: name, value: callback});
	  return type;
	}

	var frame = 0, // is an animation frame pending?
	    timeout = 0, // is a timeout pending?
	    interval = 0, // are any timers active?
	    pokeDelay = 1000, // how frequently we check for clock skew
	    taskHead,
	    taskTail,
	    clockLast = 0,
	    clockNow = 0,
	    clockSkew = 0,
	    clock = typeof performance === "object" && performance.now ? performance : Date,
	    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

	function now() {
	  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
	}

	function clearNow() {
	  clockNow = 0;
	}

	function Timer() {
	  this._call =
	  this._time =
	  this._next = null;
	}

	Timer.prototype = timer.prototype = {
	  constructor: Timer,
	  restart: function(callback, delay, time) {
	    if (typeof callback !== "function") throw new TypeError("callback is not a function");
	    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
	    if (!this._next && taskTail !== this) {
	      if (taskTail) taskTail._next = this;
	      else taskHead = this;
	      taskTail = this;
	    }
	    this._call = callback;
	    this._time = time;
	    sleep();
	  },
	  stop: function() {
	    if (this._call) {
	      this._call = null;
	      this._time = Infinity;
	      sleep();
	    }
	  }
	};

	function timer(callback, delay, time) {
	  var t = new Timer;
	  t.restart(callback, delay, time);
	  return t;
	}

	function timerFlush() {
	  now(); // Get the current time, if not already set.
	  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
	  var t = taskHead, e;
	  while (t) {
	    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
	    t = t._next;
	  }
	  --frame;
	}

	function wake() {
	  clockNow = (clockLast = clock.now()) + clockSkew;
	  frame = timeout = 0;
	  try {
	    timerFlush();
	  } finally {
	    frame = 0;
	    nap();
	    clockNow = 0;
	  }
	}

	function poke() {
	  var now = clock.now(), delay = now - clockLast;
	  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
	}

	function nap() {
	  var t0, t1 = taskHead, t2, time = Infinity;
	  while (t1) {
	    if (t1._call) {
	      if (time > t1._time) time = t1._time;
	      t0 = t1, t1 = t1._next;
	    } else {
	      t2 = t1._next, t1._next = null;
	      t1 = t0 ? t0._next = t2 : taskHead = t2;
	    }
	  }
	  taskTail = t0;
	  sleep(time);
	}

	function sleep(time) {
	  if (frame) return; // Soonest alarm already set, or will be.
	  if (timeout) timeout = clearTimeout(timeout);
	  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
	  if (delay > 24) {
	    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
	    if (interval) interval = clearInterval(interval);
	  } else {
	    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
	    frame = 1, setFrame(wake);
	  }
	}

	function timeout$1(callback, delay, time) {
	  var t = new Timer;
	  delay = delay == null ? 0 : +delay;
	  t.restart(elapsed => {
	    t.stop();
	    callback(elapsed + delay);
	  }, delay, time);
	  return t;
	}

	var emptyOn = dispatch("start", "end", "cancel", "interrupt");
	var emptyTween = [];

	var CREATED = 0;
	var SCHEDULED = 1;
	var STARTING = 2;
	var STARTED = 3;
	var RUNNING = 4;
	var ENDING = 5;
	var ENDED = 6;

	function schedule(node, name, id, index, group, timing) {
	  var schedules = node.__transition;
	  if (!schedules) node.__transition = {};
	  else if (id in schedules) return;
	  create(node, id, {
	    name: name,
	    index: index, // For context during callback.
	    group: group, // For context during callback.
	    on: emptyOn,
	    tween: emptyTween,
	    time: timing.time,
	    delay: timing.delay,
	    duration: timing.duration,
	    ease: timing.ease,
	    timer: null,
	    state: CREATED
	  });
	}

	function init(node, id) {
	  var schedule = get$1(node, id);
	  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
	  return schedule;
	}

	function set$1(node, id) {
	  var schedule = get$1(node, id);
	  if (schedule.state > STARTED) throw new Error("too late; already running");
	  return schedule;
	}

	function get$1(node, id) {
	  var schedule = node.__transition;
	  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
	  return schedule;
	}

	function create(node, id, self) {
	  var schedules = node.__transition,
	      tween;

	  // Initialize the self timer when the transition is created.
	  // Note the actual delay is not known until the first callback!
	  schedules[id] = self;
	  self.timer = timer(schedule, 0, self.time);

	  function schedule(elapsed) {
	    self.state = SCHEDULED;
	    self.timer.restart(start, self.delay, self.time);

	    // If the elapsed delay is less than our first sleep, start immediately.
	    if (self.delay <= elapsed) start(elapsed - self.delay);
	  }

	  function start(elapsed) {
	    var i, j, n, o;

	    // If the state is not SCHEDULED, then we previously errored on start.
	    if (self.state !== SCHEDULED) return stop();

	    for (i in schedules) {
	      o = schedules[i];
	      if (o.name !== self.name) continue;

	      // While this element already has a starting transition during this frame,
	      // defer starting an interrupting transition until that transition has a
	      // chance to tick (and possibly end); see d3/d3-transition#54!
	      if (o.state === STARTED) return timeout$1(start);

	      // Interrupt the active transition, if any.
	      if (o.state === RUNNING) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("interrupt", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }

	      // Cancel any pre-empted transitions.
	      else if (+i < id) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("cancel", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }
	    }

	    // Defer the first tick to end of the current frame; see d3/d3#1576.
	    // Note the transition may be canceled after start and before the first tick!
	    // Note this must be scheduled before the start event; see d3/d3-transition#16!
	    // Assuming this is successful, subsequent callbacks go straight to tick.
	    timeout$1(function() {
	      if (self.state === STARTED) {
	        self.state = RUNNING;
	        self.timer.restart(tick, self.delay, self.time);
	        tick(elapsed);
	      }
	    });

	    // Dispatch the start event.
	    // Note this must be done before the tween are initialized.
	    self.state = STARTING;
	    self.on.call("start", node, node.__data__, self.index, self.group);
	    if (self.state !== STARTING) return; // interrupted
	    self.state = STARTED;

	    // Initialize the tween, deleting null tween.
	    tween = new Array(n = self.tween.length);
	    for (i = 0, j = -1; i < n; ++i) {
	      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
	        tween[++j] = o;
	      }
	    }
	    tween.length = j + 1;
	  }

	  function tick(elapsed) {
	    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
	        i = -1,
	        n = tween.length;

	    while (++i < n) {
	      tween[i].call(node, t);
	    }

	    // Dispatch the end event.
	    if (self.state === ENDING) {
	      self.on.call("end", node, node.__data__, self.index, self.group);
	      stop();
	    }
	  }

	  function stop() {
	    self.state = ENDED;
	    self.timer.stop();
	    delete schedules[id];
	    for (var i in schedules) return; // eslint-disable-line no-unused-vars
	    delete node.__transition;
	  }
	}

	function interrupt(node, name) {
	  var schedules = node.__transition,
	      schedule,
	      active,
	      empty = true,
	      i;

	  if (!schedules) return;

	  name = name == null ? null : name + "";

	  for (i in schedules) {
	    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
	    active = schedule.state > STARTING && schedule.state < ENDING;
	    schedule.state = ENDED;
	    schedule.timer.stop();
	    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
	    delete schedules[i];
	  }

	  if (empty) delete node.__transition;
	}

	function selection_interrupt(name) {
	  return this.each(function() {
	    interrupt(this, name);
	  });
	}

	function define(constructor, factory, prototype) {
	  constructor.prototype = factory.prototype = prototype;
	  prototype.constructor = constructor;
	}

	function extend(parent, definition) {
	  var prototype = Object.create(parent.prototype);
	  for (var key in definition) prototype[key] = definition[key];
	  return prototype;
	}

	function Color() {}

	var darker = 0.7;
	var brighter = 1 / darker;

	var reI = "\\s*([+-]?\\d+)\\s*",
	    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
	    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
	    reHex = /^#([0-9a-f]{3,8})$/,
	    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
	    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
	    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
	    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
	    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
	    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

	var named = {
	  aliceblue: 0xf0f8ff,
	  antiquewhite: 0xfaebd7,
	  aqua: 0x00ffff,
	  aquamarine: 0x7fffd4,
	  azure: 0xf0ffff,
	  beige: 0xf5f5dc,
	  bisque: 0xffe4c4,
	  black: 0x000000,
	  blanchedalmond: 0xffebcd,
	  blue: 0x0000ff,
	  blueviolet: 0x8a2be2,
	  brown: 0xa52a2a,
	  burlywood: 0xdeb887,
	  cadetblue: 0x5f9ea0,
	  chartreuse: 0x7fff00,
	  chocolate: 0xd2691e,
	  coral: 0xff7f50,
	  cornflowerblue: 0x6495ed,
	  cornsilk: 0xfff8dc,
	  crimson: 0xdc143c,
	  cyan: 0x00ffff,
	  darkblue: 0x00008b,
	  darkcyan: 0x008b8b,
	  darkgoldenrod: 0xb8860b,
	  darkgray: 0xa9a9a9,
	  darkgreen: 0x006400,
	  darkgrey: 0xa9a9a9,
	  darkkhaki: 0xbdb76b,
	  darkmagenta: 0x8b008b,
	  darkolivegreen: 0x556b2f,
	  darkorange: 0xff8c00,
	  darkorchid: 0x9932cc,
	  darkred: 0x8b0000,
	  darksalmon: 0xe9967a,
	  darkseagreen: 0x8fbc8f,
	  darkslateblue: 0x483d8b,
	  darkslategray: 0x2f4f4f,
	  darkslategrey: 0x2f4f4f,
	  darkturquoise: 0x00ced1,
	  darkviolet: 0x9400d3,
	  deeppink: 0xff1493,
	  deepskyblue: 0x00bfff,
	  dimgray: 0x696969,
	  dimgrey: 0x696969,
	  dodgerblue: 0x1e90ff,
	  firebrick: 0xb22222,
	  floralwhite: 0xfffaf0,
	  forestgreen: 0x228b22,
	  fuchsia: 0xff00ff,
	  gainsboro: 0xdcdcdc,
	  ghostwhite: 0xf8f8ff,
	  gold: 0xffd700,
	  goldenrod: 0xdaa520,
	  gray: 0x808080,
	  green: 0x008000,
	  greenyellow: 0xadff2f,
	  grey: 0x808080,
	  honeydew: 0xf0fff0,
	  hotpink: 0xff69b4,
	  indianred: 0xcd5c5c,
	  indigo: 0x4b0082,
	  ivory: 0xfffff0,
	  khaki: 0xf0e68c,
	  lavender: 0xe6e6fa,
	  lavenderblush: 0xfff0f5,
	  lawngreen: 0x7cfc00,
	  lemonchiffon: 0xfffacd,
	  lightblue: 0xadd8e6,
	  lightcoral: 0xf08080,
	  lightcyan: 0xe0ffff,
	  lightgoldenrodyellow: 0xfafad2,
	  lightgray: 0xd3d3d3,
	  lightgreen: 0x90ee90,
	  lightgrey: 0xd3d3d3,
	  lightpink: 0xffb6c1,
	  lightsalmon: 0xffa07a,
	  lightseagreen: 0x20b2aa,
	  lightskyblue: 0x87cefa,
	  lightslategray: 0x778899,
	  lightslategrey: 0x778899,
	  lightsteelblue: 0xb0c4de,
	  lightyellow: 0xffffe0,
	  lime: 0x00ff00,
	  limegreen: 0x32cd32,
	  linen: 0xfaf0e6,
	  magenta: 0xff00ff,
	  maroon: 0x800000,
	  mediumaquamarine: 0x66cdaa,
	  mediumblue: 0x0000cd,
	  mediumorchid: 0xba55d3,
	  mediumpurple: 0x9370db,
	  mediumseagreen: 0x3cb371,
	  mediumslateblue: 0x7b68ee,
	  mediumspringgreen: 0x00fa9a,
	  mediumturquoise: 0x48d1cc,
	  mediumvioletred: 0xc71585,
	  midnightblue: 0x191970,
	  mintcream: 0xf5fffa,
	  mistyrose: 0xffe4e1,
	  moccasin: 0xffe4b5,
	  navajowhite: 0xffdead,
	  navy: 0x000080,
	  oldlace: 0xfdf5e6,
	  olive: 0x808000,
	  olivedrab: 0x6b8e23,
	  orange: 0xffa500,
	  orangered: 0xff4500,
	  orchid: 0xda70d6,
	  palegoldenrod: 0xeee8aa,
	  palegreen: 0x98fb98,
	  paleturquoise: 0xafeeee,
	  palevioletred: 0xdb7093,
	  papayawhip: 0xffefd5,
	  peachpuff: 0xffdab9,
	  peru: 0xcd853f,
	  pink: 0xffc0cb,
	  plum: 0xdda0dd,
	  powderblue: 0xb0e0e6,
	  purple: 0x800080,
	  rebeccapurple: 0x663399,
	  red: 0xff0000,
	  rosybrown: 0xbc8f8f,
	  royalblue: 0x4169e1,
	  saddlebrown: 0x8b4513,
	  salmon: 0xfa8072,
	  sandybrown: 0xf4a460,
	  seagreen: 0x2e8b57,
	  seashell: 0xfff5ee,
	  sienna: 0xa0522d,
	  silver: 0xc0c0c0,
	  skyblue: 0x87ceeb,
	  slateblue: 0x6a5acd,
	  slategray: 0x708090,
	  slategrey: 0x708090,
	  snow: 0xfffafa,
	  springgreen: 0x00ff7f,
	  steelblue: 0x4682b4,
	  tan: 0xd2b48c,
	  teal: 0x008080,
	  thistle: 0xd8bfd8,
	  tomato: 0xff6347,
	  turquoise: 0x40e0d0,
	  violet: 0xee82ee,
	  wheat: 0xf5deb3,
	  white: 0xffffff,
	  whitesmoke: 0xf5f5f5,
	  yellow: 0xffff00,
	  yellowgreen: 0x9acd32
	};

	define(Color, color, {
	  copy: function(channels) {
	    return Object.assign(new this.constructor, this, channels);
	  },
	  displayable: function() {
	    return this.rgb().displayable();
	  },
	  hex: color_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: color_formatHex,
	  formatHsl: color_formatHsl,
	  formatRgb: color_formatRgb,
	  toString: color_formatRgb
	});

	function color_formatHex() {
	  return this.rgb().formatHex();
	}

	function color_formatHsl() {
	  return hslConvert(this).formatHsl();
	}

	function color_formatRgb() {
	  return this.rgb().formatRgb();
	}

	function color(format) {
	  var m, l;
	  format = (format + "").trim().toLowerCase();
	  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
	      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
	      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
	      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
	      : null) // invalid hex
	      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
	      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
	      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
	      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
	      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
	      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
	      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
	      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
	      : null;
	}

	function rgbn(n) {
	  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
	}

	function rgba(r, g, b, a) {
	  if (a <= 0) r = g = b = NaN;
	  return new Rgb(r, g, b, a);
	}

	function rgbConvert(o) {
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Rgb;
	  o = o.rgb();
	  return new Rgb(o.r, o.g, o.b, o.opacity);
	}

	function rgb(r, g, b, opacity) {
	  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
	}

	function Rgb(r, g, b, opacity) {
	  this.r = +r;
	  this.g = +g;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Rgb, rgb, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  rgb: function() {
	    return this;
	  },
	  displayable: function() {
	    return (-0.5 <= this.r && this.r < 255.5)
	        && (-0.5 <= this.g && this.g < 255.5)
	        && (-0.5 <= this.b && this.b < 255.5)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: rgb_formatHex,
	  formatRgb: rgb_formatRgb,
	  toString: rgb_formatRgb
	}));

	function rgb_formatHex() {
	  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
	}

	function rgb_formatRgb() {
	  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	  return (a === 1 ? "rgb(" : "rgba(")
	      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
	      + (a === 1 ? ")" : ", " + a + ")");
	}

	function hex(value) {
	  value = Math.max(0, Math.min(255, Math.round(value) || 0));
	  return (value < 16 ? "0" : "") + value.toString(16);
	}

	function hsla(h, s, l, a) {
	  if (a <= 0) h = s = l = NaN;
	  else if (l <= 0 || l >= 1) h = s = NaN;
	  else if (s <= 0) h = NaN;
	  return new Hsl(h, s, l, a);
	}

	function hslConvert(o) {
	  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Hsl;
	  if (o instanceof Hsl) return o;
	  o = o.rgb();
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      h = NaN,
	      s = max - min,
	      l = (max + min) / 2;
	  if (s) {
	    if (r === max) h = (g - b) / s + (g < b) * 6;
	    else if (g === max) h = (b - r) / s + 2;
	    else h = (r - g) / s + 4;
	    s /= l < 0.5 ? max + min : 2 - max - min;
	    h *= 60;
	  } else {
	    s = l > 0 && l < 1 ? 0 : h;
	  }
	  return new Hsl(h, s, l, o.opacity);
	}

	function hsl(h, s, l, opacity) {
	  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
	}

	function Hsl(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Hsl, hsl, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = this.h % 360 + (this.h < 0) * 360,
	        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
	        l = this.l,
	        m2 = l + (l < 0.5 ? l : 1 - l) * s,
	        m1 = 2 * l - m2;
	    return new Rgb(
	      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
	      hsl2rgb(h, m1, m2),
	      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
	      this.opacity
	    );
	  },
	  displayable: function() {
	    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
	        && (0 <= this.l && this.l <= 1)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  formatHsl: function() {
	    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	    return (a === 1 ? "hsl(" : "hsla(")
	        + (this.h || 0) + ", "
	        + (this.s || 0) * 100 + "%, "
	        + (this.l || 0) * 100 + "%"
	        + (a === 1 ? ")" : ", " + a + ")");
	  }
	}));

	/* From FvD 13.37, CSS Color Module Level 3 */
	function hsl2rgb(h, m1, m2) {
	  return (h < 60 ? m1 + (m2 - m1) * h / 60
	      : h < 180 ? m2
	      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
	      : m1) * 255;
	}

	var constant$1 = x => () => x;

	function linear(a, d) {
	  return function(t) {
	    return a + t * d;
	  };
	}

	function exponential(a, b, y) {
	  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
	    return Math.pow(a + t * b, y);
	  };
	}

	function gamma(y) {
	  return (y = +y) === 1 ? nogamma : function(a, b) {
	    return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
	  };
	}

	function nogamma(a, b) {
	  var d = b - a;
	  return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
	}

	var interpolateRgb = (function rgbGamma(y) {
	  var color = gamma(y);

	  function rgb$1(start, end) {
	    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
	        g = color(start.g, end.g),
	        b = color(start.b, end.b),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.r = r(t);
	      start.g = g(t);
	      start.b = b(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }

	  rgb$1.gamma = rgbGamma;

	  return rgb$1;
	})(1);

	function numberArray(a, b) {
	  if (!b) b = [];
	  var n = a ? Math.min(b.length, a.length) : 0,
	      c = b.slice(),
	      i;
	  return function(t) {
	    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
	    return c;
	  };
	}

	function isNumberArray(x) {
	  return ArrayBuffer.isView(x) && !(x instanceof DataView);
	}

	function genericArray(a, b) {
	  var nb = b ? b.length : 0,
	      na = a ? Math.min(nb, a.length) : 0,
	      x = new Array(na),
	      c = new Array(nb),
	      i;

	  for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
	  for (; i < nb; ++i) c[i] = b[i];

	  return function(t) {
	    for (i = 0; i < na; ++i) c[i] = x[i](t);
	    return c;
	  };
	}

	function date(a, b) {
	  var d = new Date;
	  return a = +a, b = +b, function(t) {
	    return d.setTime(a * (1 - t) + b * t), d;
	  };
	}

	function interpolateNumber(a, b) {
	  return a = +a, b = +b, function(t) {
	    return a * (1 - t) + b * t;
	  };
	}

	function object(a, b) {
	  var i = {},
	      c = {},
	      k;

	  if (a === null || typeof a !== "object") a = {};
	  if (b === null || typeof b !== "object") b = {};

	  for (k in b) {
	    if (k in a) {
	      i[k] = interpolate(a[k], b[k]);
	    } else {
	      c[k] = b[k];
	    }
	  }

	  return function(t) {
	    for (k in i) c[k] = i[k](t);
	    return c;
	  };
	}

	var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
	    reB = new RegExp(reA.source, "g");

	function zero(b) {
	  return function() {
	    return b;
	  };
	}

	function one(b) {
	  return function(t) {
	    return b(t) + "";
	  };
	}

	function interpolateString(a, b) {
	  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
	      am, // current match in a
	      bm, // current match in b
	      bs, // string preceding current number in b, if any
	      i = -1, // index in s
	      s = [], // string constants and placeholders
	      q = []; // number interpolators

	  // Coerce inputs to strings.
	  a = a + "", b = b + "";

	  // Interpolate pairs of numbers in a & b.
	  while ((am = reA.exec(a))
	      && (bm = reB.exec(b))) {
	    if ((bs = bm.index) > bi) { // a string precedes the next number in b
	      bs = b.slice(bi, bs);
	      if (s[i]) s[i] += bs; // coalesce with previous string
	      else s[++i] = bs;
	    }
	    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
	      if (s[i]) s[i] += bm; // coalesce with previous string
	      else s[++i] = bm;
	    } else { // interpolate non-matching numbers
	      s[++i] = null;
	      q.push({i: i, x: interpolateNumber(am, bm)});
	    }
	    bi = reB.lastIndex;
	  }

	  // Add remains of b.
	  if (bi < b.length) {
	    bs = b.slice(bi);
	    if (s[i]) s[i] += bs; // coalesce with previous string
	    else s[++i] = bs;
	  }

	  // Special optimization for only a single match.
	  // Otherwise, interpolate each of the numbers and rejoin the string.
	  return s.length < 2 ? (q[0]
	      ? one(q[0].x)
	      : zero(b))
	      : (b = q.length, function(t) {
	          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	          return s.join("");
	        });
	}

	function interpolate(a, b) {
	  var t = typeof b, c;
	  return b == null || t === "boolean" ? constant$1(b)
	      : (t === "number" ? interpolateNumber
	      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
	      : b instanceof color ? interpolateRgb
	      : b instanceof Date ? date
	      : isNumberArray(b) ? numberArray
	      : Array.isArray(b) ? genericArray
	      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
	      : interpolateNumber)(a, b);
	}

	function interpolateRound(a, b) {
	  return a = +a, b = +b, function(t) {
	    return Math.round(a * (1 - t) + b * t);
	  };
	}

	var degrees = 180 / Math.PI;

	var identity = {
	  translateX: 0,
	  translateY: 0,
	  rotate: 0,
	  skewX: 0,
	  scaleX: 1,
	  scaleY: 1
	};

	function decompose(a, b, c, d, e, f) {
	  var scaleX, scaleY, skewX;
	  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
	  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
	  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
	  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
	  return {
	    translateX: e,
	    translateY: f,
	    rotate: Math.atan2(b, a) * degrees,
	    skewX: Math.atan(skewX) * degrees,
	    scaleX: scaleX,
	    scaleY: scaleY
	  };
	}

	var svgNode;

	/* eslint-disable no-undef */
	function parseCss(value) {
	  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
	  return m.isIdentity ? identity : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
	}

	function parseSvg(value) {
	  if (value == null) return identity;
	  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
	  svgNode.setAttribute("transform", value);
	  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
	  value = value.matrix;
	  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
	}

	function interpolateTransform(parse, pxComma, pxParen, degParen) {

	  function pop(s) {
	    return s.length ? s.pop() + " " : "";
	  }

	  function translate(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push("translate(", null, pxComma, null, pxParen);
	      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
	    } else if (xb || yb) {
	      s.push("translate(" + xb + pxComma + yb + pxParen);
	    }
	  }

	  function rotate(a, b, s, q) {
	    if (a !== b) {
	      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
	      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "rotate(" + b + degParen);
	    }
	  }

	  function skewX(a, b, s, q) {
	    if (a !== b) {
	      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "skewX(" + b + degParen);
	    }
	  }

	  function scale(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
	      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
	    } else if (xb !== 1 || yb !== 1) {
	      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
	    }
	  }

	  return function(a, b) {
	    var s = [], // string constants and placeholders
	        q = []; // number interpolators
	    a = parse(a), b = parse(b);
	    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
	    rotate(a.rotate, b.rotate, s, q);
	    skewX(a.skewX, b.skewX, s, q);
	    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
	    a = b = null; // gc
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  };
	}

	var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
	var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

	function tweenRemove(id, name) {
	  var tween0, tween1;
	  return function() {
	    var schedule = set$1(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = tween0 = tween;
	      for (var i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1 = tween1.slice();
	          tween1.splice(i, 1);
	          break;
	        }
	      }
	    }

	    schedule.tween = tween1;
	  };
	}

	function tweenFunction(id, name, value) {
	  var tween0, tween1;
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    var schedule = set$1(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = (tween0 = tween).slice();
	      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1[i] = t;
	          break;
	        }
	      }
	      if (i === n) tween1.push(t);
	    }

	    schedule.tween = tween1;
	  };
	}

	function transition_tween(name, value) {
	  var id = this._id;

	  name += "";

	  if (arguments.length < 2) {
	    var tween = get$1(this.node(), id).tween;
	    for (var i = 0, n = tween.length, t; i < n; ++i) {
	      if ((t = tween[i]).name === name) {
	        return t.value;
	      }
	    }
	    return null;
	  }

	  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
	}

	function tweenValue(transition, name, value) {
	  var id = transition._id;

	  transition.each(function() {
	    var schedule = set$1(this, id);
	    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
	  });

	  return function(node) {
	    return get$1(node, id).value[name];
	  };
	}

	function interpolate$1(a, b) {
	  var c;
	  return (typeof b === "number" ? interpolateNumber
	      : b instanceof color ? interpolateRgb
	      : (c = color(b)) ? (b = c, interpolateRgb)
	      : interpolateString)(a, b);
	}

	function attrRemove$1(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS$1(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant$1(name, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = this.getAttribute(name);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function attrConstantNS$1(fullname, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = this.getAttributeNS(fullname.space, fullname.local);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function attrFunction$1(name, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0, value1 = value(this), string1;
	    if (value1 == null) return void this.removeAttribute(name);
	    string0 = this.getAttribute(name);
	    string1 = value1 + "";
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function attrFunctionNS$1(fullname, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0, value1 = value(this), string1;
	    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
	    string0 = this.getAttributeNS(fullname.space, fullname.local);
	    string1 = value1 + "";
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function transition_attr(name, value) {
	  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
	  return this.attrTween(name, typeof value === "function"
	      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
	      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
	      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
	}

	function attrInterpolate(name, i) {
	  return function(t) {
	    this.setAttribute(name, i.call(this, t));
	  };
	}

	function attrInterpolateNS(fullname, i) {
	  return function(t) {
	    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
	  };
	}

	function attrTweenNS(fullname, value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function attrTween(name, value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_attrTween(name, value) {
	  var key = "attr." + name;
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  var fullname = namespace(name);
	  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
	}

	function delayFunction(id, value) {
	  return function() {
	    init(this, id).delay = +value.apply(this, arguments);
	  };
	}

	function delayConstant(id, value) {
	  return value = +value, function() {
	    init(this, id).delay = value;
	  };
	}

	function transition_delay(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? delayFunction
	          : delayConstant)(id, value))
	      : get$1(this.node(), id).delay;
	}

	function durationFunction(id, value) {
	  return function() {
	    set$1(this, id).duration = +value.apply(this, arguments);
	  };
	}

	function durationConstant(id, value) {
	  return value = +value, function() {
	    set$1(this, id).duration = value;
	  };
	}

	function transition_duration(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? durationFunction
	          : durationConstant)(id, value))
	      : get$1(this.node(), id).duration;
	}

	function easeConstant(id, value) {
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    set$1(this, id).ease = value;
	  };
	}

	function transition_ease(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each(easeConstant(id, value))
	      : get$1(this.node(), id).ease;
	}

	function easeVarying(id, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (typeof v !== "function") throw new Error;
	    set$1(this, id).ease = v;
	  };
	}

	function transition_easeVarying(value) {
	  if (typeof value !== "function") throw new Error;
	  return this.each(easeVarying(this._id, value));
	}

	function transition_filter(match) {
	  if (typeof match !== "function") match = matcher(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, this._name, this._id);
	}

	function transition_merge(transition) {
	  if (transition._id !== this._id) throw new Error;

	  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Transition(merges, this._parents, this._name, this._id);
	}

	function start(name) {
	  return (name + "").trim().split(/^|\s+/).every(function(t) {
	    var i = t.indexOf(".");
	    if (i >= 0) t = t.slice(0, i);
	    return !t || t === "start";
	  });
	}

	function onFunction(id, name, listener) {
	  var on0, on1, sit = start(name) ? init : set$1;
	  return function() {
	    var schedule = sit(this, id),
	        on = schedule.on;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and we’re done!
	    // Otherwise, copy-on-write.
	    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

	    schedule.on = on1;
	  };
	}

	function transition_on(name, listener) {
	  var id = this._id;

	  return arguments.length < 2
	      ? get$1(this.node(), id).on.on(name)
	      : this.each(onFunction(id, name, listener));
	}

	function removeFunction(id) {
	  return function() {
	    var parent = this.parentNode;
	    for (var i in this.__transition) if (+i !== id) return;
	    if (parent) parent.removeChild(this);
	  };
	}

	function transition_remove() {
	  return this.on("end.remove", removeFunction(this._id));
	}

	function transition_select(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, name, id);
	}

	function transition_selectAll(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
	          if (child = children[k]) {
	            schedule(child, name, id, k, children, inherit);
	          }
	        }
	        subgroups.push(children);
	        parents.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, parents, name, id);
	}

	var Selection$1 = selection.prototype.constructor;

	function transition_selection() {
	  return new Selection$1(this._groups, this._parents);
	}

	function styleNull(name, interpolate) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0 = styleValue(this, name),
	        string1 = (this.style.removeProperty(name), styleValue(this, name));
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, string10 = string1);
	  };
	}

	function styleRemove$1(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant$1(name, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = styleValue(this, name);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function styleFunction$1(name, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0 = styleValue(this, name),
	        value1 = value(this),
	        string1 = value1 + "";
	    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function styleMaybeRemove(id, name) {
	  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
	  return function() {
	    var schedule = set$1(this, id),
	        on = schedule.on,
	        listener = schedule.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and we’re done!
	    // Otherwise, copy-on-write.
	    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

	    schedule.on = on1;
	  };
	}

	function transition_style(name, value, priority) {
	  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
	  return value == null ? this
	      .styleTween(name, styleNull(name, i))
	      .on("end.style." + name, styleRemove$1(name))
	    : typeof value === "function" ? this
	      .styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value)))
	      .each(styleMaybeRemove(this._id, name))
	    : this
	      .styleTween(name, styleConstant$1(name, i, value), priority)
	      .on("end.style." + name, null);
	}

	function styleInterpolate(name, i, priority) {
	  return function(t) {
	    this.style.setProperty(name, i.call(this, t), priority);
	  };
	}

	function styleTween(name, value, priority) {
	  var t, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
	    return t;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_styleTween(name, value, priority) {
	  var key = "style." + (name += "");
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
	}

	function textConstant$1(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction$1(value) {
	  return function() {
	    var value1 = value(this);
	    this.textContent = value1 == null ? "" : value1;
	  };
	}

	function transition_text(value) {
	  return this.tween("text", typeof value === "function"
	      ? textFunction$1(tweenValue(this, "text", value))
	      : textConstant$1(value == null ? "" : value + ""));
	}

	function textInterpolate(i) {
	  return function(t) {
	    this.textContent = i.call(this, t);
	  };
	}

	function textTween(value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_textTween(value) {
	  var key = "text";
	  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, textTween(value));
	}

	function transition_transition() {
	  var name = this._name,
	      id0 = this._id,
	      id1 = newId();

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        var inherit = get$1(node, id0);
	        schedule(node, name, id1, i, group, {
	          time: inherit.time + inherit.delay + inherit.duration,
	          delay: 0,
	          duration: inherit.duration,
	          ease: inherit.ease
	        });
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id1);
	}

	function transition_end() {
	  var on0, on1, that = this, id = that._id, size = that.size();
	  return new Promise(function(resolve, reject) {
	    var cancel = {value: reject},
	        end = {value: function() { if (--size === 0) resolve(); }};

	    that.each(function() {
	      var schedule = set$1(this, id),
	          on = schedule.on;

	      // If this node shared a dispatch with the previous node,
	      // just assign the updated shared dispatch and we’re done!
	      // Otherwise, copy-on-write.
	      if (on !== on0) {
	        on1 = (on0 = on).copy();
	        on1._.cancel.push(cancel);
	        on1._.interrupt.push(cancel);
	        on1._.end.push(end);
	      }

	      schedule.on = on1;
	    });

	    // The selection was empty, resolve end immediately
	    if (size === 0) resolve();
	  });
	}

	var id = 0;

	function Transition(groups, parents, name, id) {
	  this._groups = groups;
	  this._parents = parents;
	  this._name = name;
	  this._id = id;
	}

	function newId() {
	  return ++id;
	}

	var selection_prototype = selection.prototype;

	Transition.prototype = {
	  constructor: Transition,
	  select: transition_select,
	  selectAll: transition_selectAll,
	  filter: transition_filter,
	  merge: transition_merge,
	  selection: transition_selection,
	  transition: transition_transition,
	  call: selection_prototype.call,
	  nodes: selection_prototype.nodes,
	  node: selection_prototype.node,
	  size: selection_prototype.size,
	  empty: selection_prototype.empty,
	  each: selection_prototype.each,
	  on: transition_on,
	  attr: transition_attr,
	  attrTween: transition_attrTween,
	  style: transition_style,
	  styleTween: transition_styleTween,
	  text: transition_text,
	  textTween: transition_textTween,
	  remove: transition_remove,
	  tween: transition_tween,
	  delay: transition_delay,
	  duration: transition_duration,
	  ease: transition_ease,
	  easeVarying: transition_easeVarying,
	  end: transition_end,
	  [Symbol.iterator]: selection_prototype[Symbol.iterator]
	};

	function cubicInOut(t) {
	  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
	}

	var defaultTiming = {
	  time: null, // Set on use.
	  delay: 0,
	  duration: 250,
	  ease: cubicInOut
	};

	function inherit(node, id) {
	  var timing;
	  while (!(timing = node.__transition) || !(timing = timing[id])) {
	    if (!(node = node.parentNode)) {
	      throw new Error(`transition ${id} not found`);
	    }
	  }
	  return timing;
	}

	function selection_transition(name) {
	  var id,
	      timing;

	  if (name instanceof Transition) {
	    id = name._id, name = name._name;
	  } else {
	    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
	  }

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        schedule(node, name, id, i, group, timing || inherit(node, id));
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id);
	}

	selection.prototype.interrupt = selection_interrupt;
	selection.prototype.transition = selection_transition;

	function initAnimationDuration(instance) {
		var animation_duration = 0;

		return function(value) {
			if (value === undefined) return animation_duration;
			animation_duration = value;
			return instance;
		};
	}

	function defaultFormat(value) { return "" + value; }

	function initFormat(instance) {
		var currentFormat = defaultFormat;
		return function(func) {
			if (func === undefined) return currentFormat || defaultFormat;
			else currentFormat = func;
			return instance;
		};
	}

	var t0 = new Date,
	    t1 = new Date;

	function newInterval(floori, offseti, count, field) {

	  function interval(date) {
	    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
	  }

	  interval.floor = function(date) {
	    return floori(date = new Date(+date)), date;
	  };

	  interval.ceil = function(date) {
	    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
	  };

	  interval.round = function(date) {
	    var d0 = interval(date),
	        d1 = interval.ceil(date);
	    return date - d0 < d1 - date ? d0 : d1;
	  };

	  interval.offset = function(date, step) {
	    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
	  };

	  interval.range = function(start, stop, step) {
	    var range = [], previous;
	    start = interval.ceil(start);
	    step = step == null ? 1 : Math.floor(step);
	    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
	    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
	    while (previous < start && start < stop);
	    return range;
	  };

	  interval.filter = function(test) {
	    return newInterval(function(date) {
	      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
	    }, function(date, step) {
	      if (date >= date) {
	        if (step < 0) while (++step <= 0) {
	          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
	        } else while (--step >= 0) {
	          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
	        }
	      }
	    });
	  };

	  if (count) {
	    interval.count = function(start, end) {
	      t0.setTime(+start), t1.setTime(+end);
	      floori(t0), floori(t1);
	      return Math.floor(count(t0, t1));
	    };

	    interval.every = function(step) {
	      step = Math.floor(step);
	      return !isFinite(step) || !(step > 0) ? null
	          : !(step > 1) ? interval
	          : interval.filter(field
	              ? function(d) { return field(d) % step === 0; }
	              : function(d) { return interval.count(0, d) % step === 0; });
	    };
	  }

	  return interval;
	}

	var millisecond = newInterval(function() {
	  // noop
	}, function(date, step) {
	  date.setTime(+date + step);
	}, function(start, end) {
	  return end - start;
	});

	// An optimized implementation for this simple case.
	millisecond.every = function(k) {
	  k = Math.floor(k);
	  if (!isFinite(k) || !(k > 0)) return null;
	  if (!(k > 1)) return millisecond;
	  return newInterval(function(date) {
	    date.setTime(Math.floor(date / k) * k);
	  }, function(date, step) {
	    date.setTime(+date + step * k);
	  }, function(start, end) {
	    return (end - start) / k;
	  });
	};

	var durationSecond = 1e3;
	var durationMinute = 6e4;
	var durationHour = 36e5;
	var durationDay = 864e5;
	var durationWeek = 6048e5;

	var second = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds());
	}, function(date, step) {
	  date.setTime(+date + step * durationSecond);
	}, function(start, end) {
	  return (end - start) / durationSecond;
	}, function(date) {
	  return date.getUTCSeconds();
	});

	var minute = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute);
	}, function(start, end) {
	  return (end - start) / durationMinute;
	}, function(date) {
	  return date.getMinutes();
	});

	var hour = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour);
	}, function(start, end) {
	  return (end - start) / durationHour;
	}, function(date) {
	  return date.getHours();
	});

	var day = newInterval(
	  date => date.setHours(0, 0, 0, 0),
	  (date, step) => date.setDate(date.getDate() + step),
	  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
	  date => date.getDate() - 1
	);

	function weekday(i) {
	  return newInterval(function(date) {
	    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setDate(date.getDate() + step * 7);
	  }, function(start, end) {
	    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
	  });
	}

	var sunday = weekday(0);
	var monday = weekday(1);
	var tuesday = weekday(2);
	var wednesday = weekday(3);
	var thursday = weekday(4);
	var friday = weekday(5);
	var saturday = weekday(6);

	var month = newInterval(function(date) {
	  date.setDate(1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setMonth(date.getMonth() + step);
	}, function(start, end) {
	  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
	}, function(date) {
	  return date.getMonth();
	});

	var year = newInterval(function(date) {
	  date.setMonth(0, 1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setFullYear(date.getFullYear() + step);
	}, function(start, end) {
	  return end.getFullYear() - start.getFullYear();
	}, function(date) {
	  return date.getFullYear();
	});

	// An optimized implementation for this simple case.
	year.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
	    date.setMonth(0, 1);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setFullYear(date.getFullYear() + step * k);
	  });
	};

	var utcDay = newInterval(function(date) {
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCDate(date.getUTCDate() + step);
	}, function(start, end) {
	  return (end - start) / durationDay;
	}, function(date) {
	  return date.getUTCDate() - 1;
	});

	function utcWeekday(i) {
	  return newInterval(function(date) {
	    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCDate(date.getUTCDate() + step * 7);
	  }, function(start, end) {
	    return (end - start) / durationWeek;
	  });
	}

	var utcSunday = utcWeekday(0);
	var utcMonday = utcWeekday(1);
	var utcTuesday = utcWeekday(2);
	var utcWednesday = utcWeekday(3);
	var utcThursday = utcWeekday(4);
	var utcFriday = utcWeekday(5);
	var utcSaturday = utcWeekday(6);

	var utcYear = newInterval(function(date) {
	  date.setUTCMonth(0, 1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCFullYear(date.getUTCFullYear() + step);
	}, function(start, end) {
	  return end.getUTCFullYear() - start.getUTCFullYear();
	}, function(date) {
	  return date.getUTCFullYear();
	});

	// An optimized implementation for this simple case.
	utcYear.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
	    date.setUTCMonth(0, 1);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCFullYear(date.getUTCFullYear() + step * k);
	  });
	};

	function localDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
	    date.setFullYear(d.y);
	    return date;
	  }
	  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
	}

	function utcDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
	    date.setUTCFullYear(d.y);
	    return date;
	  }
	  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
	}

	function newDate(y, m, d) {
	  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
	}

	function formatLocale(locale) {
	  var locale_dateTime = locale.dateTime,
	      locale_date = locale.date,
	      locale_time = locale.time,
	      locale_periods = locale.periods,
	      locale_weekdays = locale.days,
	      locale_shortWeekdays = locale.shortDays,
	      locale_months = locale.months,
	      locale_shortMonths = locale.shortMonths;

	  var periodRe = formatRe(locale_periods),
	      periodLookup = formatLookup(locale_periods),
	      weekdayRe = formatRe(locale_weekdays),
	      weekdayLookup = formatLookup(locale_weekdays),
	      shortWeekdayRe = formatRe(locale_shortWeekdays),
	      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
	      monthRe = formatRe(locale_months),
	      monthLookup = formatLookup(locale_months),
	      shortMonthRe = formatRe(locale_shortMonths),
	      shortMonthLookup = formatLookup(locale_shortMonths);

	  var formats = {
	    "a": formatShortWeekday,
	    "A": formatWeekday,
	    "b": formatShortMonth,
	    "B": formatMonth,
	    "c": null,
	    "d": formatDayOfMonth,
	    "e": formatDayOfMonth,
	    "f": formatMicroseconds,
	    "g": formatYearISO,
	    "G": formatFullYearISO,
	    "H": formatHour24,
	    "I": formatHour12,
	    "j": formatDayOfYear,
	    "L": formatMilliseconds,
	    "m": formatMonthNumber,
	    "M": formatMinutes,
	    "p": formatPeriod,
	    "q": formatQuarter,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatSeconds,
	    "u": formatWeekdayNumberMonday,
	    "U": formatWeekNumberSunday,
	    "V": formatWeekNumberISO,
	    "w": formatWeekdayNumberSunday,
	    "W": formatWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatYear,
	    "Y": formatFullYear,
	    "Z": formatZone,
	    "%": formatLiteralPercent
	  };

	  var utcFormats = {
	    "a": formatUTCShortWeekday,
	    "A": formatUTCWeekday,
	    "b": formatUTCShortMonth,
	    "B": formatUTCMonth,
	    "c": null,
	    "d": formatUTCDayOfMonth,
	    "e": formatUTCDayOfMonth,
	    "f": formatUTCMicroseconds,
	    "g": formatUTCYearISO,
	    "G": formatUTCFullYearISO,
	    "H": formatUTCHour24,
	    "I": formatUTCHour12,
	    "j": formatUTCDayOfYear,
	    "L": formatUTCMilliseconds,
	    "m": formatUTCMonthNumber,
	    "M": formatUTCMinutes,
	    "p": formatUTCPeriod,
	    "q": formatUTCQuarter,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatUTCSeconds,
	    "u": formatUTCWeekdayNumberMonday,
	    "U": formatUTCWeekNumberSunday,
	    "V": formatUTCWeekNumberISO,
	    "w": formatUTCWeekdayNumberSunday,
	    "W": formatUTCWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatUTCYear,
	    "Y": formatUTCFullYear,
	    "Z": formatUTCZone,
	    "%": formatLiteralPercent
	  };

	  var parses = {
	    "a": parseShortWeekday,
	    "A": parseWeekday,
	    "b": parseShortMonth,
	    "B": parseMonth,
	    "c": parseLocaleDateTime,
	    "d": parseDayOfMonth,
	    "e": parseDayOfMonth,
	    "f": parseMicroseconds,
	    "g": parseYear,
	    "G": parseFullYear,
	    "H": parseHour24,
	    "I": parseHour24,
	    "j": parseDayOfYear,
	    "L": parseMilliseconds,
	    "m": parseMonthNumber,
	    "M": parseMinutes,
	    "p": parsePeriod,
	    "q": parseQuarter,
	    "Q": parseUnixTimestamp,
	    "s": parseUnixTimestampSeconds,
	    "S": parseSeconds,
	    "u": parseWeekdayNumberMonday,
	    "U": parseWeekNumberSunday,
	    "V": parseWeekNumberISO,
	    "w": parseWeekdayNumberSunday,
	    "W": parseWeekNumberMonday,
	    "x": parseLocaleDate,
	    "X": parseLocaleTime,
	    "y": parseYear,
	    "Y": parseFullYear,
	    "Z": parseZone,
	    "%": parseLiteralPercent
	  };

	  // These recursive directive definitions must be deferred.
	  formats.x = newFormat(locale_date, formats);
	  formats.X = newFormat(locale_time, formats);
	  formats.c = newFormat(locale_dateTime, formats);
	  utcFormats.x = newFormat(locale_date, utcFormats);
	  utcFormats.X = newFormat(locale_time, utcFormats);
	  utcFormats.c = newFormat(locale_dateTime, utcFormats);

	  function newFormat(specifier, formats) {
	    return function(date) {
	      var string = [],
	          i = -1,
	          j = 0,
	          n = specifier.length,
	          c,
	          pad,
	          format;

	      if (!(date instanceof Date)) date = new Date(+date);

	      while (++i < n) {
	        if (specifier.charCodeAt(i) === 37) {
	          string.push(specifier.slice(j, i));
	          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
	          else pad = c === "e" ? " " : "0";
	          if (format = formats[c]) c = format(date, pad);
	          string.push(c);
	          j = i + 1;
	        }
	      }

	      string.push(specifier.slice(j, i));
	      return string.join("");
	    };
	  }

	  function newParse(specifier, Z) {
	    return function(string) {
	      var d = newDate(1900, undefined, 1),
	          i = parseSpecifier(d, specifier, string += "", 0),
	          week, day$1;
	      if (i != string.length) return null;

	      // If a UNIX timestamp is specified, return it.
	      if ("Q" in d) return new Date(d.Q);
	      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

	      // If this is utcParse, never use the local timezone.
	      if (Z && !("Z" in d)) d.Z = 0;

	      // The am-pm flag is 0 for AM, and 1 for PM.
	      if ("p" in d) d.H = d.H % 12 + d.p * 12;

	      // If the month was not specified, inherit from the quarter.
	      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

	      // Convert day-of-week and week-of-year to day-of-year.
	      if ("V" in d) {
	        if (d.V < 1 || d.V > 53) return null;
	        if (!("w" in d)) d.w = 1;
	        if ("Z" in d) {
	          week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
	          week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
	          week = utcDay.offset(week, (d.V - 1) * 7);
	          d.y = week.getUTCFullYear();
	          d.m = week.getUTCMonth();
	          d.d = week.getUTCDate() + (d.w + 6) % 7;
	        } else {
	          week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
	          week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
	          week = day.offset(week, (d.V - 1) * 7);
	          d.y = week.getFullYear();
	          d.m = week.getMonth();
	          d.d = week.getDate() + (d.w + 6) % 7;
	        }
	      } else if ("W" in d || "U" in d) {
	        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
	        day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
	        d.m = 0;
	        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
	      }

	      // If a time zone is specified, all fields are interpreted as UTC and then
	      // offset according to the specified time zone.
	      if ("Z" in d) {
	        d.H += d.Z / 100 | 0;
	        d.M += d.Z % 100;
	        return utcDate(d);
	      }

	      // Otherwise, all fields are in local time.
	      return localDate(d);
	    };
	  }

	  function parseSpecifier(d, specifier, string, j) {
	    var i = 0,
	        n = specifier.length,
	        m = string.length,
	        c,
	        parse;

	    while (i < n) {
	      if (j >= m) return -1;
	      c = specifier.charCodeAt(i++);
	      if (c === 37) {
	        c = specifier.charAt(i++);
	        parse = parses[c in pads ? specifier.charAt(i++) : c];
	        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
	      } else if (c != string.charCodeAt(j++)) {
	        return -1;
	      }
	    }

	    return j;
	  }

	  function parsePeriod(d, string, i) {
	    var n = periodRe.exec(string.slice(i));
	    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	  }

	  function parseShortWeekday(d, string, i) {
	    var n = shortWeekdayRe.exec(string.slice(i));
	    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	  }

	  function parseWeekday(d, string, i) {
	    var n = weekdayRe.exec(string.slice(i));
	    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	  }

	  function parseShortMonth(d, string, i) {
	    var n = shortMonthRe.exec(string.slice(i));
	    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	  }

	  function parseMonth(d, string, i) {
	    var n = monthRe.exec(string.slice(i));
	    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	  }

	  function parseLocaleDateTime(d, string, i) {
	    return parseSpecifier(d, locale_dateTime, string, i);
	  }

	  function parseLocaleDate(d, string, i) {
	    return parseSpecifier(d, locale_date, string, i);
	  }

	  function parseLocaleTime(d, string, i) {
	    return parseSpecifier(d, locale_time, string, i);
	  }

	  function formatShortWeekday(d) {
	    return locale_shortWeekdays[d.getDay()];
	  }

	  function formatWeekday(d) {
	    return locale_weekdays[d.getDay()];
	  }

	  function formatShortMonth(d) {
	    return locale_shortMonths[d.getMonth()];
	  }

	  function formatMonth(d) {
	    return locale_months[d.getMonth()];
	  }

	  function formatPeriod(d) {
	    return locale_periods[+(d.getHours() >= 12)];
	  }

	  function formatQuarter(d) {
	    return 1 + ~~(d.getMonth() / 3);
	  }

	  function formatUTCShortWeekday(d) {
	    return locale_shortWeekdays[d.getUTCDay()];
	  }

	  function formatUTCWeekday(d) {
	    return locale_weekdays[d.getUTCDay()];
	  }

	  function formatUTCShortMonth(d) {
	    return locale_shortMonths[d.getUTCMonth()];
	  }

	  function formatUTCMonth(d) {
	    return locale_months[d.getUTCMonth()];
	  }

	  function formatUTCPeriod(d) {
	    return locale_periods[+(d.getUTCHours() >= 12)];
	  }

	  function formatUTCQuarter(d) {
	    return 1 + ~~(d.getUTCMonth() / 3);
	  }

	  return {
	    format: function(specifier) {
	      var f = newFormat(specifier += "", formats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    parse: function(specifier) {
	      var p = newParse(specifier += "", false);
	      p.toString = function() { return specifier; };
	      return p;
	    },
	    utcFormat: function(specifier) {
	      var f = newFormat(specifier += "", utcFormats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    utcParse: function(specifier) {
	      var p = newParse(specifier += "", true);
	      p.toString = function() { return specifier; };
	      return p;
	    }
	  };
	}

	var pads = {"-": "", "_": " ", "0": "0"},
	    numberRe = /^\s*\d+/, // note: ignores next directive
	    percentRe = /^%/,
	    requoteRe = /[\\^$*+?|[\]().{}]/g;

	function pad(value, fill, width) {
	  var sign = value < 0 ? "-" : "",
	      string = (sign ? -value : value) + "",
	      length = string.length;
	  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	}

	function requote(s) {
	  return s.replace(requoteRe, "\\$&");
	}

	function formatRe(names) {
	  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
	}

	function formatLookup(names) {
	  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
	}

	function parseWeekdayNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.w = +n[0], i + n[0].length) : -1;
	}

	function parseWeekdayNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.u = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.U = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberISO(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.V = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.W = +n[0], i + n[0].length) : -1;
	}

	function parseFullYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 4));
	  return n ? (d.y = +n[0], i + n[0].length) : -1;
	}

	function parseYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
	}

	function parseZone(d, string, i) {
	  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
	  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
	}

	function parseQuarter(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
	}

	function parseMonthNumber(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
	}

	function parseDayOfMonth(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.d = +n[0], i + n[0].length) : -1;
	}

	function parseDayOfYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
	}

	function parseHour24(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.H = +n[0], i + n[0].length) : -1;
	}

	function parseMinutes(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.M = +n[0], i + n[0].length) : -1;
	}

	function parseSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.S = +n[0], i + n[0].length) : -1;
	}

	function parseMilliseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.L = +n[0], i + n[0].length) : -1;
	}

	function parseMicroseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 6));
	  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
	}

	function parseLiteralPercent(d, string, i) {
	  var n = percentRe.exec(string.slice(i, i + 1));
	  return n ? i + n[0].length : -1;
	}

	function parseUnixTimestamp(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.Q = +n[0], i + n[0].length) : -1;
	}

	function parseUnixTimestampSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.s = +n[0], i + n[0].length) : -1;
	}

	function formatDayOfMonth(d, p) {
	  return pad(d.getDate(), p, 2);
	}

	function formatHour24(d, p) {
	  return pad(d.getHours(), p, 2);
	}

	function formatHour12(d, p) {
	  return pad(d.getHours() % 12 || 12, p, 2);
	}

	function formatDayOfYear(d, p) {
	  return pad(1 + day.count(year(d), d), p, 3);
	}

	function formatMilliseconds(d, p) {
	  return pad(d.getMilliseconds(), p, 3);
	}

	function formatMicroseconds(d, p) {
	  return formatMilliseconds(d, p) + "000";
	}

	function formatMonthNumber(d, p) {
	  return pad(d.getMonth() + 1, p, 2);
	}

	function formatMinutes(d, p) {
	  return pad(d.getMinutes(), p, 2);
	}

	function formatSeconds(d, p) {
	  return pad(d.getSeconds(), p, 2);
	}

	function formatWeekdayNumberMonday(d) {
	  var day = d.getDay();
	  return day === 0 ? 7 : day;
	}

	function formatWeekNumberSunday(d, p) {
	  return pad(sunday.count(year(d) - 1, d), p, 2);
	}

	function dISO(d) {
	  var day = d.getDay();
	  return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
	}

	function formatWeekNumberISO(d, p) {
	  d = dISO(d);
	  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
	}

	function formatWeekdayNumberSunday(d) {
	  return d.getDay();
	}

	function formatWeekNumberMonday(d, p) {
	  return pad(monday.count(year(d) - 1, d), p, 2);
	}

	function formatYear(d, p) {
	  return pad(d.getFullYear() % 100, p, 2);
	}

	function formatYearISO(d, p) {
	  d = dISO(d);
	  return pad(d.getFullYear() % 100, p, 2);
	}

	function formatFullYear(d, p) {
	  return pad(d.getFullYear() % 10000, p, 4);
	}

	function formatFullYearISO(d, p) {
	  var day = d.getDay();
	  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
	  return pad(d.getFullYear() % 10000, p, 4);
	}

	function formatZone(d) {
	  var z = d.getTimezoneOffset();
	  return (z > 0 ? "-" : (z *= -1, "+"))
	      + pad(z / 60 | 0, "0", 2)
	      + pad(z % 60, "0", 2);
	}

	function formatUTCDayOfMonth(d, p) {
	  return pad(d.getUTCDate(), p, 2);
	}

	function formatUTCHour24(d, p) {
	  return pad(d.getUTCHours(), p, 2);
	}

	function formatUTCHour12(d, p) {
	  return pad(d.getUTCHours() % 12 || 12, p, 2);
	}

	function formatUTCDayOfYear(d, p) {
	  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
	}

	function formatUTCMilliseconds(d, p) {
	  return pad(d.getUTCMilliseconds(), p, 3);
	}

	function formatUTCMicroseconds(d, p) {
	  return formatUTCMilliseconds(d, p) + "000";
	}

	function formatUTCMonthNumber(d, p) {
	  return pad(d.getUTCMonth() + 1, p, 2);
	}

	function formatUTCMinutes(d, p) {
	  return pad(d.getUTCMinutes(), p, 2);
	}

	function formatUTCSeconds(d, p) {
	  return pad(d.getUTCSeconds(), p, 2);
	}

	function formatUTCWeekdayNumberMonday(d) {
	  var dow = d.getUTCDay();
	  return dow === 0 ? 7 : dow;
	}

	function formatUTCWeekNumberSunday(d, p) {
	  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
	}

	function UTCdISO(d) {
	  var day = d.getUTCDay();
	  return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
	}

	function formatUTCWeekNumberISO(d, p) {
	  d = UTCdISO(d);
	  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
	}

	function formatUTCWeekdayNumberSunday(d) {
	  return d.getUTCDay();
	}

	function formatUTCWeekNumberMonday(d, p) {
	  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
	}

	function formatUTCYear(d, p) {
	  return pad(d.getUTCFullYear() % 100, p, 2);
	}

	function formatUTCYearISO(d, p) {
	  d = UTCdISO(d);
	  return pad(d.getUTCFullYear() % 100, p, 2);
	}

	function formatUTCFullYear(d, p) {
	  return pad(d.getUTCFullYear() % 10000, p, 4);
	}

	function formatUTCFullYearISO(d, p) {
	  var day = d.getUTCDay();
	  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
	  return pad(d.getUTCFullYear() % 10000, p, 4);
	}

	function formatUTCZone() {
	  return "+0000";
	}

	function formatLiteralPercent() {
	  return "%";
	}

	function formatUnixTimestamp(d) {
	  return +d;
	}

	function formatUnixTimestampSeconds(d) {
	  return Math.floor(+d / 1000);
	}

	var locale;
	var timeFormat;
	var timeParse;

	defaultLocale({
	  dateTime: "%x, %X",
	  date: "%-m/%-d/%Y",
	  time: "%-I:%M:%S %p",
	  periods: ["AM", "PM"],
	  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	});

	function defaultLocale(definition) {
	  locale = formatLocale(definition);
	  timeFormat = locale.format;
	  timeParse = locale.parse;
	  locale.utcFormat;
	  locale.utcParse;
	  return locale;
	}

	var defaultNumberParser = parseFloat;
	var defaultDatetimeParser = timeParse("%Y-%m-%d");


	function initNumberParse(instance) {
		var currentNumberParser = defaultNumberParser;
		return function(func) {
			if (func === undefined) return currentNumberParser || defaultNumberParser;
			else currentNumberParser = func;
			return instance;
		};
	}


	function initDatetimeParse(instance) {
		var currentDatetimeParser = defaultDatetimeParser;
		return function(func) {
			if (func === undefined) return currentDatetimeParser || defaultDatetimeParser;
			else currentDatetimeParser = func;
			return instance;
		};
	}

	function initDimensions(instance) {
		var dimensions = {};
		var width = null;
		var height = null;
		var plot_aspect = null;

		dimensions.width = function(value) {
			if (value === undefined) {
				if (width !== null) return width;
				return instance.svg.node().getBoundingClientRect().width;
			}
			width = value;
			return instance;
		};

		dimensions.height = function(value) {
			if (value === undefined) {
				if (height !== null) return height;
				else if (plot_aspect !== null) {
					return dimensions.plotHeight() + instance.margins.top + instance.margins.bottom;
				}
				return instance.svg.node().getBoundingClientRect().height;
			}
			height = value;
			plot_aspect = null;
			return instance;
		};

		dimensions.plotAspect = function(value) {
			if (value === undefined) {
				if (plot_aspect !== null) return plot_aspect;
				return dimensions.plotWidth() / dimensions.plotHeight();
			}
			height = null;
			plot_aspect = value;
			return instance;
		};

		dimensions.plotWidth = function() {
			return instance.width() - (instance.margins.right + instance.margins.left);
		};

		dimensions.plotHeight = function() {
			if (plot_aspect === null) {
				return dimensions.height() - (instance.margins.top + instance.margins.bottom);
			}
			return dimensions.plotWidth() / plot_aspect;
		};

		dimensions.xLeft = function() {
			return instance.margins.left;
		};

		dimensions.xRight = function() {
			return instance.width() - instance.margins.right;
		};

		dimensions.yBottom = function() {
			return instance.height() - instance.margins.bottom;
		};

		dimensions.yTop = function() {
			return instance.margins.top;
		};

		return dimensions;
	}


	function initOffsetLeft(instance) {
		var left_offset = 0;

		return function(value) {
			if (value === undefined) return left_offset;
			else left_offset = value;
			return instance;
		};
	}


	function initOffsetTop(instance) {
		var top_offset = 0;

		return function(value) {
			if (value === undefined) return top_offset;
			else top_offset = value;
			return instance;
		};
	}

	function getUniqueValues(arr) {
		var uniq_arr = [];
		var uniq_obj = [];
		arr.forEach(function(d) {
			if (uniq_obj[d]) return;
			uniq_arr.push(d);
			uniq_obj[d] = true;
		});
		return uniq_arr;
	}

	var isArray = Array.isArray;

	function identity$1(x) {
		return x;
	}

	function createAdder(obj) {
		var prop = function(name, value) {
			Object.defineProperty(obj, name, { value: value, enumerable: true });
		};

		var getter = function(name, func) {
			Object.defineProperty(obj, name, { get: func, enumerable: true });
		};

		var method = function(name, func) {
			Object.defineProperty(obj, name, { value: func });
		};

		return {
			prop: prop,
			getter: getter,
			method: method
		};
	}

	// 1 2 2 4
	function best(sorted_values, lowest_first) {
		var reducer = lowest_first ? "reduce" : "reduceRight";
		var rank = 1;
		return sorted_values[reducer](function(lookup, d) {
			if (!lookup[d]) lookup[d] = rank;
			rank += 1;
			return lookup;
		}, {});
	}

	// 1 3 3 4
	function worst(sorted_values, lowest_first) {
		var reducer = lowest_first ? "reduce" : "reduceRight";
		var rank = 1;
		return sorted_values[reducer](function(lookup, d) {
			lookup[d] = rank++;
			return lookup;
		}, {});
	}

	// 1 2 2 3
	function dense(sorted_values, lowest_first) {
		var reducer = lowest_first ? "reduce" : "reduceRight";
		var rank = 1;
		return sorted_values[reducer](function(lookup, d) {
			if (!lookup[d]) lookup[d] = rank++;
			return lookup;
		}, {});
	}

	// 1 2.5 2.5 4
	function fractional(sorted_values, lowest_first) {
		var ll = best(sorted_values, lowest_first);
		var hl = worst(sorted_values, lowest_first);
		return Object.keys(ll).reduce(function(obj, key) {
			obj[key] = (ll[key] + hl[key]) / 2;
			return obj;
		}, {});
	}


	function rank(unsorted_values, sorted_values, lowest_first, ties_method) {
		var lookup;
		if (ties_method === "dense") lookup = dense(sorted_values, lowest_first);
		else if (ties_method === "fractional") lookup = fractional(sorted_values, lowest_first);
		else if (ties_method === "worst") lookup = worst(sorted_values, lowest_first);
		else lookup = best(sorted_values, lowest_first);

		var mapFunc = function(d) { return lookup[d]; };
		// ties_method ordinal (1 2 3 4) uses lowest lookup but then modifies it in place
		if (ties_method === "ordinal") mapFunc = function(d) { return lookup[d]++; };

		return unsorted_values.map(mapFunc);
	}

	function getRandomIntegerGenerator(nextRandom) {
		nextRandom = nextRandom || Math.random;
		return function(first, last) {
			var n = (last - first) + 1;
			return Math.floor(nextRandom() * n) + first;
		};
	}


	function randomFromArray(values, nextRandom) {
		var index = getRandomIntegerGenerator(nextRandom)(0, values.length-1);
		return values[index];
	}


	function sampleArray(values, n_samples, replace, nextRandom) {
		var n_points = values.length;
		replace = n_samples !== undefined ? replace : false;
		n_samples = n_samples !== undefined ? Math.floor(n_samples) : n_points;

		if (!n_points || n_samples < 1) return [];

		var out;
		var getRandomInteger = getRandomIntegerGenerator(nextRandom);

		if (replace || n_samples === 1) {
			out = [];
			for (var i = 0; i < n_samples; i++) {
				out.push(values[getRandomInteger(0, n_points - 1)]);
			}
			return out;
		}

		out = values.slice();
		var n = Math.min(n_points, n_samples);

		for (var i = 0; i < n; i++) {
			var pick_index = getRandomInteger(i, n_points - 1);
			if (pick_index === i) continue;
			var pick = out[pick_index];
			var temp = out[i];
			out[i] = pick;
			out [pick_index] = temp;
		}

		out.length = n;

		return out;
	}

	function uncleanArray(dataset, dropped_indexes, dirty_value) {
		if (!dropped_indexes.length) return dataset.slice();

		var counter = 0;
		var unclean_data = dataset.reduce(function(arr, d) {
			while (arr.length === dropped_indexes[counter]) {
				arr.push(dirty_value);
				counter++;
			}
			arr.push(d);
			return arr;
		}, []);
		while (dropped_indexes[counter++]) unclean_data.push(dirty_value);

		return unclean_data;
	}

	function addSorting(add) {
		add.method("unsorted", function() { return this.values.slice(); });
		add.method("ascending", function() { return this.sorted_values.slice(); });
		add.method("descending", function() { return this.sorted_values.slice().reverse(); });
		add.method("unique", function() { return getUniqueValues(this.values); });
		add.method("uniqueAscending", function() { return getUniqueValues(this.sorted_values); });
		add.method("uniqueDescending", function() { return getUniqueValues(this.sorted_values).reverse(); });
	}

	function ascending$1(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending$1(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending$1);

	function number(x) {
	  return x === null ? NaN : +x;
	}

	function d3_variance(values, valueof) {
	  var n = values.length,
	      m = 0,
	      i = -1,
	      mean = 0,
	      value,
	      delta,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  if (m > 1) return sum / (m - 1);
	}

	function d3_quantile(values, p, valueof) {
	  if (valueof == null) valueof = number;
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	}

	function quantiles(sorted_data, vals) {
		if (!isArray(vals)) return d3_quantile(sorted_data, vals);
		return vals.map(function(d) { return d3_quantile(sorted_data, d); });
	}


	function addSummaries(add) {
		var variance = function() {
			return d3_variance(this.values);
		};

		var sd = function() {
			return Math.sqrt(this.variance);
		};

		var quartiles = function() {
			return quantiles(this.sorted_values, [ 0.25, 0.5, 0.75 ]);
		};

		var median = function() {
			return quantiles(this.sorted_values, 0.5);
		};

		var iqr = function() {
			var iq = quantiles(this.sorted_values, [ 0.25, 0.75 ]);
			return iq[1] - iq[0];
		};

		add.getter("variance", variance);
		add.getter("sd", sd);
		add.getter("median", median);
		add.getter("iqr", iqr);
		add.method("quantiles", function(vals) { return quantiles(this.sorted_values, vals); });
		add.method("quartiles", quartiles);
	}

	function addSampling(add) {
		add.method("random", function(nextRandom) {
			return randomFromArray(this.values, nextRandom);
		});

		add.method("sample", function(n_samples, replace, nextRandom) {
			return sampleArray(this.values, n_samples, replace, nextRandom);
		});
	}

	function addRanking(add) {
		add.method("rank", function(lowest_first, ties_method) {
			return rank(this.values, this.sorted_values, lowest_first, ties_method);
		});
	}

	function addUncleaning(add) {
		add.method("unclean", function(dataset) {
			if (dataset && dataset.length < this.values.length) throw new RangeError("dataset is too short");
			if (dataset && dataset.length > this.values.length) throw new RangeError("dataset is too long");
			dataset = dataset || this.values;
			return uncleanArray(dataset, this.dropped_indexes, NaN);
		});
	}

	function init$1() {
		var proto = {};
		var add = createAdder(proto);
		addSorting(add);
		addSummaries(add);
		addSampling(add);
		addRanking(add);
		addUncleaning(add);
		return proto;
	}

	function isAscending(arr) {
		var prev = -Infinity;
		return arr.every(function(d) {
			if (d >= prev) {
				prev = d;
				return true;
			}
		});
	}

	function isDescending(arr) {
		var prev = Infinity;
		return arr.every(function(d) {
			if (d <= prev) {
				prev = d;
				return true;
			}
		});
	}

	function init$2(obj, input_data, accessor) {
		accessor = accessor || identity$1;

		var min = Infinity;
		var max = -Infinity;
		var sorted_values = null;
		var sum = 0;
		var dropped_indexes = [];

		var values = Object.freeze(input_data.reduce(function(arr, d, i) {
			var value = accessor(d);
			if (typeof value === "number" && !isNaN(value)) {
				arr.push(value);
				min = Math.min(min, value);
				max = Math.max(max, value);
				sum += value;
			}
			else dropped_indexes.push(i);
			return arr;
		}, []));

		var add = createAdder(obj);

		add.prop("enhanced_array", true);
		add.prop("numeric_array", true);
		add.prop("values", values);
		add.prop("min", values.length ? min : null);
		add.prop("max", values.length ? max : null);
		add.prop("sum", sum);
		add.prop("mean", values.length ? sum / values.length : null);
		add.prop("range", values.length ? max - min : null);
		add.prop("length", values.length);
		add.prop("dropped_indexes", Object.freeze(dropped_indexes));
		add.method("extent", function() { return [this.min, this.max]; });

		add.getter("sorted_values", function() {
			if (!sorted_values) {
				if (isAscending(values)) sorted_values = values;
				if (isDescending(values)) sorted_values = Object.freeze(values.slice().reverse());
				else sorted_values = Object.freeze(values.slice().sort(ascending$1));
			}
			return sorted_values;
		});

		return obj;
	}

	var proto = init$1();

	function init$3(input_data, accessor) {
		var obj = Object.create(proto);
		init$2(obj, input_data, accessor);
		return obj;
	}

	var PROPS_TO_STEAL = Object.freeze([ "min", "max", "mean" ]);

	var METHODS_TO_STEAL = Object.freeze([
		"extent",
		"random", "sample",
		"unsorted", "ascending", "descending", "unique", "uniqueAscending", "uniqueDescending",
		"quartiles", "quantiles",
		"unclean"
	]);


	function isValidDate(entity) {
		return Object.prototype.toString.call(entity) === "[object Date]" && !isNaN(entity.getTime());
	}


	function numberToDate(num) {
		if (typeof num !== "number") return null;
		return new Date(num);
	}


	function _stealMethod(numeric_array, method) {
		return function() {
			var res = numeric_array[method].apply(numeric_array, arguments);
			return Array.isArray(res) ? res.map(numberToDate) : numberToDate(res);
		};
	}


	function init$4(obj, input_data, accessor) {
		accessor = accessor || identity$1;

		var numeric_array = init$3(
			input_data.map(function(d) {
				var dt = accessor(d);
				return isValidDate(dt) ? dt.getTime(): null;
			})
		);

		var add = createAdder(obj);

		add.prop("enhanced_array", true);
		add.prop("datetime_array", true);
		add.getter("values", function() { return Object.freeze(numeric_array.values.map(numberToDate)); });
		add.getter("sorted_values", function() { return Object.freeze(numeric_array.sorted_values.map(numberToDate)); });
		add.getter("median", function() { return numberToDate(numeric_array.median); });
		add.prop("length", numeric_array.values.length);
		add.prop("dropped_indexes", numeric_array.dropped_indexes);
		add.method("rank", function() { return numeric_array.rank(arguments); });

		var stealMethod = _stealMethod.bind(null, numeric_array);
		PROPS_TO_STEAL.forEach(function(prop) { add.prop(prop, numberToDate(numeric_array[prop])); });
		METHODS_TO_STEAL.forEach(function(method) { add.method(method, stealMethod(method)); });

		return obj;
	}

	// import initProto from "./proto";

	// var proto = initProto();

	function init$5(input_data, accessor) {
		var obj = {}; // Object.create(proto);
		init$4(obj, input_data, accessor);
		return obj;
	}

	function addSorting$1(add) {
		add.method("unsorted", function() { return this.values.slice(); });
		add.method("ascending", function() { return this.sorted_values.slice(); });
		add.method("descending", function() { return this.sorted_values.slice().reverse(); });
		add.method("unique", function() { return getUniqueValues(this.values); });
		add.method("uniqueAscending", function() { return getUniqueValues(this.sorted_values); });
		add.method("uniqueDescending", function() { return getUniqueValues(this.sorted_values).reverse(); });
	}

	function addSampling$1(add) {
		add.method("random", function(nextRandom) {
			return randomFromArray(this.values, nextRandom);
		});

		add.method("sample", function(n_samples, replace, nextRandom) {
			return sampleArray(this.values, n_samples, replace, nextRandom);
		});
	}

	function addRanks(add) {
		add.method("rank", function(lowest_first, ties_method) {
			return rank(this.values, this.sorted_values, lowest_first, ties_method);
		});
	}

	function addUncleaning$1(add) {
		add.method("unclean", function(dataset) {
			if (dataset && dataset.length < this.values.length) throw new RangeError("dataset is too short");
			if (dataset && dataset.length > this.values.length) throw new RangeError("dataset is too long");
			dataset = dataset || this.values;
			return uncleanArray(dataset, this.dropped_indexes);
		});
	}

	function init$6() {
		var proto = {};
		var add = createAdder(proto);
		addSorting$1(add);
		addSampling$1(add);
		addRanks(add);
		addUncleaning$1(add);
		return proto;
	}

	function isAscending$1(arr) {
		if (arr.length < 2) return true;
		var prev = arr[0];
		return arr.every(function(d) {
			if (d >= prev) {
				prev = d;
				return true;
			}
		});
	}

	function isDescending$1(arr) {
		if (arr.length < 2) return true;
		var prev = arr[0];
		return arr.every(function(d) {
			if (d <= prev) {
				prev = d;
				return true;
			}
		});
	}

	function init$7(obj, input_data, accessor) {
		accessor = accessor || identity$1;

		var sorted_values = null;
		var dropped_indexes = [];
		var n_empty = 0;

		var min = null;
		var i = 0;
		while (min === null && i < input_data.length) {
			var val = accessor(input_data[i++]);
			if (typeof val === "string") min = val;
		}
		var max = min;

		var values = Object.freeze(input_data.reduce(function(arr, d, i) {
			var value = accessor(d);
			if (typeof value === "string") {
				arr.push(value);
				min = value < min ? value : min;
				max = value > max ? value : max;
				if (!value) n_empty++;
			}
			else dropped_indexes.push(i);
			return arr;
		}, []));

		var add = createAdder(obj);

		add.prop("enhanced_array", true);
		add.prop("string_array", true);
		add.prop("values", values);
		add.prop("min", min);
		add.prop("max", max);
		add.prop("length", values.length);
		add.prop("dropped_indexes", Object.freeze(dropped_indexes));
		add.prop("n_empty", n_empty);
		add.method("extent", function() { return [this.min, this.max]; });

		add.getter("sorted_values", function() {
			if (!sorted_values) {
				if (isAscending$1(values)) sorted_values = values;
				if (isDescending$1(values)) sorted_values = Object.freeze(values.slice().reverse());
				else sorted_values = Object.freeze(values.slice().sort());
			}
			return sorted_values;
		});

		return obj;
	}

	var proto$1 = init$6();

	function init$8(input_data, accessor) {
		var obj = Object.create(proto$1);
		init$7(obj, input_data, accessor);
		return obj;
	}

	var remToPx;
	function updateRemToPx() {
		var multiplier = parseFloat(getComputedStyle(document.documentElement).fontSize);
		var dpr = window.devicePixelRatio;

		remToPx = function(rem, round) {
			if (!rem) return 0;
			if (!round) return rem * multiplier;
			return Math.max(Math.round(rem * multiplier * dpr), 1) / dpr;
		};
	}


	function getFont(container_selection, size_in_rem, weight) {
		var family_string = getComputedStyle(container_selection.node()).fontFamily;
		var size = remToPx(size_in_rem);
		var size_string = size + "px ";
		var weight_string = weight ? weight + " " : "";
		return weight_string + size_string + family_string;
	}


	function xyToTranslate(x, y) {
		return "translate(" + x + "," + y +")";
	}


	function angleToRotate(angle, x, y) {
		x = x || 0;
		y = y || 0;
		return "rotate(" + angle + "," + x + "," + y + ")";
	}


	var log10 = Math.log10 || function(x) { return Math.log(x) * Math.LOG10E; };


	function getExponent(value) {
		return Math.floor(log10(Math.abs(value)));
	}


	// Based on https://stackoverflow.com/a/22885197
	function getSignificantDigitCount(v) {
		if (v === 0) return 0;
		var value = Math.abs(String(v).replace(".", "")); // remove decimal and make positive
		while (value !== 0 && value % 10 === 0) value /= 10; // kill the 0s at the end of n
		return getExponent(value) + 1; // get number of digits
	}


	// Based on https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
	function linesIntersect(p, q) {
		var x1 = p[0][0], x2 = p[1][0], x3 = q[0][0], x4 = q[1][0];
		var y1 = p[0][1], y2 = p[1][1], y3 = q[0][1], y4 = q[1][1];
		var denominator = (x1-x2) * (y3-y4) - (x3-x4) * (y1-y2);

		// Parallel lines
		if (!denominator) {
			if (
				(x1 < x3 && x1 < x4 && x2 < x3 && x2 < x4) // p is left of q
				|| (x1 > x3 && x1 > x4 && x2 > x3 && x2 > x4) // p is right of q
				|| (y1 < y3 && y1 < y4 && y2 < y3 && y2 < y4) // p is above q
				|| (y1 > y3 && y1 > y4 && y2 > y3 && y2 > y4) // p is below q
			) return false;
			return true;
		}

		var t = ((x1-x3)*(y3-y4) - (y1-y3)*(x3-x4)) / denominator;
		if (t < 0 || t > 1) return false; // point of intersection does not fall within the p line segment
		var u = -((x1-x2)*(y1-y3) - (y1-y2)*(x1-x3)) / denominator;
		if (u < 0 || u > 1) return false; // point of intersection does not fall within the q line segment

		return true;
	}


	function sign(val) {
		if (!val || typeof val !== "number") return 0;
		return val > 0 ? 1 : -1;
	}


	// The safeScale function wraps a standard d3-scale, preventing it from returning a NaN value or +-Infinity
	// which can lead to errors when being used for translations during transitions - eg from a linear scale to
	// a log scale or vice versa
	function safeScale(scale) {
		var type = scale.type; // Store the type since scale.copy won't copy that custom property across
		scale = scale.copy(); // Use a copy of the scale so it can't be tampered with from outside
		scale.type = type; // Add the type information to the new scale
		var SAFE_POSITION = -1e6; // The +-1e6th pixel should not be on screen
		var COPIED_METHODS = ["domain", "range"];

		var scaleWrapper = function(unscaled_value) {
			var val = scale(unscaled_value);
			// Catch values that will break SVG transforms
			if (isNaN(val) || Math.abs(val) === Infinity) {
				// Work out whether should be off top/left (flipped === false) or bottom/right (flipped)
				var flipped;
				var range = scale.range();
				if (type !== "numeric") flipped = range[0] > range[1] ? true : false;
				else {
					var domain = scale.domain();
					// flipped true for ordinary y axis or x axis is set so go largest -> smallest
					flipped = sign(domain[1] - domain[0]) !== sign(range[1] - range[0]);
				}
				val = SAFE_POSITION * (flipped ? -1 : 1);
			}
			return val;
		};

		// Having the range and domain easily accessible is useful, so apply these functions
		COPIED_METHODS.forEach(function(name) {
			scaleWrapper[name] = function() {
				var result = scale[name].apply(scale, arguments);
				// Return the wrapper rather than the wrapped scale object
				return result === scale ? scaleWrapper : result;
			};
		});

		// Add a custom copy method and the type and step properties to the wrapper
		scaleWrapper.copy = function() { return safeScale(scale); };
		scaleWrapper.type = scale.type;
		scaleWrapper.step = scale.step;

		return scaleWrapper;
	}


	function isDate(entity) {
		return Object.prototype.toString.call(entity) === "[object Date]";
	}


	function isValidDate$1(entity) {
		return isDate(entity) && !isNaN(entity.getTime());
	}


	function textareaToArray(text_string) {
		return text_string.split("\n")
			.filter(function(d) { return d; })
			.map(function(d) { return d.trim(); });
	}

	var ERROR_MESSAGE = "Input data must be an array or Flourish array";


	function getFrozenData(input_data, accessor) {
		if (!input_data) throw new TypeError(ERROR_MESSAGE);
		if (input_data.enhanced_array) return input_data;
		if (!Array.isArray(input_data)) throw new TypeError(ERROR_MESSAGE);

		var acc = accessor || function(x) { return x; };

		for (var i = 0; i < input_data.length; i++) {
			var value = acc(input_data[i]);
			var type = typeof value;
			if (type === "number") return init$3(input_data, accessor);
			if (type === "string") return init$8(input_data, accessor);
			if (isDate(value)) return init$5(input_data, accessor);
		}

		return init$3(input_data, accessor);
	}


	function initData(instance) {
		var current_data = getFrozenData([]);

		return function(data, accessor) {
			if (data === undefined) return current_data;
			current_data = getFrozenData(data, accessor);
			return instance;
		};
	}

	var DUMMY_TEXT = "Testing";


	function degToRad(deg) {
		return deg * (Math.PI / 180);
	}


	function dropRepeatedLabels(tick_array, format) {
		var last_value;
		return tick_array.filter(function(value) {
			var fv = format(value);
			if (fv === last_value) return;
			last_value = fv;
			return true;
		});
	}

	function getFitTextFunction(params) {
		var max_space = params.max_space !== undefined ? params.max_space : 100;
		var text_height = params.text_height !== undefined ? params.text_height : remToPx(1);
		var max_lines = params.max_lines;
		var angle = params.angle || 0;
		var canvas = document.createElement("canvas");
		var ctx = canvas.getContext("2d");
		ctx.font = params.font;

		var max_width = max_space;
		var theta = degToRad(angle);
		max_width = (max_space - text_height * Math.sin(theta)) / Math.cos(theta);

		return function(text) {
			var lines = [];
			var max_line_width = 0;

			// Everything fits in one line, so leave as a single string
			var text_width = ctx.measureText(text).width;
			if (text_width <= max_width) {
				lines.push(text);
				max_line_width = text_width;
			}

			// Otherwise…
			else {
				// Create array of words
				var words = text.trim().split(/\s+/g);
				// Loop through the words, adding them until they won't fit
				var current_line = "";
				for (var i = 0; i < words.length; i++) {
					var word = words[i];
					var string = current_line + (current_line ? " " : "") + word;
					var string_width = ctx.measureText(string).width;
					// If the string including the next word fits, update the
					// current_line and the max_width
					if (string_width <= max_width) {
						current_line = string;
						max_line_width = Math.max(max_line_width, string_width);
					}
					// If we reach this point, the text has overflowed,
					// so should always result in a truncation or a new line
					else {
						var last_line = lines.length + 1 == max_lines;
						if (!last_line && current_line) {
							lines.push(current_line);
							var word_width = ctx.measureText(word).width;
							if (word_width <= max_width) {
								current_line = word;
								continue;
							}
						}
						// Truncate
						var remove_counter = 1;
						var truncated_string = string;
						do {
							truncated_string = string.substring(0, string.length - remove_counter) + "…";
							string_width = ctx.measureText(truncated_string).width;
						}
						while ((string_width > max_width) && (++remove_counter < string.length));
						max_line_width = Math.max(max_line_width, string_width);
						current_line = truncated_string;
						break;
					}
				}
				lines.push(current_line);
			}
			return { lines: lines, text_width: max_line_width };
		};
	}


	function getAutoLabelSpaceFunction(instance, dimension) {
		var UNITS = [ "px", "rem", "fraction" ];
		dimension = dimension || "width";
		var value = 0.3;
		var unit = "fraction";

		var getValues = function() {
			var dim = instance[dimension]();
			var px = unit === "px" ? value : (unit === "rem" ? remToPx(value) : (value * dim));
			return {
				px: px,
				rem: unit === "rem" ? value : px / remToPx(1),
				fraction: unit === "fraction" ? value : px / dim,
				unit: unit
			};
		};

		return function(v, u) {
			if (v === undefined) return getValues();
			value = Math.max(v, 0);
			unit = UNITS.indexOf(u) !== -1 ? u : "px";
			return instance;
		};
	}


	function initXTicks(instance, state) {
		var x = state.x;
		var ticks = Object.freeze([]);
		var group = instance.chart.select(".fl-x-axes");

		var setTicks = function(tick_array) {
			var type = instance.xData().string_array ? "string" : "numeric";
			var font = getFont(select(".fl-x-axes"), x.tick_label_size, x.tick_label_weight);
			var angle = x.tick_label_position === "default" ? +x.tick_label_angle : 90;
			var max_box_height = 0;
			var format = instance.xFormat();
			var text_height;
			var font_size = remToPx(x.tick_label_size);
			// Used in conjunction with line height for estimating the height of each line
			// in a multiline label

			group.append("text")
				.style("opacity", 0)
				.style("font", font)
				.each(function() {
					var bounds = select(this).text(DUMMY_TEXT).node().getBoundingClientRect();
					text_height = bounds.height;
				})
				.remove();

			// filter out dates that will give repeated tick labels
			if (typeof tick_array[0] === "object") tick_array = dropRepeatedLabels(tick_array, format);

			var max_space = remToPx(x.tick_label_space);
			if (x.tick_label_space_mode === "auto") max_space = instance.xTicks.autoLabelSpace().px;
			var params =  { text_height: text_height, max_space: max_space, font: font, angle: 90 - angle, max_lines: x.tick_label_max_lines };
			var fitText = getFitTextFunction(params);

			ticks = tick_array.map(function(value, index) {
				var result = fitText(format(value));
				var lines = result.lines;
				var text_width = result.text_width;
				var box_width, box_height, box_width_left, box_width_right, box_height_left, box_height_right;
				var multiline_offset = 0;

				var total_text_height = (text_height * lines.length) + ((lines.length - 1) * x.tick_label_line_height);
				if (angle === 0 || angle === 90) {
					// Add extra padding for non-rotated text
					box_width = angle === 0 ? text_width + remToPx(0.5) : total_text_height;
					box_height = angle === 0 ? total_text_height : text_width;
					box_width_left = box_width_right = box_width / 2;
					box_height_left = box_height;
					box_height_right = box_height;
					if (angle === 90) multiline_offset = lines.length < 2 ? 0 : ((lines.length - 1)/2 * (font_size * x.tick_label_line_height));
				}
				else {
					/*
				   tl------tr <- rotate about tr
					 |        |
					 bl------br
				*/
					var theta = degToRad(angle);
					var sinTheta = Math.sin(theta);
					var cosTheta = Math.cos(theta);
					box_width_left = text_width * cosTheta; // horizontal distance between tl and tr after rotation
					box_width_right = total_text_height * sinTheta; // horizontal distance between br and tr after rotation
					box_height_left = text_width * sinTheta; // vertical distance between tl and tr after rotation
					box_height_right = total_text_height * cosTheta; // vertical distance between br and tr after rotation
					box_width = box_width_left + box_width_right; // total bounding box width after rotation
					box_height = box_height_left + box_height_right; // total bounding box height after rotation
				}

				// Reverse left and right when axis is at top
				// This can probably be simplified with some basic trigonometry
				if (x.axis_position === "top" || x.axis_position === "float-above") {
					var temp = box_width_left;
					box_width_left = box_width_right;
					box_width_right = temp;
					temp = box_height_left;
					box_height_left = box_height_right;
					box_height_right = temp;

					// Also adjust multiline offsets for angled top/above ticks, since we want
					// the lines to flow upwards not downwards
					if (angle !== 0 && angle !== 90) multiline_offset = lines.length < 2 ? 0 : (lines.length - 1) * (font_size * x.tick_label_line_height);
				}

				max_box_height = Math.max(max_box_height, box_height);
				var significant_digits = type === "numeric" ? getSignificantDigitCount(value) : null;
				var exponent = type === "numeric" ? getExponent(value) : null;

				return Object.freeze({
					index: index,
					value: value,
					lines: lines,
					significant_digits: significant_digits,
					exponent: exponent,
					text_width: text_width,
					text_height: text_height,
					box_width: box_width,
					box_height: box_height,
					box_width_left: box_width_left,
					box_width_right: box_width_right,
					box_height_left: box_height_left,
					box_height_right: box_height_right,
					multiline_offset: multiline_offset
				});
			});

			ticks.type = type;
			ticks.max_box_height = x.tick_label_space_mode === "fixed" ? remToPx(x.tick_label_space) : max_box_height;
			Object.freeze(ticks);

			return instance;
		};

		var getTicks = function() { return ticks; };
		getTicks._update = setTicks;
		getTicks.autoLabelSpace = getAutoLabelSpaceFunction(instance, "height");

		return getTicks;
	}


	function initVerticalTicks(instance, state, y_name) {
		var y = state[y_name];
		var data_name = y_name + "Data";
		var format_name = y_name + "Format";
		var ticks_name = y_name + "Ticks";
		var ticks = Object.freeze([]);
		var group = instance.chart.select(".fl-y-axes");

		var setTicks = function(tick_array) {
			var type = instance[data_name]().string_array ? "string" : "numeric";
			var font = getFont(select(".fl-y-axes"), y.tick_label_size, y.tick_label_weight);
			var angle = y.tick_label_position === "default" ? +y.tick_label_angle : 0;
			var max_box_width = 0;
			var format = instance[format_name]();
			var text_height;

			group.append("text")
				.style("opacity", 0)
				.style("font", font)
				.each(function() {
					var bounds = select(this).text(DUMMY_TEXT).node().getBoundingClientRect();
					text_height = bounds.height;
				})
				.remove();

			// filter out dates that will give repeated tick labels
			if (typeof tick_array[0] === "object") tick_array = dropRepeatedLabels(tick_array, format);

			var max_space = remToPx(y.tick_label_space);
			if (y.tick_label_space_mode === "auto") max_space = instance[ticks_name].autoLabelSpace().px;
			var params =  { text_height: text_height, max_space: max_space, font: font, angle: angle, max_lines: angle ? 1 : y.tick_label_max_lines };
			var fitText = getFitTextFunction(params);

			ticks = tick_array.map(function(value, index) {
				var result = fitText(format(value));
				var lines = result.lines;
				var text_width = result.text_width;
				var box_width, box_height, box_width_above, box_width_below, box_height_above, box_height_below;
				var multiline_offset = 0;

				var total_text_height = (text_height * lines.length) + ((lines.length - 1) * y.tick_label_line_height);
				if (angle === 0 || angle === 90) {
					box_width = !angle ? text_width : total_text_height;
					// Add extra padding for text rotated by 90 degrees
					box_height = !angle ? total_text_height : text_width + remToPx(0.5);
					box_width_above = box_width;
					box_width_below = box_width;
					box_height_above = box_height_below = box_height / 2;
					if (angle === 0) multiline_offset = lines.length < 2 ? 0 : ((lines.length - 1)/2 * (text_height * y.tick_label_line_height));
				}
				else {
					/*
				   tl------tr
					 |        |
					 bl------br <- rotate about br
					*/
					var theta = degToRad(angle);
					var sinTheta = Math.sin(theta);
					var cosTheta = Math.cos(theta);
					box_width_above = total_text_height * sinTheta; // horizontal distance between tr and br after rotation
					box_width_below = text_width * cosTheta; // horizontal distance between bl and br after rotation
					box_height_above = total_text_height * cosTheta; // vertical distance between tr and br after rotation
					box_height_below = text_width * sinTheta; // vertical distance between bl and br after rotation
					box_width = box_width_above + box_width_below; // total bounding box width after rotation
					box_height = box_height_above + box_height_below; // total bounding box height after rotation
				}

				max_box_width = Math.max(max_box_width, box_width);
				var significant_digits = type === "numeric" ? getSignificantDigitCount(value) : null;
				var exponent = type === "numeric" ? getExponent(value) : null;

				return Object.freeze({
					index: index,
					value: value,
					lines: lines,
					type: type,
					significant_digits: significant_digits,
					exponent: exponent,
					text_width: text_width,
					text_height: text_height,
					box_width: box_width,
					box_height: box_height,
					box_width_above: box_width_above,
					box_width_below: box_width_below,
					box_height_above: box_height_above,
					box_height_below: box_height_below,
					multiline_offset: multiline_offset
				});
			});

			ticks.type = type;
			ticks.max_box_width = y.tick_label_space_mode === "fixed" ? remToPx(y.tick_label_space) : max_box_width;
			Object.freeze(ticks);

			return instance;
		};

		var getTicks = function() { return ticks; };
		getTicks._update = setTicks;
		getTicks.autoLabelSpace = getAutoLabelSpaceFunction(instance);

		return getTicks;
	}

	// TODO: Maybe this should take an object?
	function initYTicks(instance, state) {
		return initVerticalTicks(instance, state, "y");
	}

	function initY2Ticks(instance, state) {
		return initVerticalTicks(instance, state, "y2");
	}


	function initAutoTicks(instance, axis = "x") {
		const DEFAULT = () => instance[axis + "Scale"]({ "domain_only": true }).ticks();
		let value = DEFAULT;

		return function(v) {
			if (v === undefined) return value;
			if (v === null) value = DEFAULT;
			else value = v;
			return instance;
		};
	}


	function initXAutoTicks(instance) {
		const func = initAutoTicks(instance, "x");
		return v => func(v);
	}


	function initYAutoTicks(instance) {
		const func = initAutoTicks(instance, "y");
		return v => func(v);
	}


	function initY2AutoTicks(instance) {
		const func = initAutoTicks(instance, "y2");
		return v => func(v);
	}

	function initAutoTitle(instance) {
		var auto_title = "";

		return function(value) {
			if (value === undefined) return auto_title;
			auto_title = value;
			return instance;
		};
	}


	function initXTitle(instance, state) {
		instance.xAutoTitle = initAutoTitle(instance);
		instance.xAutoTitle("X");

		return function() {
			var text = (state.x.title_mode === "auto" ? instance.xAutoTitle() : state.x.title);
			return text.trim();
		};
	}


	function initYTitle(instance, state) {
		instance.yAutoTitle = initAutoTitle(instance);
		instance.yAutoTitle("Y");

		return function() {
			var text = state.y.title_mode === "auto" ? instance.yAutoTitle() : state.y.title;
			return text.trim();
		};
	}


	function initY2Title(instance, state) {
		instance.y2AutoTitle = initAutoTitle(instance);
		instance.y2AutoTitle("Y2");

		return function() {
			var text = (state.y2.title_mode === "auto" ? instance.y2AutoTitle() : state.y2.title);
			return text.trim();
		};
	}

	function getXTitleHeight(instance, state) {
		var x = state.x;
		var title_text = instance.xTitle();
		if (x.axis_visible === "off" || !title_text) return 0;

		var title_container = instance.chart.select(".fl-x-axis .fl-axis-title");
		var font = getFont(title_container, x.title_size, x.title_weight);

		var title_selection = title_container.append("text")
			.text(title_text)
			.style("opacity", 0)
			.style("font", font);

		var title_height = title_selection.node().getBoundingClientRect().height;
		title_selection.remove();
		return title_height + 2 * remToPx(x.title_padding);
	}


	function getYTitleHeight(instance, state) {
		var y = state.y;
		var title_text = instance.yTitle();
		if (!y.axis_visible || !title_text) return 0;

		var title_container = instance.chart.select(".fl-left-axis .fl-axis-title");
		var font = getFont(title_container, y.title_size, y.title_weight);

		var title_selection = title_container.append("text")
			.text(title_text)
			.style("opacity", 0)
			.style("font", font);

		var title_height = title_selection.node().getBoundingClientRect().height;
		title_selection.remove();
		return title_height + 2 * remToPx(y.title_padding);
	}

	// TODO. This function is almost identical to the above so should maybe be combined
	// and take arguments for the state property (y/y2) and the container.
	function getY2TitleHeight(instance, state) {
		var y = state.y2;
		var title_text = instance.y2Title();
		if (!y.axis_visible || !title_text) return 0;

		var title_container = instance.chart.select(".fl-right-axis .fl-axis-title");
		var font = getFont(title_container, y.title_size, y.title_weight);

		var title_selection = title_container.append("text")
			.text(title_text)
			.style("opacity", 0)
			.style("font", font);

		var title_height = title_selection.node().getBoundingClientRect().height;
		title_selection.remove();
		return title_height + 2 * remToPx(y.title_padding);
	}


	function getXAxisSpace(instance, state) {
		// Space for x axis
		var x = state.x;
		var pos = x.axis_position;
		if (pos === "off") return 0;
		var tick_space = 0;
		var tick_padding = 0;
		var tick_label_space = 0;
		if (pos === "top" || pos == "bottom") {
			var ticks = instance.xTicks();
			tick_space = ticks.length && x.tick_side === "out" && x.tick_label_position === "default" ? remToPx(x.tick_length) : 0;
			tick_label_space = ticks.max_box_height || 0;
			tick_padding = ticks.length ? remToPx(x.tick_padding) : 0;
		}
		var title_space = getXTitleHeight(instance, state);
		return tick_space + tick_padding + tick_label_space + title_space;
	}


	function getTopMargin(instance, state) {
		var x = state.x;
		var x_axis_space = 0;
		if (!instance.xHide() && ["top", "float-above"].indexOf(x.axis_position) !== -1) {
			x_axis_space = getXAxisSpace(instance, state);
		}

		var y_offset = 0, y2_offset = 0;
		var y_ticks = !instance.yHide() ? instance.yTicks() : [];
		if (y_ticks.length) {
			var last_y_tick = y_ticks[y_ticks.length - 1]; // Assume last tick is placed at the top of the axis
			if (state.y.tick_label_position == "default") y_offset = 0.9 * last_y_tick.box_height_above;
			else if (state.y.tick_label_position == "above") y_offset += last_y_tick.box_height;
		}
		var y2_ticks = !instance.y2Hide() ? instance.y2Ticks() : [];
		if (y2_ticks.length) {
			var last_y2_tick = y2_ticks[y2_ticks.length - 1]; // Assume last tick is placed at the top of the axis
			if (state.y2.tick_label_position == "default") y2_offset = 0.9 * last_y2_tick.box_height_above;
			else if (state.y2.tick_label_position == "above") y2_offset += last_y2_tick.box_height;
		}
		var y_overflow = Math.max(remToPx(0.25), y_offset, y2_offset);
		return Math.max(x_axis_space, y_overflow);
	}


	function getBottomMargin(instance, state) {
		var x = state.x;
		var x_axis_space = 0;
		if (!instance.xHide() && ["bottom", "float-below"].indexOf(x.axis_position) !== -1) {
			x_axis_space = getXAxisSpace(instance, state);
		}
		var y_offset = 0, y2_offset = 0;
		var y_ticks = !instance.yHide() ? instance.yTicks() : [];
		if (y_ticks.length) {
			var first_y_tick = y_ticks[0]; // Assume first tick is placed at the bottom of the axis
			if (state.y.tick_label_position == "default") y_offset = 0.9 * first_y_tick.box_height_below;
			else if (state.y.tick_label_position == "below") y_offset += first_y_tick.box_height;
		}
		var y2_ticks = !instance.y2Hide() ? instance.y2Ticks() : [];
		if (y2_ticks.length) {
			var first_y2_tick = y2_ticks[0]; // Assume first tick is placed at the bottom of the axis
			if (state.y2.tick_label_position == "default") y2_offset = 0.9 * first_y2_tick.box_height_below;
			else if (state.y2.tick_label_position == "below") y2_offset += first_y2_tick.box_height;
		}
		var y_overflow = Math.max(remToPx(0.25), y_offset, y2_offset);
		return Math.max(x_axis_space, y_overflow);
	}


	function getLeftMargin(instance, state) {
		// Space for y axis
		var y = state.y;
		var axis_width = 0;
		if (y.axis_visible) {
			var ticks = !instance.yHide() ? instance.yTicks() : [];
			var tick_space = ticks.length && y.tick_side === "out" && y.tick_label_position === "default" ? remToPx(y.tick_length) : 0;
			var tick_padding = ticks.length ? remToPx(y.tick_padding) : 0;
			var tick_label_space = ticks.max_box_width || 0;
			var title_space = !instance.yHide() ? getYTitleHeight(instance, state) : 0;
			axis_width = tick_space + tick_padding + tick_label_space + title_space;
		}

		// Space for overflowing x tick
		var x_overflow = remToPx(0.25), offset = 0;
		var x_ticks = !instance.xHide() ? instance.xTicks() : [];
		if (x_ticks.length) {
			var first_x_tick = x_ticks[0]; // Assume first tick is placed at the left edge of the axis
			if (state.x.tick_label_position == "default") offset = 0.9 * first_x_tick.box_width_left;
			else if (state.x.tick_label_position == "left") offset = first_x_tick.box_width;
			x_overflow = Math.max(x_overflow, offset);
		}

		return Math.max(axis_width, x_overflow);
	}


	function getRightMargin(instance, state) {
		// Space for y axis
		var y2 = state.y2;
		var axis_width = 0;
		if (y2.axis_visible) {
			var y2_ticks = !instance.y2Hide() ? instance.y2Ticks() : [];
			var tick_space = y2_ticks.length && (y2.tick_side === "out" && y2.tick_label_position === "default") ? remToPx(y2.tick_length) : 0;
			var tick_padding = y2_ticks.length ? remToPx(y2.tick_padding) : 0;
			var tick_label_space = y2_ticks.max_box_width || 0;
			var title_space = !instance.y2Hide() ? getY2TitleHeight(instance, state) : 0;
			axis_width = tick_space + tick_padding + tick_label_space + title_space;
		}

		// Space for overflowing x tick
		var x_overflow = remToPx(0.25), offset = 0;
		var x_ticks = !instance.xHide() ? instance.xTicks() : [];
		if (x_ticks.length) {
			var last_x_tick = x_ticks[x_ticks.length - 1]; // Assume last tick is placed at the right edge of the axis
			if (state.x.tick_label_position == "default") offset = 0.9 * last_x_tick.box_width_right;
			else if (state.x.tick_label_position == "right") offset = last_x_tick.box_width;
			x_overflow = Math.max(x_overflow, offset);
		}

		return Math.max(axis_width, x_overflow);
	}


	function initMargins(instance, state) {
		var top, right, bottom, left;

		var updateMargins = function(overrides) {
			overrides = overrides || {};
			top = overrides.top !== undefined ? overrides.top : getTopMargin(instance, state);
			right = overrides.right !== undefined ? overrides.right : getRightMargin(instance, state);
			bottom = overrides.bottom !== undefined ? overrides.bottom : getBottomMargin(instance, state);
			left = overrides.left !== undefined ? overrides.left : getLeftMargin(instance, state);
		};

		var margins = function() {
			return { top: top, right: right, bottom: bottom, left: left };
		};

		margins._update = updateMargins;

		Object.defineProperty(margins, "top", { get: function() { return top; } });
		Object.defineProperty(margins, "right", { get: function() { return right; } });
		Object.defineProperty(margins, "bottom", { get: function() { return bottom; } });
		Object.defineProperty(margins, "left", { get: function() { return left; } });

		return margins;
	}

	function ascending$2(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector$1(f) {
	  let delta = f;
	  let compare = f;

	  if (f.length === 1) {
	    delta = (d, x) => f(d) - x;
	    compare = ascendingComparator$1(f);
	  }

	  function left(a, x, lo, hi) {
	    if (lo == null) lo = 0;
	    if (hi == null) hi = a.length;
	    while (lo < hi) {
	      const mid = (lo + hi) >>> 1;
	      if (compare(a[mid], x) < 0) lo = mid + 1;
	      else hi = mid;
	    }
	    return lo;
	  }

	  function right(a, x, lo, hi) {
	    if (lo == null) lo = 0;
	    if (hi == null) hi = a.length;
	    while (lo < hi) {
	      const mid = (lo + hi) >>> 1;
	      if (compare(a[mid], x) > 0) hi = mid;
	      else lo = mid + 1;
	    }
	    return lo;
	  }

	  function center(a, x, lo, hi) {
	    if (lo == null) lo = 0;
	    if (hi == null) hi = a.length;
	    const i = left(a, x, lo, hi - 1);
	    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
	  }

	  return {left, center, right};
	}

	function ascendingComparator$1(f) {
	  return (d, x) => ascending$2(f(d), x);
	}

	function number$1(x) {
	  return x === null ? NaN : +x;
	}

	const ascendingBisect$1 = bisector$1(ascending$2);
	const bisectRight = ascendingBisect$1.right;
	const bisectCenter = bisector$1(number$1).center;

	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);

	function ticks(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    step = -step;
	    start = Math.ceil(start * step);
	    stop = Math.floor(stop * step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	}

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	function sequence(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	}

	function initRange(domain, range) {
	  switch (arguments.length) {
	    case 0: break;
	    case 1: this.range(domain); break;
	    default: this.range(range).domain(domain); break;
	  }
	  return this;
	}

	const implicit = Symbol("implicit");

	function ordinal() {
	  var index = new Map(),
	      domain = [],
	      range = [],
	      unknown = implicit;

	  function scale(d) {
	    var key = d + "", i = index.get(key);
	    if (!i) {
	      if (unknown !== implicit) return unknown;
	      index.set(key, i = domain.push(d));
	    }
	    return range[(i - 1) % range.length];
	  }

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [], index = new Map();
	    for (const value of _) {
	      const key = value + "";
	      if (index.has(key)) continue;
	      index.set(key, domain.push(value));
	    }
	    return scale;
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = Array.from(_), scale) : range.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return ordinal(domain, range).unknown(unknown);
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function band() {
	  var scale = ordinal().unknown(undefined),
	      domain = scale.domain,
	      ordinalRange = scale.range,
	      r0 = 0,
	      r1 = 1,
	      step,
	      bandwidth,
	      round = false,
	      paddingInner = 0,
	      paddingOuter = 0,
	      align = 0.5;

	  delete scale.unknown;

	  function rescale() {
	    var n = domain().length,
	        reverse = r1 < r0,
	        start = reverse ? r1 : r0,
	        stop = reverse ? r0 : r1;
	    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
	    if (round) step = Math.floor(step);
	    start += (stop - start - step * (n - paddingInner)) * align;
	    bandwidth = step * (1 - paddingInner);
	    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
	    var values = sequence(n).map(function(i) { return start + step * i; });
	    return ordinalRange(reverse ? values.reverse() : values);
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.range = function(_) {
	    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
	  };

	  scale.rangeRound = function(_) {
	    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
	  };

	  scale.bandwidth = function() {
	    return bandwidth;
	  };

	  scale.step = function() {
	    return step;
	  };

	  scale.round = function(_) {
	    return arguments.length ? (round = !!_, rescale()) : round;
	  };

	  scale.padding = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
	  };

	  scale.paddingInner = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
	  };

	  scale.paddingOuter = function(_) {
	    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
	  };

	  scale.align = function(_) {
	    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	  };

	  scale.copy = function() {
	    return band(domain(), [r0, r1])
	        .round(round)
	        .paddingInner(paddingInner)
	        .paddingOuter(paddingOuter)
	        .align(align);
	  };

	  return initRange.apply(rescale(), arguments);
	}

	function pointish(scale) {
	  var copy = scale.copy;

	  scale.padding = scale.paddingOuter;
	  delete scale.paddingInner;
	  delete scale.paddingOuter;

	  scale.copy = function() {
	    return pointish(copy());
	  };

	  return scale;
	}

	function point() {
	  return pointish(band.apply(null, arguments).paddingInner(1));
	}

	function constants(x) {
	  return function() {
	    return x;
	  };
	}

	function number$2(x) {
	  return +x;
	}

	var unit = [0, 1];

	function identity$2(x) {
	  return x;
	}

	function normalize(a, b) {
	  return (b -= (a = +a))
	      ? function(x) { return (x - a) / b; }
	      : constants(isNaN(b) ? NaN : 0.5);
	}

	function clamper(a, b) {
	  var t;
	  if (a > b) t = a, a = b, b = t;
	  return function(x) { return Math.max(a, Math.min(b, x)); };
	}

	// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
	// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
	function bimap(domain, range, interpolate) {
	  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
	  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
	  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
	  return function(x) { return r0(d0(x)); };
	}

	function polymap(domain, range, interpolate) {
	  var j = Math.min(domain.length, range.length) - 1,
	      d = new Array(j),
	      r = new Array(j),
	      i = -1;

	  // Reverse descending domains.
	  if (domain[j] < domain[0]) {
	    domain = domain.slice().reverse();
	    range = range.slice().reverse();
	  }

	  while (++i < j) {
	    d[i] = normalize(domain[i], domain[i + 1]);
	    r[i] = interpolate(range[i], range[i + 1]);
	  }

	  return function(x) {
	    var i = bisectRight(domain, x, 1, j) - 1;
	    return r[i](d[i](x));
	  };
	}

	function copy(source, target) {
	  return target
	      .domain(source.domain())
	      .range(source.range())
	      .interpolate(source.interpolate())
	      .clamp(source.clamp())
	      .unknown(source.unknown());
	}

	function transformer() {
	  var domain = unit,
	      range = unit,
	      interpolate$1 = interpolate,
	      transform,
	      untransform,
	      unknown,
	      clamp = identity$2,
	      piecewise,
	      output,
	      input;

	  function rescale() {
	    var n = Math.min(domain.length, range.length);
	    if (clamp !== identity$2) clamp = clamper(domain[0], domain[n - 1]);
	    piecewise = n > 2 ? polymap : bimap;
	    output = input = null;
	    return scale;
	  }

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
	  }

	  scale.invert = function(y) {
	    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain = Array.from(_, number$2), rescale()) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = _ ? true : identity$2, rescale()) : clamp !== identity$2;
	  };

	  scale.interpolate = function(_) {
	    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t, u) {
	    transform = t, untransform = u;
	    return rescale();
	  };
	}

	function continuous() {
	  return transformer()(identity$2, identity$2);
	}

	function formatDecimal(x) {
	  return Math.abs(x = Math.round(x)) >= 1e21
	      ? x.toLocaleString("en").replace(/,/g, "")
	      : x.toString(10);
	}

	// Computes the decimal coefficient and exponent of the specified number x with
	// significant digits p, where x is positive and p is in [1, 21] or undefined.
	// For example, formatDecimalParts(1.23) returns ["123", 0].
	function formatDecimalParts(x, p) {
	  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
	  var i, coefficient = x.slice(0, i);

	  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
	  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
	  return [
	    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
	    +x.slice(i + 1)
	  ];
	}

	function exponent(x) {
	  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
	}

	function formatGroup(grouping, thousands) {
	  return function(value, width) {
	    var i = value.length,
	        t = [],
	        j = 0,
	        g = grouping[0],
	        length = 0;

	    while (i > 0 && g > 0) {
	      if (length + g + 1 > width) g = Math.max(1, width - length);
	      t.push(value.substring(i -= g, i + g));
	      if ((length += g + 1) > width) break;
	      g = grouping[j = (j + 1) % grouping.length];
	    }

	    return t.reverse().join(thousands);
	  };
	}

	function formatNumerals(numerals) {
	  return function(value) {
	    return value.replace(/[0-9]/g, function(i) {
	      return numerals[+i];
	    });
	  };
	}

	// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
	var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

	function formatSpecifier(specifier) {
	  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	  var match;
	  return new FormatSpecifier({
	    fill: match[1],
	    align: match[2],
	    sign: match[3],
	    symbol: match[4],
	    zero: match[5],
	    width: match[6],
	    comma: match[7],
	    precision: match[8] && match[8].slice(1),
	    trim: match[9],
	    type: match[10]
	  });
	}

	formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

	function FormatSpecifier(specifier) {
	  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
	  this.align = specifier.align === undefined ? ">" : specifier.align + "";
	  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
	  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
	  this.zero = !!specifier.zero;
	  this.width = specifier.width === undefined ? undefined : +specifier.width;
	  this.comma = !!specifier.comma;
	  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
	  this.trim = !!specifier.trim;
	  this.type = specifier.type === undefined ? "" : specifier.type + "";
	}

	FormatSpecifier.prototype.toString = function() {
	  return this.fill
	      + this.align
	      + this.sign
	      + this.symbol
	      + (this.zero ? "0" : "")
	      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
	      + (this.comma ? "," : "")
	      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
	      + (this.trim ? "~" : "")
	      + this.type;
	};

	// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
	function formatTrim(s) {
	  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
	    switch (s[i]) {
	      case ".": i0 = i1 = i; break;
	      case "0": if (i0 === 0) i0 = i; i1 = i; break;
	      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
	    }
	  }
	  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
	}

	var prefixExponent;

	function formatPrefixAuto(x, p) {
	  var d = formatDecimalParts(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1],
	      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
	      n = coefficient.length;
	  return i === n ? coefficient
	      : i > n ? coefficient + new Array(i - n + 1).join("0")
	      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
	      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
	}

	function formatRounded(x, p) {
	  var d = formatDecimalParts(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1];
	  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
	      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
	      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
	}

	var formatTypes = {
	  "%": (x, p) => (x * 100).toFixed(p),
	  "b": (x) => Math.round(x).toString(2),
	  "c": (x) => x + "",
	  "d": formatDecimal,
	  "e": (x, p) => x.toExponential(p),
	  "f": (x, p) => x.toFixed(p),
	  "g": (x, p) => x.toPrecision(p),
	  "o": (x) => Math.round(x).toString(8),
	  "p": (x, p) => formatRounded(x * 100, p),
	  "r": formatRounded,
	  "s": formatPrefixAuto,
	  "X": (x) => Math.round(x).toString(16).toUpperCase(),
	  "x": (x) => Math.round(x).toString(16)
	};

	function identity$3(x) {
	  return x;
	}

	var map = Array.prototype.map,
	    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

	function formatLocale$1(locale) {
	  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$3 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
	      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
	      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
	      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
	      numerals = locale.numerals === undefined ? identity$3 : formatNumerals(map.call(locale.numerals, String)),
	      percent = locale.percent === undefined ? "%" : locale.percent + "",
	      minus = locale.minus === undefined ? "−" : locale.minus + "",
	      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

	  function newFormat(specifier) {
	    specifier = formatSpecifier(specifier);

	    var fill = specifier.fill,
	        align = specifier.align,
	        sign = specifier.sign,
	        symbol = specifier.symbol,
	        zero = specifier.zero,
	        width = specifier.width,
	        comma = specifier.comma,
	        precision = specifier.precision,
	        trim = specifier.trim,
	        type = specifier.type;

	    // The "n" type is an alias for ",g".
	    if (type === "n") comma = true, type = "g";

	    // The "" type, and any invalid type, is an alias for ".12~g".
	    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

	    // If zero fill is specified, padding goes after sign and before digits.
	    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

	    // Compute the prefix and suffix.
	    // For SI-prefix, the suffix is lazily computed.
	    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
	        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

	    // What format function should we use?
	    // Is this an integer type?
	    // Can this type generate exponential notation?
	    var formatType = formatTypes[type],
	        maybeSuffix = /[defgprs%]/.test(type);

	    // Set the default precision if not specified,
	    // or clamp the specified precision to the supported range.
	    // For significant precision, it must be in [1, 21].
	    // For fixed precision, it must be in [0, 20].
	    precision = precision === undefined ? 6
	        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
	        : Math.max(0, Math.min(20, precision));

	    function format(value) {
	      var valuePrefix = prefix,
	          valueSuffix = suffix,
	          i, n, c;

	      if (type === "c") {
	        valueSuffix = formatType(value) + valueSuffix;
	        value = "";
	      } else {
	        value = +value;

	        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
	        var valueNegative = value < 0 || 1 / value < 0;

	        // Perform the initial formatting.
	        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

	        // Trim insignificant zeros.
	        if (trim) value = formatTrim(value);

	        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
	        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

	        // Compute the prefix and suffix.
	        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
	        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

	        // Break the formatted value into the integer “value” part that can be
	        // grouped, and fractional or exponential “suffix” part that is not.
	        if (maybeSuffix) {
	          i = -1, n = value.length;
	          while (++i < n) {
	            if (c = value.charCodeAt(i), 48 > c || c > 57) {
	              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
	              value = value.slice(0, i);
	              break;
	            }
	          }
	        }
	      }

	      // If the fill character is not "0", grouping is applied before padding.
	      if (comma && !zero) value = group(value, Infinity);

	      // Compute the padding.
	      var length = valuePrefix.length + value.length + valueSuffix.length,
	          padding = length < width ? new Array(width - length + 1).join(fill) : "";

	      // If the fill character is "0", grouping is applied after padding.
	      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

	      // Reconstruct the final output based on the desired alignment.
	      switch (align) {
	        case "<": value = valuePrefix + value + valueSuffix + padding; break;
	        case "=": value = valuePrefix + padding + value + valueSuffix; break;
	        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
	        default: value = padding + valuePrefix + value + valueSuffix; break;
	      }

	      return numerals(value);
	    }

	    format.toString = function() {
	      return specifier + "";
	    };

	    return format;
	  }

	  function formatPrefix(specifier, value) {
	    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
	        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
	        k = Math.pow(10, -e),
	        prefix = prefixes[8 + e / 3];
	    return function(value) {
	      return f(k * value) + prefix;
	    };
	  }

	  return {
	    format: newFormat,
	    formatPrefix: formatPrefix
	  };
	}

	var locale$1;
	var format;
	var formatPrefix;

	defaultLocale$1({
	  thousands: ",",
	  grouping: [3],
	  currency: ["$", ""]
	});

	function defaultLocale$1(definition) {
	  locale$1 = formatLocale$1(definition);
	  format = locale$1.format;
	  formatPrefix = locale$1.formatPrefix;
	  return locale$1;
	}

	function precisionFixed(step) {
	  return Math.max(0, -exponent(Math.abs(step)));
	}

	function precisionPrefix(step, value) {
	  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
	}

	function precisionRound(step, max) {
	  step = Math.abs(step), max = Math.abs(max) - step;
	  return Math.max(0, exponent(max) - exponent(step)) + 1;
	}

	function tickFormat(start, stop, count, specifier) {
	  var step = tickStep(start, stop, count),
	      precision;
	  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
	  switch (specifier.type) {
	    case "s": {
	      var value = Math.max(Math.abs(start), Math.abs(stop));
	      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
	      return formatPrefix(specifier, value);
	    }
	    case "":
	    case "e":
	    case "g":
	    case "p":
	    case "r": {
	      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
	      break;
	    }
	    case "f":
	    case "%": {
	      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
	      break;
	    }
	  }
	  return format(specifier);
	}

	function linearish(scale) {
	  var domain = scale.domain;

	  scale.ticks = function(count) {
	    var d = domain();
	    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	  };

	  scale.tickFormat = function(count, specifier) {
	    var d = domain();
	    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
	  };

	  scale.nice = function(count) {
	    if (count == null) count = 10;

	    var d = domain();
	    var i0 = 0;
	    var i1 = d.length - 1;
	    var start = d[i0];
	    var stop = d[i1];
	    var prestep;
	    var step;
	    var maxIter = 10;

	    if (stop < start) {
	      step = start, start = stop, stop = step;
	      step = i0, i0 = i1, i1 = step;
	    }
	    
	    while (maxIter-- > 0) {
	      step = tickIncrement(start, stop, count);
	      if (step === prestep) {
	        d[i0] = start;
	        d[i1] = stop;
	        return domain(d);
	      } else if (step > 0) {
	        start = Math.floor(start / step) * step;
	        stop = Math.ceil(stop / step) * step;
	      } else if (step < 0) {
	        start = Math.ceil(start * step) / step;
	        stop = Math.floor(stop * step) / step;
	      } else {
	        break;
	      }
	      prestep = step;
	    }

	    return scale;
	  };

	  return scale;
	}

	function linear$1() {
	  var scale = continuous();

	  scale.copy = function() {
	    return copy(scale, linear$1());
	  };

	  initRange.apply(scale, arguments);

	  return linearish(scale);
	}

	function nice(domain, interval) {
	  domain = domain.slice();

	  var i0 = 0,
	      i1 = domain.length - 1,
	      x0 = domain[i0],
	      x1 = domain[i1],
	      t;

	  if (x1 < x0) {
	    t = i0, i0 = i1, i1 = t;
	    t = x0, x0 = x1, x1 = t;
	  }

	  domain[i0] = interval.floor(x0);
	  domain[i1] = interval.ceil(x1);
	  return domain;
	}

	function transformLog(x) {
	  return Math.log(x);
	}

	function transformExp(x) {
	  return Math.exp(x);
	}

	function transformLogn(x) {
	  return -Math.log(-x);
	}

	function transformExpn(x) {
	  return -Math.exp(-x);
	}

	function pow10(x) {
	  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
	}

	function powp(base) {
	  return base === 10 ? pow10
	      : base === Math.E ? Math.exp
	      : function(x) { return Math.pow(base, x); };
	}

	function logp(base) {
	  return base === Math.E ? Math.log
	      : base === 10 && Math.log10
	      || base === 2 && Math.log2
	      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
	}

	function reflect(f) {
	  return function(x) {
	    return -f(-x);
	  };
	}

	function loggish(transform) {
	  var scale = transform(transformLog, transformExp),
	      domain = scale.domain,
	      base = 10,
	      logs,
	      pows;

	  function rescale() {
	    logs = logp(base), pows = powp(base);
	    if (domain()[0] < 0) {
	      logs = reflect(logs), pows = reflect(pows);
	      transform(transformLogn, transformExpn);
	    } else {
	      transform(transformLog, transformExp);
	    }
	    return scale;
	  }

	  scale.base = function(_) {
	    return arguments.length ? (base = +_, rescale()) : base;
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.ticks = function(count) {
	    var d = domain(),
	        u = d[0],
	        v = d[d.length - 1],
	        r;

	    if (r = v < u) i = u, u = v, v = i;

	    var i = logs(u),
	        j = logs(v),
	        p,
	        k,
	        t,
	        n = count == null ? 10 : +count,
	        z = [];

	    if (!(base % 1) && j - i < n) {
	      i = Math.floor(i), j = Math.ceil(j);
	      if (u > 0) for (; i <= j; ++i) {
	        for (k = 1, p = pows(i); k < base; ++k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      } else for (; i <= j; ++i) {
	        for (k = base - 1, p = pows(i); k >= 1; --k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      }
	      if (z.length * 2 < n) z = ticks(u, v, n);
	    } else {
	      z = ticks(i, j, Math.min(j - i, n)).map(pows);
	    }

	    return r ? z.reverse() : z;
	  };

	  scale.tickFormat = function(count, specifier) {
	    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
	    if (typeof specifier !== "function") specifier = format(specifier);
	    if (count === Infinity) return specifier;
	    if (count == null) count = 10;
	    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
	    return function(d) {
	      var i = d / pows(Math.round(logs(d)));
	      if (i * base < base - 0.5) i *= base;
	      return i <= k ? specifier(d) : "";
	    };
	  };

	  scale.nice = function() {
	    return domain(nice(domain(), {
	      floor: function(x) { return pows(Math.floor(logs(x))); },
	      ceil: function(x) { return pows(Math.ceil(logs(x))); }
	    }));
	  };

	  return scale;
	}

	function log() {
	  var scale = loggish(transformer()).domain([1, 10]);

	  scale.copy = function() {
	    return copy(scale, log()).base(scale.base());
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	var durationSecond$1 = 1000,
	    durationMinute$1 = durationSecond$1 * 60,
	    durationHour$1 = durationMinute$1 * 60,
	    durationDay$1 = durationHour$1 * 24,
	    durationWeek$1 = durationDay$1 * 7,
	    durationMonth = durationDay$1 * 30,
	    durationYear = durationDay$1 * 365;

	function date$1(t) {
	  return new Date(t);
	}

	function number$3(t) {
	  return t instanceof Date ? +t : +new Date(+t);
	}

	function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
	  var scale = continuous(),
	      invert = scale.invert,
	      domain = scale.domain;

	  var formatMillisecond = format(".%L"),
	      formatSecond = format(":%S"),
	      formatMinute = format("%I:%M"),
	      formatHour = format("%I %p"),
	      formatDay = format("%a %d"),
	      formatWeek = format("%b %d"),
	      formatMonth = format("%B"),
	      formatYear = format("%Y");

	  var tickIntervals = [
	    [second,  1,      durationSecond$1],
	    [second,  5,  5 * durationSecond$1],
	    [second, 15, 15 * durationSecond$1],
	    [second, 30, 30 * durationSecond$1],
	    [minute,  1,      durationMinute$1],
	    [minute,  5,  5 * durationMinute$1],
	    [minute, 15, 15 * durationMinute$1],
	    [minute, 30, 30 * durationMinute$1],
	    [  hour,  1,      durationHour$1  ],
	    [  hour,  3,  3 * durationHour$1  ],
	    [  hour,  6,  6 * durationHour$1  ],
	    [  hour, 12, 12 * durationHour$1  ],
	    [   day,  1,      durationDay$1   ],
	    [   day,  2,  2 * durationDay$1   ],
	    [  week,  1,      durationWeek$1  ],
	    [ month,  1,      durationMonth ],
	    [ month,  3,  3 * durationMonth ],
	    [  year,  1,      durationYear  ]
	  ];

	  function tickFormat(date) {
	    return (second(date) < date ? formatMillisecond
	        : minute(date) < date ? formatSecond
	        : hour(date) < date ? formatMinute
	        : day(date) < date ? formatHour
	        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
	        : year(date) < date ? formatMonth
	        : formatYear)(date);
	  }

	  function tickInterval(interval, start, stop) {
	    if (interval == null) interval = 10;

	    // If a desired tick count is specified, pick a reasonable tick interval
	    // based on the extent of the domain and a rough estimate of tick size.
	    // Otherwise, assume interval is already a time interval and use it.
	    if (typeof interval === "number") {
	      var target = Math.abs(stop - start) / interval,
	          i = bisector$1(function(i) { return i[2]; }).right(tickIntervals, target),
	          step;
	      if (i === tickIntervals.length) {
	        step = tickStep(start / durationYear, stop / durationYear, interval);
	        interval = year;
	      } else if (i) {
	        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
	        step = i[1];
	        interval = i[0];
	      } else {
	        step = Math.max(tickStep(start, stop, interval), 1);
	        interval = millisecond;
	      }
	      return interval.every(step);
	    }

	    return interval;
	  }

	  scale.invert = function(y) {
	    return new Date(invert(y));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? domain(Array.from(_, number$3)) : domain().map(date$1);
	  };

	  scale.ticks = function(interval) {
	    var d = domain(),
	        t0 = d[0],
	        t1 = d[d.length - 1],
	        r = t1 < t0,
	        t;
	    if (r) t = t0, t0 = t1, t1 = t;
	    t = tickInterval(interval, t0, t1);
	    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
	    return r ? t.reverse() : t;
	  };

	  scale.tickFormat = function(count, specifier) {
	    return specifier == null ? tickFormat : format(specifier);
	  };

	  scale.nice = function(interval) {
	    var d = domain();
	    return (interval = tickInterval(interval, d[0], d[d.length - 1]))
	        ? domain(nice(d, interval))
	        : scale;
	  };

	  scale.copy = function() {
	    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
	  };

	  return scale;
	}

	function time() {
	  return initRange.apply(calendar(year, month, sunday, day, hour, minute, second, millisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
	}

	var LOG_SCALE_FACTOR = 1000;


	function getPointScale(data, {edge_padding, flip}) {
		var domain = flip ? data.unique().reverse() : data.unique();
		var scale = point().domain(domain).padding(edge_padding/100);
		scale.type = "ordinal";
		return scale;
	}


	function getLinearDomain(data, {min, max, include_zero, nice, flip}) {
		const FALLBACK_DOMAIN_RANGE = 100; // If we can't construct a sensible default domain, make an arbitrary one this wide
		if (min === max) min = max = null; // If min and max are equal then ignore them both
		// If we have min and max then it's easy
		if (min !== null && max !== null) return flip ? [max, min] : [min, max];

		let domain;
		if (data.range) { // Standard case: multiple different values
			domain = data.extent();
			if (nice) domain = linear$1().domain(domain).nice().domain();
			if (include_zero) {
				if (domain[0] >= 0) domain[0] = 0;
				else if (domain[1] < 0) domain[1] = 0;
			}
		}
		else if (data.length) { // Only one unique value
			var value = data.min;
			if (value > 0) domain = [0, 2 * value]; // Place value in middle of domain starting at 0
			else if (value < 0) domain = [2 * value, 0]; // Place value in middle of domain ending at 0
			else domain = [-FALLBACK_DOMAIN_RANGE/2, FALLBACK_DOMAIN_RANGE/2]; // Domain centred on 0 with arbitrary min and max
		}
		else domain = [0, FALLBACK_DOMAIN_RANGE]; // No values at all: pick arbitrary domain values

		if (min !== null) {
			domain[0] = min;
			// If domain values now match we need to do something, so change the non-specified max value
			if (domain[0] === domain[1]) domain[1] = min + (data.range || FALLBACK_DOMAIN_RANGE);
		}
		else if (max !== null) {
			domain[1] = max;
			// If domain values now match we need to do something, so change the non-specified min value
			if (domain[0] === domain[1]) domain[0] = max - (data.range || FALLBACK_DOMAIN_RANGE);
		}

		return flip ? domain.reverse() : domain;
	}


	function getLinearScale(data, settings) {
		var domain = getLinearDomain(data, settings);
		var scale = linear$1().domain(domain);
		scale.type = "numeric";
		return scale;
	}


	function getLogScale(data, {min, max, nice, flip}) {
		// Get suitable values for the domain based on data
		const extent = data.extent();
		if (extent[0] <= 0) {
			if (extent[1] > 0) extent[0] = Math.min(1, extent[1]/LOG_SCALE_FACTOR);
			else extent[0] = 1;
		}
		if (extent[1] <= extent[0]) extent[1] = LOG_SCALE_FACTOR * extent[0];
		const scale = log().domain(extent);
		if (nice) scale.nice();
		const domain = scale.domain();

		// Override domain values if min and/or max appropriate
		if (min === max) min = max = null;
		if (min > 0) domain[0] = min;
		if (max > 0) domain[1] = max;
		scale.domain(flip ? domain.reverse() : domain);
		scale.type = "numeric";

		return scale;
	}


	function getDatetimeScale(data, {min, max, format, nice, flip}) {
		const extent = data.extent();
		const scale = time().domain(extent);
		if (nice) scale.nice();
		if (format) scale.tickFormat(null, format);
		const domain = scale.domain();

		if (min === max) min = max = null;
		if (min) domain[0] = format(min);
		if (max) domain[1] = format(max);
		scale.domain(flip ? domain.reverse() : domain);
		scale.type = "datetime";

		return scale;
	}

	function minStep(data, scale) {
		if (scale.step) return scale.step();

		const scaled_data = data.uniqueAscending().map(d => scale(d));
		const n = scaled_data.length;
		if (n < 2) return 0;

		let min_step = Infinity;
		for (let i = 1; i < n; i++) {
			const step = Math.abs(scaled_data[i] - scaled_data[i-1]);
			min_step = Math.min(min_step, step);
		}

		return min_step;
	}

	function initXPadding(instance) {
		const UNITS = [ "px", "steps" ];
		let left = 0;
		let right = 0;
		let unit = "px";

		return function(values) {
			if (values === undefined) return { left, right, unit };
			const u = values.unit;
			if (u && !UNITS.includes(u)) throw new Error(`Unit "${u}" not recognised`);
			({ left = left, right = right, unit = unit } = values);
			return instance;
		};
	}


	function getXPadding(instance, x_state, domain) {
		const no_padding = { left: 0, right: 0 };
		const x_data = instance.xData();
		// Ignore developer-set padding on categorical axes because of user-set padding
		if (x_data.string_array) return no_padding;

		const { left, right, unit } = instance.xPadding();

		// Ignore developer-set padding on logarithmic axes if not in px
		if (x_data.numeric_array && x_state.numeric_scale_type !== "linear" && unit !== "px") return no_padding;

		if (unit === "px" || (!left && !right)) return { left, right };

		const unique_values = x_data.uniqueAscending();
		const n = unique_values.length;
		if (n < 2) return no_padding;

		let min_data_step = Infinity;
		for (let i = 1; i < n; i++) {
			const step = Math.abs(unique_values[i] - unique_values[i-1]);
			min_data_step = Math.min(min_data_step, step);
		}

		const domain_width = Math.max(...domain) - Math.min(...domain); // in domain units
		const full_width = domain_width + ((left + right) * min_data_step); // in domain units
		const n_min_steps = full_width / min_data_step;
		const step_width = instance.plot_width / n_min_steps; // in pixels

		return { left: left * step_width, right: right * step_width };
	}


	function initXScale(instance, state) {
		const x = state.x;

		return function(opts = {}) {
			const x_data = instance.xData();
			const settings = { nice: x.nice, flip: instance.xFlipAxis() !== x.flip };
			let getScale;
			if (x_data.string_array) {
				getScale = getPointScale;
				settings.edge_padding = x.edge_padding;
			}
			else if (x_data.datetime_array) {
				getScale = getDatetimeScale;
				settings.min = x.datetime_min;
				settings.max = x.datetime_max;
				settings.format = instance.xDatetimeParse();
			}
			else if (x.numeric_scale_type === "log") {
				getScale = getLogScale;
				settings.min = x.log_min;
				settings.max = x.log_max;
			}
			else {
				getScale = getLinearScale;
				settings.min = x.linear_min;
				settings.max = x.linear_max;
				settings.include_zero = x.zero_axis === "off" ? false : (x.zero_axis === "on" ? true : instance.xZeroAxis());
			}

			const xScale = getScale(x_data, settings);
			if (opts.domain_only) return xScale;

			const x_width = instance.plot_width;
			const left_margin = instance.margins.left;
			const { left, right } = getXPadding(instance, x, xScale.domain());
			const effective_width = x_width - (left + right);
			const range_start = left_margin + left;
			let range = [ range_start, range_start + effective_width ];
			const offset = opts.global && instance.offsetLeft();
			if (offset) range = range.map(function(x) { return x + offset; });

			return xScale.range(range);
		};
	}


	function initXMinStep(instance) {
		return function() {
			return minStep(instance.xData(), instance.xScale());
		};
	}

	function initYPadding(instance) {
		const UNITS = [ "px", "steps" ];
		let bottom = 0;
		let top = 0;
		let unit = "px";

		return function(values) {
			if (values === undefined) return { bottom, top, unit };
			const u = values.unit;
			if (u && !UNITS.includes(u)) throw new Error(`Unit "${u}" not recognised`);
			({ bottom = bottom, top = top, unit = unit } = values);
			return instance;
		};
	}


	function getYPadding(instance, y_state, domain) {
		const no_padding = { bottom: 0, top: 0 };
		const y_data = instance.yData();
		// Ignore developer-set padding on categorical axes because of user-set padding
		if (y_data.string_array) return no_padding;

		const { bottom, top, unit } = instance.yPadding();

		// Ignore developer-set padding on logarithmic axes if not in px
		if (y_data.numeric_array && y_state.numeric_scale_type !== "linear" && unit !== "px") return no_padding;

		if (unit === "px" || (!bottom && !top)) return { bottom, top };

		const unique_values = y_data.uniqueAscending();
		const n = unique_values.length;
		if (n < 2) return no_padding;

		let min_data_step = Infinity;
		for (let i = 1; i < n; i++) {
			const step = Math.abs(unique_values[i] - unique_values[i-1]);
			min_data_step = Math.min(min_data_step, step);
		}

		const domain_width = Math.max(...domain) - Math.min(...domain); // in domain units
		const full_width = domain_width + ((bottom + top) * min_data_step); // in domain units
		const n_min_steps = full_width / min_data_step;
		const step_width = instance.plot_height / n_min_steps; // in pixels

		return { bottom: bottom * step_width, top: top * step_width };
	}


	function initYScale(instance, state) {
		const y = state.y;

		return function(opts = {}) {
			var y_data = instance.yData();

			const settings = { nice: y.nice, flip: instance.yFlipAxis() !== y.flip };
			let getScale;
			if (y_data.string_array) {
				getScale = getPointScale;
				settings.edge_padding = y.edge_padding;
			}
			else if (y_data.datetime_array) {
				getScale = getDatetimeScale;
				settings.min = y.datetime_min;
				settings.max = y.datetime_max;
				settings.format = instance.yDatetimeParse();
			}
			else if (y.numeric_scale_type === "log") {
				getScale = getLogScale;
				settings.min = y.log_min;
				settings.max = y.log_max;
			}
			else {
				getScale = getLinearScale;
				settings.min = y.linear_min;
				settings.max = y.linear_max;
				settings.include_zero = y.zero_axis === "off" ? false : (y.zero_axis === "on" ? true : instance.yZeroAxis());
			}

			const yScale = getScale(y_data, settings);
			if (opts.domain_only) return yScale;

			const y_height = instance.plot_height;
			const top_margin = instance.margins.top;
			const { bottom, top } = getYPadding(instance, y, yScale.domain());
			const effective_height = y_height - (bottom + top);
			const offset = opts.global && instance.offsetTop();
			const range_start = top_margin + top;
			let range = [ range_start + effective_height, range_start ];
			if (offset) range = range.map(function(y) { return y + offset; });

			return yScale.range(range);
		};
	}


	function initYMinStep(instance) {
		return function() {
			return minStep(instance.yData(), instance.yScale());
		};
	}

	function initY2Padding(instance) {
		const UNITS = [ "px", "steps" ];
		let bottom = 0;
		let top = 0;
		let unit = "px";

		return function(values) {
			if (values === undefined) return { bottom, top, unit };
			const u = values.unit;
			if (u && !UNITS.includes(u)) throw new Error(`Unit "${u}" not recognised`);
			({ bottom = bottom, top = top, unit = unit } = values);
			return instance;
		};
	}


	function getY2Padding(instance, y2_state, domain) {
		const no_padding = { bottom: 0, top: 0 };
		const y2_data = instance.y2Data();
		// Ignore developer-set padding on categorical axes because of user-set padding
		if (y2_data.string_array) return no_padding;

		const { bottom, top, unit } = instance.y2Padding();

		// Ignore developer-set padding on logarithmic axes if not in px
		if (y2_data.numeric_array && y2_state.numeric_scale_type !== "linear" && unit !== "px") return no_padding;

		if (unit === "px" || (!bottom && !top)) return { bottom, top };

		const unique_values = y2_data.uniqueAscending();
		const n = unique_values.length;
		if (n < 2) return no_padding;

		let min_data_step = Infinity;
		for (let i = 1; i < n; i++) {
			const step = Math.abs(unique_values[i] - unique_values[i-1]);
			min_data_step = Math.min(min_data_step, step);
		}

		const domain_width = Math.max(...domain) - Math.min(...domain); // in domain units
		const full_width = domain_width + ((bottom + top) * min_data_step); // in domain units
		const n_min_steps = full_width / min_data_step;
		const step_width = instance.plot_width / n_min_steps; // in pixels

		return { bottom: bottom * step_width, top: top * step_width };
	}


	function initY2Scale(instance, state) {
		const y2 = state.y2;

		return function(opts = {}) {
			var y2_data = instance.y2Data();

			const settings = { nice: y2.nice, flip: instance.y2FlipAxis() !== y2.flip };
			let getScale;
			if (y2_data.string_array) {
				getScale = getPointScale;
				settings.edge_padding = y2.edge_padding;
			}
			else if (y2_data.datetime_array) {
				getScale = getDatetimeScale;
				settings.min = y2.datetime_min;
				settings.max = y2.datetime_max;
				settings.format = instance.y2DatetimeParse();
			}
			else if (y2.numeric_scale_type === "log") {
				getScale = getLogScale;
				settings.min = y2.log_min;
				settings.max = y2.log_max;
			}
			else {
				getScale = getLinearScale;
				settings.min = y2.linear_min;
				settings.max = y2.linear_max;
				settings.include_zero = y2.zero_axis === "off" ? false : (y2.zero_axis === "on" ? true : instance.y2ZeroAxis());
			}

			const yScale = getScale(y2_data, settings);
			if (opts.domain_only) return yScale;

			const y2_height = instance.plot_height;
			const top_margin = instance.margins.top;
			const { bottom, top } = getY2Padding(instance, y2, yScale.domain());
			const effective_height = y2_height - (bottom + top);
			const offset = opts.global && instance.offsetTop();
			const range_start = top_margin + top;
			let range = [ range_start + effective_height, range_start ];
			if (offset) range = range.map(function(y) { return y + offset; });

			return yScale.range(range);
		};
	}


	function initY2MinStep(instance) {
		return function() {
			return minStep(instance.y2Data(), instance.y2Scale());
		};
	}

	function initZeroAxis(instance) {
		var zero_axis = false;
		return function(value) {
			if (value === undefined) return zero_axis;
			zero_axis = !!value;
			return instance;
		};
	}


	function initFlipAxis(instance) {
		let flip = false;

		return function(value) {
			if (value === undefined) return flip;
			flip = !!value;
			return instance;
		};
	}

	function initHide(instance) {
		var hide = false;
		var keep_gridlines = false;

		return function(value) {
			if (value === undefined) return hide ? {keep_gridlines: keep_gridlines} : false;
			hide = !!value;
			keep_gridlines = (value && typeof value === "object" && value.keep_gridlines) ? true : false;
			return instance;
		};
	}

	function initDebugUpdating(instance) {
		let debug_rect = instance.chart.select("rect.fl-chart-debug-rectangle");

		return function() {
			debug_rect.attr("width", instance.width())
				.attr("height", instance.height())
				.style("stroke", instance.debugColor())
				.style("display", instance.debug() ? null : "none");
		};
	}

	function removeDuplicates(arr) {
		if (!arr.length) return arr.slice();

		// For datetimes we must convert datetime objects to timestamps before removing duplicates
		// Then we must convert timestamps back to date objects
		if (isDate(arr[0])) {
			return Array.from(new Set(arr.map(d => d.getTime()))).map(d => new Date(d));
		}

		return Array.from(new Set(arr));
	}


	function getTickValues(instance, state, axis = "x") {
		const axis_state = state[axis];
		const scale = instance[axis + "Scale"]({ "domain_only": true });
		const data = instance[axis + "Data"]();
		let ticks;
		const ticks_hidden = axis === "x" ? axis_state.axis_position === "off" : !axis_state.axis_visible;

		if (ticks_hidden) ticks = [];
		else if (data.string_array) ticks = scale.domain();
		else if (axis_state.tick_mode === "number") ticks = scale.ticks(axis_state.tick_number);
		else {
			let tick_list;
			const is_datetime = data.datetime_array;
			if (axis_state.tick_mode === "custom") {
				const parser_name = axis + (is_datetime ? "Datetime" : "Number") + "Parse";
				const parser = instance[parser_name]();
				tick_list = textareaToArray(axis_state.tick_custom).map(d => parser(d));
			}
			else {
				const auto = instance[axis + "AutoTicks"]();
				tick_list = Array.isArray(auto) ? auto : auto();
			}
			tick_list = removeDuplicates(tick_list);
			const domain = scale.domain();
			const min = Math.min(...domain);
			const max = Math.max(...domain);
			if (is_datetime) ticks = tick_list.filter(d => isValidDate$1(d) && d >= min && d <= max);
			else ticks = tick_list.filter(d => !isNaN(d) && d >= min && d <= max);
		}

		return ticks;
	}


	function initTickUpdating(instance, state) {
		var updateXTicks = function() {
			instance.xTicks._update(getTickValues(instance, state, "x"));
		};

		var updateYTicks = function() {
			instance.yTicks._update(getTickValues(instance, state, "y"));
		};

		var updateY2Ticks = function() {
			instance.y2Ticks._update(getTickValues(instance, state, "y2"));
		};

		return function() {
			updateXTicks();
			updateYTicks();
			updateY2Ticks();
		};
	}

	function initClipUpdating(instance, state) {
		var clip_path = instance.chart.select("clipPath.fl-data-clip-path");
		var clip_rect = clip_path.select("rect");
		var clip_path_grid = instance.chart.select("clipPath.fl-grid-clip-path");
		var clip_rect_grid = clip_path_grid.select("rect");
		var data_background = instance.chart.select(".fl-data-background");
		var data_foreground = instance.chart.select(".fl-data-foreground");
		var gridlines = instance.chart.select(".fl-gridlines");

		return function() {
			var id = instance.identifier() + "-clip-path";
			var clip_attr = "url(#" + id + ")";
			clip_path.attr("id", id);
			var id_grid = instance.identifier() + "-grid-clip-path";
			var clip_attr_grid = "url(#" + id_grid + ")";
			clip_path_grid.attr("id", id_grid);

			data_background.attr("clip-path", clip_attr);
			data_foreground.attr("clip-path", clip_attr);
			gridlines.attr("clip-path", clip_attr_grid);

			var x_left = instance.x_left;
			var x_right = instance.x_right;
			var y_top = instance.y_top;
			var y_bottom = instance.y_bottom;

			var clip = instance.clip();
			var x = clip.left ? x_left : 0;
			var y = clip.top ? y_top : 0;
			var width = Math.max((clip.right ? x_right : instance.width()) - x, 1);
			var height = Math.max((clip.bottom ? y_bottom : instance.height()) - y, 1);

			clip_rect
				.attr("x", x)
				.attr("y", y)
				.attr("width", width)
				.attr("height", height);

			var lr_padding = remToPx(state.x.gridline_width, true);
			var tb_padding = remToPx(state.y.gridline_width, true);

			clip_rect_grid
				.transition()
				.duration(instance.animationDuration())
				.attr("x", x_left - lr_padding)
				.attr("y", y_top - tb_padding)
				.attr("width", (x_right - x_left) + (2 * lr_padding))
				.attr("height", (y_bottom - y_top) + (2 * tb_padding));
		};
	}

	function initBackgroundUpdating(instance, state) {
		var bg = state.background;
		var fill = instance.chart.select("rect.fl-chart-fill");
		var image = instance.chart.select("image.fl-chart-image");
		var rect = instance.chart.select("rect.fl-chart-interaction");

		return function() {
			var x_range = instance.xScale().range();
			var y_range = instance.yScale().range();

			var x = x_range[0];
			var y = y_range[1];
			var width = Math.max(instance.plot_width, 1);
			var height = Math.max(instance.plot_height, 1);

			fill
				.attr("x", x)
				.attr("y", y)
				.attr("width", width)
				.attr("height", height)
				.attr("fill", bg.background_color_enabled ? bg.background_color : "none");
			image
				.attr("x", x)
				.attr("y", y)
				.attr("width", width)
				.attr("height", height)
				.attr("xlink:href", bg.background_image_enabled ? bg.background_image_src : null)
				.attr("preserveAspectRatio", function() {
					if (bg.background_image_size == "stretch") return "none";
					return bg.background_image_position + " " + bg.background_image_size;
				});
			rect
				.attr("x", x)
				.attr("y", y)
				.attr("width", width)
				.attr("height", height);
		};
	}

	function tickSorter(a, b) {
		// Make the numbers with the fewest significant digits come first
		var diff = a.significant_digits - b.significant_digits;
		if (diff) return diff;
		// Then the numbers with the greatest exponent
		diff = b.exponent - a.exponent;
		if (diff) return diff;
		// Then the number with the largest absolute value
		diff = Math.abs(b.value) - Math.abs(a.value);
		if (diff) return diff;
		// Then, finally, favour the largest number
		diff = b.value - a.value;
		return diff;
	}

	function userSelectNone(selection) {
		selection
			.style("user-select", "none")
			.style("-moz-user-select", "none")
			.style("-webkit-user-select", "none")
			.style("-ms-user-select", "none")
			.style("cursor", "default");
	}

	function getDirectionAttribute() {
		return document.body.getAttribute("dir");
	}

	function initXAxisUpdating(instance, state) {
		var x = state.x;
		var xScale, yScale, animation_duration;
		var line_color, line_width, tick_label_color;
		var tick_length, tick_label_size, tick_label_distance;
		var title_size, title_text;
		var x_left, x_mid, x_right, x_left_old, x_right_old;
		var oldXScale, enteringXScale, exitingXScale, oldYScale;

		function setValues() {
			xScale = safeScale(instance.xScale());
			yScale = safeScale(instance.yScale());
			animation_duration = oldXScale ? instance.animationDuration() : 0;
			x_left = instance.x_left;
			x_right = instance.x_right;
			x_mid = (x_left + x_right) / 2;
			if (x_left_old === undefined) x_left_old = x_left;
			if (!oldXScale) oldXScale = xScale;
			enteringXScale = oldXScale.type === xScale.type && xScale.type !== "ordinal" ? oldXScale : xScale;
			exitingXScale = oldXScale.type === xScale.type && oldXScale.type !== "ordinal" ? xScale : oldXScale;
			line_color = x.line_and_tick_color;
			line_width = remToPx(x.line_and_tick_width, true);
			tick_label_color = x.tick_label_color;

			var ticks_labels_below = x.tick_label_position === "default";
			var x_ticks = instance.xTicks();
			var axis_height = x_ticks.max_box_height;
			var tick_padding = x_ticks.length ? remToPx(x.tick_padding) : 0;
			if (x.axis_position == "top" || x.axis_position == "bottom") axis_height += tick_padding;
			var ticks_out = x.tick_side === "out";
			tick_length = ticks_labels_below ? (remToPx(x.tick_length) * (ticks_out ? 1 : -1)) : axis_height;
			tick_label_size = remToPx(x.tick_label_size);
			tick_label_distance = (ticks_out && ticks_labels_below ? tick_length : 0) + tick_padding;
			title_size = remToPx(x.title_size);
			title_text = instance.xTitle();
		}

		var updateBottomAxis = (function() {
			var bottom = instance.chart.select("g.fl-bottom-axis");
			var line_container = bottom.select("g.fl-axis-line");
			var tick_container = bottom.select("g.fl-axis-ticks");
			var title_container = bottom.select("g.fl-axis-title");
			var y_bottom_old;

			return function() {
				var pos = x.axis_position;
				var measurements = { pos: pos };
				var show_this_axis = (!instance.xHide() && ["bottom", "float-below"].indexOf(pos) !== -1);
				var ticks = show_this_axis ? instance.xTicks() : [];
				var y_bottom = instance.y_bottom;
				if (y_bottom_old === undefined) y_bottom_old = y_bottom;
				var title_distance = y_bottom + remToPx(x.title_padding);
				if (pos === "bottom") {
					title_distance += tick_label_distance + ticks.max_box_height;
					measurements.extended_gridline = y_bottom + tick_label_distance + ticks.max_box_height;
				}

				function getAxisPosition(value, fallback) {
					if (value === undefined || isNaN(value)) return fallback;
					return value;
				}

				var axis_y_position_old = y_bottom_old;
				var axis_y_position = y_bottom;
				if (pos === "float-below") {
					axis_y_position_old = getAxisPosition((oldYScale || yScale)(x.y_axis_position), y_bottom_old);
					axis_y_position = getAxisPosition(yScale(x.y_axis_position), y_bottom);
				}

				var line = line_container.selectAll("line")
					.data(show_this_axis && x.line_visible ? [xScale.domain()] : []);

				line.exit()
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("x1", x_left)
					.attr("x2", x_right)
					.attr("y1", axis_y_position)
					.attr("y2", axis_y_position)
					.style("opacity", 0)
					.remove();

				var line_enter = line.enter()
					.append("line")
					.style("shape-rendering", "crispEdges")
					.style("stroke-linecap", "square")
					.style("stroke-width", line_width)
					.attr("x1", x_left_old)
					.attr("x2", x_right_old)
					.attr("y1", axis_y_position_old)
					.attr("y2", axis_y_position_old)
					.style("opacity", 0);

				line.merge(line_enter)
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("x1", x_left)
					.attr("x2", x_right)
					.attr("y1", axis_y_position)
					.attr("y2", axis_y_position)
					.style("opacity", 1);

				var sorted_ticks = show_this_axis ? ticks : [];
				if (ticks.type === "numeric" && x.tick_mode !== "custom") {
					sorted_ticks = ticks.slice().sort(tickSorter);
				}

				var tickLabelTransform = function(d) {
					var angle = x.tick_label_position == "default" ? -x.tick_label_angle : -90;
					var rotate = angleToRotate(angle, 0, 0);
					if (x.tick_label_position !== "default") {
						var y_offset = x.tick_label_position === "left" ? -0.3 : 1;
						return xyToTranslate(0, tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size * y_offset);
					}
					if (angle === 0) {
						return xyToTranslate(d.text_width/2, tick_label_distance + tick_label_size*0.66);
					}
					else if (angle === -90) {
						return xyToTranslate(0, tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size*0.33 - d.multiline_offset);
					}
					else {
						return xyToTranslate(0, tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size*0.66);
					}
				};

				var tick_g = tick_container.selectAll("g")
					.data(sorted_ticks, function(d) { return d.type + "-" + d.value; });

				var tick_g_exit = tick_g.exit();

				tick_g_exit.transition()
					.duration(animation_duration)
					.attr("transform", function(d) { return xyToTranslate(exitingXScale(d.value), axis_y_position); })
					.style("opacity", 0)
					.remove();

				tick_g_exit.each(function() {
					var sel = select(this);
					// Tick lines
					sel.select("line")
						.style("stroke", line_color)
						.style("stroke-width", line_width)
						.transition()
						.duration(animation_duration)
						.attr("y2", tick_length);
					// Tick labels
					sel.select("text")
						.style("fill", tick_label_color)
						.style("font-size", tick_label_size + "px")
						.style("font-weight", x.tick_label_weight)
						.attr("transform", tickLabelTransform)
						.transition()
						.duration(animation_duration);
				});

				var tick_g_enter = tick_g.enter().append("g")
					.style("opacity", 0);

				tick_g_enter
					.attr("transform", function(d) { return xyToTranslate(enteringXScale(d.value), axis_y_position_old); });

				tick_g_enter.each(function() {
					var sel = select(this);
					// Tick lines
					sel.append("line")
						.attr("y2", tick_length);
					// Tick labels
					sel.append("text").attr("text-anchor", "middle")
						.attr("transform", tickLabelTransform)
						.call(userSelectNone);
				});

				var tick_g_update = tick_g.merge(tick_g_enter);

				tick_g_update.transition()
					.duration(animation_duration)
					.style("opacity", 1)
					.attr("transform", function(d) { return xyToTranslate(xScale(d.value), axis_y_position); });

				var setTickOpacity = (function() {
					var placed_ticks = [];
					var y_anchor = axis_y_position + tick_label_distance;
					return function(d) {
						var x_anchor = xScale(d.value);
						if (pos === "float-below") {
							var range = xScale.range();
							if (state.y.axis_visible) {
								var left = x_anchor - d.box_width_left;
								if (left < range[0]) return 0;
							}
							if (state.y2.axis_visible) {
								var right = x_anchor + d.box_width_right;
								if (right > range[1]) return 0;
							}
						}
						var p1q1 = [ x_anchor, y_anchor ];
						var p2 = [ x_anchor + d.box_width_right, y_anchor + d.box_height_right];
						var q2 = [ x_anchor - d.box_width_left, y_anchor + d.box_height_left];
						var p = [ p1q1, p2 ];
						var q = [ p1q1, q2 ];
						for (var i = 0; i < placed_ticks.length; i++) {
							var placed_tick = placed_ticks[i];
							if (x_anchor <= placed_tick.x_anchor) {
								if (linesIntersect(p, placed_tick.q)) return 0;
							}
							else {
								if (linesIntersect(placed_tick.p, q)) return 0; // eslint-disable-line no-lonely-if
							}
						}
						placed_ticks.push({ x_anchor: x_anchor, p: p, q: q });
						return 1;
					};
				})();
				const read_direction = getDirectionAttribute();

				tick_g_update.each(function() {
					var sel = select(this);
					// Tick lines
					sel.select("line")
						.style("stroke", line_color)
						.style("stroke-width", line_width)
						.transition()
						.duration(animation_duration)
						.attr("y2", tick_length);
					// Tick labels
					sel.select("text")
						.each(function() {
							var tspans = select(this).selectAll("tspan").data(function(d) { return d.lines; });
							tspans.merge(tspans.enter().append("tspan"))
								.attr("x", 0)
								.attr("dy", function(d, i) { return i ? x.tick_label_line_height + "em" : 0; })
								.text(function(d) { return d; });
							tspans.exit().remove();
						})
						.attr("text-anchor", read_direction === "rtl" ? "start" : "end")
						.style("fill", tick_label_color)
						.style("font-size", tick_label_size + "px")
						.style("font-weight", x.tick_label_weight)
						.transition()
						.duration(animation_duration)
						.style("opacity", setTickOpacity)
						.attr("transform", tickLabelTransform);
				});

				var title = title_container.selectAll("text")
					.data(show_this_axis && title_text ? [title_text] : []);

				title.exit().remove();

				title.enter().append("text")
					.attr("text-anchor", "middle")
					.style("font-size", title_size + "px")
					.style("fill", x.title_color)
					.style("font-weight", x.title_weight)
					.call(userSelectNone)
					.transition()
					.duration(0)
					.delay(animation_duration)
					.text(function(d) { return d; })
					.attr("x", x_mid)
					.attr("y", title_distance)
					.attr("dy", title_size);

				title.text(function(d) { return d; })
					.style("fill", x.title_color)
					.style("font-size", title_size + "px")
					.style("font-weight", x.title_weight)
					.transition()
					.duration(animation_duration)
					.attr("x", x_mid)
					.attr("y", title_distance)
					.attr("dy", title_size);

				y_bottom_old = y_bottom;

				return pos == "bottom" ? measurements : null;
			};
		})();

		var updateTopAxis = (function() {
			var top = instance.chart.select("g.fl-top-axis");
			var line_container = top.select("g.fl-axis-line");
			var tick_container = top.select("g.fl-axis-ticks");
			var title_container = top.select("g.fl-axis-title");
			var y_top_old;

			return function() {
				var pos = x.axis_position;
				var measurements = { pos: pos };
				var show_this_axis = (!instance.xHide() && ["top", "float-above"].indexOf(pos) !== -1);
				var ticks = show_this_axis ? instance.xTicks() : [];
				var y_top = instance.y_top;
				if (y_top_old === undefined) y_top_old = y_top;
				var title_distance = y_top - remToPx(x.title_padding);
				if (pos === "top") {
					title_distance -= tick_label_distance + ticks.max_box_height;
					measurements.extended_gridline = y_top - (tick_label_distance + ticks.max_box_height);
				}

				var axis_y_position_old = pos === "float-above" ? (oldYScale || yScale)(x.y_axis_position) : y_top_old;
				var axis_y_position = pos === "float-above" ? yScale(x.y_axis_position) : y_top;

				var line = line_container.selectAll("line")
					.data(show_this_axis && x.line_visible ? [xScale.domain()] : []);

				line.exit()
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("x1", x_left)
					.attr("x2", x_right)
					.attr("y1", axis_y_position)
					.attr("y2", axis_y_position)
					.style("opacity", 0)
					.remove();

				var line_enter = line.enter()
					.append("line")
					.style("shape-rendering", "crispEdges")
					.style("stroke-linecap", "square")
					.style("stroke-width", line_width)
					.attr("x1", x_left_old)
					.attr("x2", x_left_old)
					.attr("y1", axis_y_position_old)
					.attr("y2", axis_y_position_old)
					.style("opacity", 0);

				line.merge(line_enter)
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("x1", x_left)
					.attr("x2", x_right)
					.attr("y1", axis_y_position)
					.attr("y2", axis_y_position)
					.style("opacity", 1);

				var sorted_ticks = [];
				if (show_this_axis) {
					sorted_ticks = ticks.type === "numeric" ? ticks.slice().sort(tickSorter) : ticks;
				}

				var tickLabelTransform = function(d) {
					var angle = x.tick_label_position == "default" ? -x.tick_label_angle : -90;
					var rotate = angleToRotate(angle, 0, 0);
					if (x.tick_label_position !== "default") {
						var y_offset = x.tick_label_position === "left" ? -0.3 : 1;
						return xyToTranslate(0, -tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size * y_offset);
					}
					if (angle === 0) {
						return xyToTranslate(-d.text_width/2, -(tick_label_distance + tick_label_size*0.33));
					}
					else if (angle === -90) {
						return xyToTranslate(0, -tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size*0.33 - d.multiline_offset);
					}
					else {
						return xyToTranslate(0, -tick_label_distance) + " " + rotate + xyToTranslate(0, -d.multiline_offset); // + " " + xyToTranslate(0, tick_label_size*0.66);
					}
				};

				var tick_g = tick_container.selectAll("g")
					.data(sorted_ticks, function(d) { return d.type + "-" + d.value; });

				var tick_g_exit = tick_g.exit();

				tick_g_exit.transition()
					.duration(animation_duration)
					.attr("transform", function(d) { return xyToTranslate(exitingXScale(d.value), axis_y_position); })
					.style("opacity", 0)
					.remove();

				tick_g_exit.each(function() {
					var sel = select(this);
					// Tick lines
					sel.select("line")
						.style("stroke", line_color)
						.style("stroke-width", line_width)
						.transition()
						.duration(animation_duration)
						.attr("y2", -tick_length);
					// Tick labels
					sel.select("text")
						.style("fill", tick_label_color)
						.style("font-size", tick_label_size + "px")
						.style("font-weight", x.tick_label_weight)
						.attr("transform", tickLabelTransform)
						.transition()
						.duration(animation_duration);
				});

				var tick_g_enter = tick_g.enter().append("g")
					.style("opacity", 0);

				tick_g_enter
					.attr("transform", function(d) { return xyToTranslate(enteringXScale(d.value), axis_y_position_old); });

				tick_g_enter.each(function() {
					var sel = select(this);
					// Tick lines
					sel.append("line")
						.attr("y2", -tick_length);
					// Tick labels
					sel.append("text").attr("text-anchor", "middle")
						.attr("transform", tickLabelTransform)
						.call(userSelectNone);
				});

				var tick_g_update = tick_g.merge(tick_g_enter);

				tick_g_update.transition()
					.duration(animation_duration)
					.style("opacity", 1)
					.attr("transform", function(d) { return xyToTranslate(xScale(d.value), axis_y_position); });

				var setTickOpacity = (function() {
					var placed_ticks = [];
					var y_anchor = axis_y_position + tick_label_distance;
					return function(d) {
						var x_anchor = xScale(d.value);
						if (pos === "float-above") {
							var range = xScale.range();
							if (state.y.axis_visible) {
								var left = x_anchor - d.box_width_left;
								if (left < range[0]) return 0;
							}
							if (state.y2.axis_visible) {
								var right = x_anchor + d.box_width_right;
								if (right > range[1]) return 0;
							}
						}
						var p1q1 = [ x_anchor, y_anchor ];
						var p2 = [ x_anchor - d.box_width_left, y_anchor - d.box_height_left];
						var q2 = [ x_anchor + d.box_width_right, y_anchor - d.box_height_right];
						var p = [ p1q1, p2 ];
						var q = [ p1q1, q2 ];
						for (var i = 0; i < placed_ticks.length; i++) {
							var placed_tick = placed_ticks[i];
							if (x_anchor <= placed_tick.x_anchor) {
								if (linesIntersect(q, placed_tick.p)) return 0;
							}
							else {
								if (linesIntersect(p, placed_tick.q)) return 0; // eslint-disable-line no-lonely-if
							}
						}
						placed_ticks.push({ x_anchor: x_anchor, p: p, q: q });
						return 1;
					};
				})();
				const read_direction = getDirectionAttribute();

				tick_g_update.each(function() {
					var sel = select(this);
					// Tick lines
					sel.select("line")
						.style("stroke", line_color)
						.style("stroke-width", line_width)
						.transition()
						.duration(animation_duration)
						.attr("y2", -tick_length);
					// Tick labels
					sel.select("text")
						.each(function() {
							var tspans = select(this).selectAll("tspan").data(function(d) { return d.lines; });
							tspans.merge(tspans.enter().append("tspan"))
								.attr("x", 0)
								.attr("dy", function(d, i) { return i ? x.tick_label_line_height + "em" : 0; })
								.text(function(d) { return d; });
							tspans.exit().remove();
						})
						.attr("text-anchor", read_direction === "rtl" ? "end" : "start")
						.style("fill", tick_label_color)
						.style("font-size", tick_label_size + "px")
						.style("font-weight", x.tick_label_weight)
						.transition()
						.duration(animation_duration)
						.style("opacity", setTickOpacity)
						.attr("transform", tickLabelTransform);
				});

				var title = title_container.selectAll("text")
					.data(show_this_axis && title_text ? [title_text] : []);

				title.exit().remove();

				title.enter().append("text")
					.attr("text-anchor", "middle")
					.style("font-size", title_size + "px")
					.style("fill", x.title_color)
					.style("font-weight", x.title_weight)
					.call(userSelectNone)
					.transition()
					.duration(0)
					.delay(animation_duration)
					.text(function(d) { return d; })
					.attr("x", x_mid)
					.attr("y", title_distance)
					.attr("dy", -0.33 * title_size);

				title.text(function(d) { return d; })
					.style("fill", x.title_color)
					.style("font-size", title_size + "px")
					.style("font-weight", x.title_weight)
					.transition()
					.duration(animation_duration)
					.attr("x", x_mid)
					.attr("y", title_distance)
					.attr("dy", -0.33 * title_size);

				y_top_old = y_top;

				return pos == "top" ? measurements : null;
			};
		})();

		return function() {
			setValues();
			var bottom = updateBottomAxis();
			var top = updateTopAxis();
			oldXScale = xScale;
			oldYScale = yScale;
			x_left_old = x_left;
			x_right_old = x_right;
			return bottom || top;
		};
	}

	function initYAxisUpdating(instance, state) {
		var left = instance.chart.select("g.fl-left-axis");
		var line_container = left.select("g.fl-axis-line");
		var tick_container = left.select("g.fl-axis-ticks");
		var title_container = left.select("g.fl-axis-title");
		var y = state.y;
		var oldXScale;
		var oldYScale;
		var y_bottom_old, y_top_old;
		var x_left_old;

		return function() {
			var measurements = {};
			var show_this_axis = y.axis_visible && !instance.yHide();
			var xScale = safeScale(instance.xScale());
			var yScale = safeScale(instance.yScale());
			var ticks = show_this_axis ? instance.yTicks() : [];
			var animation_duration = oldXScale ? instance.animationDuration() : 0;
			if (!oldXScale) oldXScale = xScale;
			if (!oldYScale) oldYScale = yScale;
			var enteringYScale = oldYScale.type === yScale.type && yScale.type !== "ordinal" ? oldYScale : yScale;
			var exitingYScale = oldYScale.type === yScale.type && oldYScale.type !== "ordinal" ? yScale : oldYScale;
			var y_bottom = instance.y_bottom;
			var y_top = instance.y_top;
			if (y_bottom_old === undefined) y_bottom_old = y_bottom;
			if (y_top_old === undefined) y_top_old = y_top;
			var x_left = instance.x_left;
			if (x_left_old === undefined) x_left_old = x_left;

			var line_color = y.line_and_tick_color;
			var line_width = remToPx(y.line_and_tick_width, true);
			var tick_label_color = y.tick_label_color;

			var ticks_labels_side = y.tick_label_position === "default";
			var ticks_out = y.tick_side === "out";

			var tick_padding = remToPx(y.tick_padding);
			var axis_width = instance.yTicks().max_box_width + tick_padding;
			var tick_length = ticks_labels_side ? (remToPx(y.tick_length) * (ticks_out ? 1 : -1)) : axis_width;
			var tick_label_size = remToPx(y.tick_label_size);
			var tick_label_distance = (ticks_out && ticks_labels_side ? tick_length : 0) + tick_padding;

			var title_text = instance.yTitle();
			var title_size = remToPx(y.title_size);
			var title_distance = tick_label_distance + ticks.max_box_width + remToPx(y.title_padding) + 0.33 * title_size;
			measurements.extended_gridline = x_left - (tick_label_distance + ticks.max_box_width);

			var y_mid = (y_top + y_bottom) / 2;

			var line = line_container.selectAll("line")
				.data(show_this_axis && y.line_visible ? [yScale.domain()] : []);

			line.exit()
				.style("stroke", line_color)
				.style("stroke-width", line_width)
				.transition()
				.duration(animation_duration)
				.attr("x1", x_left)
				.attr("x2", x_left)
				.attr("y1", y_bottom)
				.attr("y2", y_top)
				.style("opacity", 0)
				.remove();

			var line_enter = line.enter()
				.append("line")
				.style("shape-rendering", "crispEdges")
				.style("stroke-linecap", "square")
				.style("stroke-width", line_width)
				.attr("x1", x_left_old)
				.attr("x2", x_left_old)
				.attr("y1", y_bottom_old)
				.attr("y2", y_top_old)
				.style("opacity", 0);

			line.merge(line_enter)
				.style("stroke", line_color)
				.style("stroke-width", line_width)
				.transition()
				.duration(animation_duration)
				.attr("x1", x_left)
				.attr("x2", x_left)
				.attr("y1", y_bottom)
				.attr("y2", y_top)
				.style("opacity", 1);

			var sorted_ticks = show_this_axis ? ticks : [];
			if (ticks.type === "numeric" && y.tick_mode !== "custom") {
				sorted_ticks = ticks.slice().sort(tickSorter);
			}

			function tickLabelTransform(d) {
				if (y.tick_label_position !== "default") {
					var x_offset = -tick_label_distance - (ticks.max_box_width - d.box_width);
					var y_offset = y.tick_label_position === "above" ? -0.3 : 1;
					return xyToTranslate(x_offset, y_offset*tick_label_size);
				}
				var angle = -y.tick_label_angle;
				if (angle === 0) {
					return xyToTranslate(-tick_label_distance, 0.33*tick_label_size - d.multiline_offset);
				}
				var transform = xyToTranslate(-tick_label_distance, 0) + " " + angleToRotate(angle);
				if (angle === -90) transform += " " + xyToTranslate(d.text_width/2, 0);
				return transform;
			}

			var tick_g = tick_container.selectAll("g")
				.data(sorted_ticks, function(d) { return d.type + "-" + d.value; });

			var tick_g_exit = tick_g.exit();

			tick_g_exit.transition()
				.duration(animation_duration)
				.attr("transform", function(d) { return xyToTranslate(x_left, exitingYScale(d.value)); })
				.style("opacity", 0)
				.remove();

			tick_g_exit.each(function() {
				var sel = select(this);
				// Tick lines
				sel.select("line")
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("x2", -tick_length);
				// Tick labels
				sel.select("text")
					.style("fill", tick_label_color)
					.style("font-size", tick_label_size + "px")
					.style("font-weight", y.tick_label_weight)
					.attr("transform", tickLabelTransform)
					.transition()
					.duration(animation_duration);
			});

			var tick_g_enter = tick_g.enter().append("g")
				.style("opacity", 0);

			tick_g_enter
				.attr("transform", function(d) { return xyToTranslate(x_left_old, enteringYScale(d.value)); });

			const read_direction = getDirectionAttribute();
			const text_anchor = read_direction === "rtl" ? "start" : "end";

			tick_g_enter.each(function() {
				var sel = select(this);
				// Tick lines
				sel.append("line")
					.attr("x2", -tick_length);
				// Tick labels
				sel.append("text")
					.attr("text-anchor", text_anchor)
					.attr("transform", tickLabelTransform)
					.call(userSelectNone);
			});

			var tick_g_update = tick_g.merge(tick_g_enter);

			tick_g_update.transition()
				.duration(animation_duration)
				.style("opacity", 1)
				.attr("transform", function(d) { return xyToTranslate(x_left, yScale(d.value)); });

			var setTickOpacity = (function() {
				var placed_ticks = [];
				var x_anchor = x_left - tick_label_distance;
				return function(d) {
					var y_anchor = yScale(d.value);
					var p1q1 = [ x_anchor, y_anchor ];
					var p2 = [ x_anchor - d.box_width_above, y_anchor - d.box_height_above];
					var q2 = [ x_anchor - d.box_width_below, y_anchor + d.box_height_below];
					var p = [ p1q1, p2 ];
					var q = [ p1q1, q2 ];
					for (var i = 0; i < placed_ticks.length; i++) {
						var placed_tick = placed_ticks[i];
						if (y_anchor >= placed_tick.y_anchor) {
							if (linesIntersect(p, placed_tick.q)) return 0;
						}
						else {
							if (linesIntersect(placed_tick.p, q)) return 0; // eslint-disable-line no-lonely-if
						}
					}
					placed_ticks.push({ y_anchor: y_anchor, p: p, q: q });
					return 1;
				};
			})();

			tick_g_update.each(function() {
				var sel = select(this);
				// Tick lines
				sel.select("line")
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("x2", -tick_length);
				// Tick labels
				sel.select("text")
					.each(function() {
						var tspans = select(this).selectAll("tspan").data(function(d) { return d.lines; });
						tspans.merge(tspans.enter().append("tspan"))
							.attr("x", 0)
							.attr("dy", function(d, i) { return i ? y.tick_label_line_height + "em" : 0; })
							.text(function(d) { return d; });
						tspans.exit().remove();
					})
					.style("fill", tick_label_color)
					.style("font-size", tick_label_size + "px")
					.style("font-weight", y.tick_label_weight)
					.attr("text-anchor", text_anchor)
					.transition()
					.duration(animation_duration)
					.style("opacity", setTickOpacity)
					.attr("transform", tickLabelTransform);
			});

			var title = title_container.selectAll("text")
				.data(show_this_axis && title_text ? [title_text] : []);

			title.exit().remove();

			var getTitleTransform = function() {
				return xyToTranslate(x_left, y_mid) + " " + angleToRotate(-90) + " " + xyToTranslate(0, -title_distance);
			};

			title.enter().append("text")
				.attr("text-anchor", "middle")
				.style("font-size", title_size + "px")
				.style("fill", y.title_color)
				.style("font-weight", y.title_weight)
				.call(userSelectNone)
				.transition()
				.duration(0)
				.delay(animation_duration)
				.text(function(d) { return d; })
				.attr("x", 0)
				.attr("y", 0)
				.attr("transform", getTitleTransform);

			title.text(function(d) { return d; })
				.style("fill", y.title_color)
				.style("font-size", title_size + "px")
				.style("font-weight", y.title_weight)
				.transition()
				.duration(animation_duration)
				.attr("x", 0)
				.attr("y", 0)
				.attr("transform", getTitleTransform);

			oldXScale = xScale;
			oldYScale = yScale;
			y_bottom_old = y_bottom;
			y_top_old = y_top;
			x_left_old = x_left;

			return measurements;
		};
	}

	function initY2AxisUpdating(instance, state) {
		var right = instance.chart.select("g.fl-right-axis");
		var line_container = right.select("g.fl-axis-line");
		var tick_container = right.select("g.fl-axis-ticks");
		var title_container = right.select("g.fl-axis-title");
		var y = state.y2;
		var oldXScale;
		var oldYScale;
		var y_bottom_old, y_top_old;
		var x_right_old;

		return function() {
			var measurements = {};
			var show_this_axis = y.axis_visible && !instance.y2Hide();
			var xScale = safeScale(instance.xScale());
			var yScale = safeScale(instance.y2Scale());
			var ticks = show_this_axis ? instance.y2Ticks() : [];
			var animation_duration = oldXScale ? instance.animationDuration() : 0;
			if (!oldXScale) oldXScale = xScale;
			if (!oldYScale) oldYScale = yScale;
			var enteringYScale = oldYScale.type === yScale.type && yScale.type !== "ordinal" ? oldYScale : yScale;
			var exitingYScale = oldYScale.type === yScale.type && oldYScale.type !== "ordinal" ? yScale : oldYScale;
			var y_bottom = instance.y_bottom;
			var y_top = instance.y_top;
			if (y_bottom_old === undefined) y_bottom_old = y_bottom;
			if (y_top_old === undefined) y_top_old = y_top;
			var x_right = instance.x_right;
			if (x_right_old === undefined) x_right_old = x_right;

			var line_color = y.line_and_tick_color;
			var line_width = remToPx(y.line_and_tick_width, true);
			var tick_label_color = y.tick_label_color;

			var ticks_labels_side = y.tick_label_position === "default";
			var ticks_out = y.tick_side === "out";

			var tick_padding = remToPx(y.tick_padding);
			var axis_width = instance.y2Ticks().max_box_width + tick_padding;
			var tick_length = ticks_labels_side ? (remToPx(y.tick_length) * (ticks_out ? 1 : -1)) : axis_width;
			var tick_label_size = remToPx(y.tick_label_size);
			var tick_label_distance = (ticks_out && ticks_labels_side ? tick_length : 0) + tick_padding;

			var title_text = instance.y2Title();
			var title_size = remToPx(y.title_size);
			var title_distance = tick_label_distance + ticks.max_box_width + remToPx(y.title_padding) + 0.85 * title_size;
			// 0.85 was arrived at by trial and error; we do not fully understand why it is correct
			measurements.extended_gridline = x_right + tick_label_distance + ticks.max_box_width;

			var y_mid = (y_bottom + y_top) / 2;

			var line = line_container.selectAll("line")
				.data(show_this_axis && y.line_visible ? [yScale.domain()] : []);

			line.exit()
				.style("stroke", line_color)
				.style("stroke-width", line_width)
				.transition()
				.duration(animation_duration)
				.attr("x1", x_right)
				.attr("x2", x_right)
				.attr("y1", y_bottom)
				.attr("y2", y_top)
				.style("opacity", 0)
				.remove();

			var line_enter = line.enter()
				.append("line")
				.style("shape-rendering", "crispEdges")
				.style("stroke-linecap", "square")
				.style("stroke-width", line_width)
				.attr("x1", x_right_old)
				.attr("x2", x_right_old)
				.attr("y1", y_bottom_old)
				.attr("y2", y_top_old)
				.style("opacity", 0);

			line.merge(line_enter)
				.style("stroke", line_color)
				.style("stroke-width", line_width)
				.transition()
				.duration(animation_duration)
				.attr("x1", x_right)
				.attr("x2", x_right)
				.attr("y1", y_bottom)
				.attr("y2", y_top)
				.style("opacity", 1);

			var sorted_ticks = ticks.type === "numeric" ? ticks.slice().sort(tickSorter) : ticks;

			function tickLabelTransform(d) {
				if (y.tick_label_position !== "default") {
					var x_offset = tick_label_distance + (ticks.max_box_width - d.box_width);
					var y_offset = y.tick_label_position === "above" ? -0.3 : 1;
					return xyToTranslate(x_offset, y_offset*tick_label_size);
				}
				var angle = -y.tick_label_angle;
				if (angle === 0) {
					return xyToTranslate(tick_label_distance, 0.33*tick_label_size - d.multiline_offset);
				}
				var transform = xyToTranslate(tick_label_distance, 0) + " " + angleToRotate(angle);
				if (angle === -90) transform += " " + xyToTranslate(d.text_width/2, 0);
				return transform;
			}

			var tick_g = tick_container.selectAll("g")
				.data(sorted_ticks, function(d) { return d.type + "-" + d.value; });

			var tick_g_exit = tick_g.exit();

			tick_g_exit.transition()
				.duration(animation_duration)
				.attr("transform", function(d) { return xyToTranslate(x_right, exitingYScale(d.value)); })
				.style("opacity", 0)
				.remove();

			tick_g_exit.each(function() {
				var sel = select(this);
				// Tick lines
				sel.select("line")
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("x2", -tick_length);
				// Tick labels
				sel.select("text")
					.style("fill", tick_label_color)
					.style("font-size", tick_label_size + "px")
					.style("font-weight", y.tick_label_weight)
					.attr("transform", tickLabelTransform)
					.transition()
					.duration(animation_duration);
			});

			var tick_g_enter = tick_g.enter().append("g")
				.style("opacity", 0);

			tick_g_enter
				.attr("transform", function(d) { return xyToTranslate(x_right_old, enteringYScale(d.value)); });

			const read_direction = getDirectionAttribute();


			tick_g_enter.each(function() {
				var sel = select(this);
				// Tick lines
				sel.append("line")
					.attr("x2", tick_length);
				// Tick labels
				sel.append("text")
					.attr("transform", tickLabelTransform)
					.call(userSelectNone);
			});

			var tick_g_update = tick_g.merge(tick_g_enter);

			tick_g_update.transition()
				.duration(animation_duration)
				.style("opacity", 1)
				.attr("transform", function(d) { return xyToTranslate(x_right, yScale(d.value)); })
				.attr("text-anchor", read_direction === "rtl" ? "end" : "start");

			var setTickOpacity = (function() {
				var placed_ticks = [];
				var x_anchor = x_right + tick_label_distance;
				return function(d) {
					var y_anchor = yScale(d.value);
					var p1q1 = [ x_anchor, y_anchor ];
					var p2 = [ x_anchor - d.box_width_above, y_anchor - d.box_height_above];
					var q2 = [ x_anchor - d.box_width_below, y_anchor + d.box_height_below];
					var p = [ p1q1, p2 ];
					var q = [ p1q1, q2 ];
					for (var i = 0; i < placed_ticks.length; i++) {
						var placed_tick = placed_ticks[i];
						if (y_anchor >= placed_tick.y_anchor) {
							if (linesIntersect(p, placed_tick.q)) return 0;
						}
						else {
							if (linesIntersect(placed_tick.p, q)) return 0; // eslint-disable-line no-lonely-if
						}
					}
					placed_ticks.push({ y_anchor: y_anchor, p: p, q: q });
					return 1;
				};
			})();

			tick_g_update.each(function() {
				var sel = select(this);
				// Tick lines
				sel.select("line")
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("x2", tick_length);
				// Tick labels
				sel.select("text")
					.each(function() {
						var tspans = select(this).selectAll("tspan").data(function(d) { return d.lines; });
						tspans.merge(tspans.enter().append("tspan"))
							.attr("x", 0)
							.attr("dy", function(d, i) { return i ? y.tick_label_line_height + "em" : 0; })
							.text(function(d) { return d; });
						tspans.exit().remove();
					})
					.style("fill", tick_label_color)
					.style("font-size", tick_label_size + "px")
					.style("font-weight", y.tick_label_weight)
					.transition()
					.duration(animation_duration)
					.style("opacity", setTickOpacity)
					.attr("transform", tickLabelTransform);
			});

			var title = title_container.selectAll("text")
				.data(show_this_axis && title_text ? [title_text] : []);

			title.exit().remove();

			var getTitleTransform = function() {
				return xyToTranslate(x_right, y_mid) + " " + angleToRotate(-90) + " " + xyToTranslate(0, title_distance);
			};

			title.enter().append("text")
				.attr("text-anchor", "middle")
				.style("font-size", title_size + "px")
				.style("fill", y.title_color)
				.style("font-weight", y.title_weight)
				.call(userSelectNone)
				.transition()
				.duration(0)
				.delay(animation_duration)
				.text(function(d) { return d; })
				.attr("x", 0)
				.attr("y", 0)
				.attr("transform", getTitleTransform);

			title.text(function(d) { return d; })
				.style("fill", y.title_color)
				.style("font-size", title_size + "px")
				.style("font-weight", y.title_weight)
				.transition()
				.duration(animation_duration)
				.attr("x", 0)
				.attr("y", 0)
				.attr("transform", getTitleTransform);

			oldXScale = xScale;
			oldYScale = yScale;
			y_bottom_old = y_bottom;
			y_top_old = y_top;
			x_right_old = x_right;

			return measurements;
		};
	}

	function initAxisUpdating(instance, state) {
		var updateXAxes = initXAxisUpdating(instance, state);
		var updateYAxes = initYAxisUpdating(instance, state);
		var updateY2Axes = initY2AxisUpdating(instance, state);

		return function() {
			var x = updateXAxes();
			var y = updateYAxes();
			var y2 = updateY2Axes();
			return {
				x: x,
				y: y,
				y2: y2
			};
		};
	}

	var DASH_ARRAYS = {
		solid: null,
		dash: [ 4, 1 ],
		dot: [ 1, 1 ],
		dot_dash: [4, 1, 1, 1]
	};


	function getDashArray(style) {
		if (style === "solid") return null;
		var multiplier = remToPx(1) / 4;
		return DASH_ARRAYS[style].map(function(d) { return d * multiplier; }).join(" ");
	}


	function initGridlineUpdating(instance, state) {
		var x = state.x;
		var y = state.y;
		var y2 = state.y2;
		var vertical = instance.chart.select("g.fl-gridlines-vertical");
		var horizontal = instance.chart.select("g.fl-gridlines-horizontal");
		var oldXScale, oldYScale, oldY2Scale;
		var x_left_old, x_right_old, y_bottom_old, y_top_old;

		return function(measurements) {
			var xScale = safeScale(instance.xScale());
			var yScale = safeScale(instance.yScale());
			var y2Scale = safeScale(instance.y2Scale());
			var x_left = instance.x_left;
			var x_right = instance.x_right;
			if (x_left_old === undefined) x_left_old = x_left;
			if (x_right_old === undefined) x_right_old = x_right;
			var y_bottom = instance.y_bottom;
			var y_top = instance.y_top;
			if (y_bottom_old === undefined) y_bottom_old = y_bottom;
			if (y_top_old === undefined) y_top_old = y_top;
			oldXScale = oldXScale || xScale;
			oldYScale = oldYScale || yScale;
			oldY2Scale = oldY2Scale || y2Scale;
			var enteringXScale = oldXScale.type === xScale.type && xScale.type !== "ordinal" ? oldXScale : xScale;
			var exitingXScale = oldXScale.type === xScale.type && oldXScale.type !== "ordinal" ? xScale : oldXScale;
			var enteringYScale = oldYScale.type === yScale.type && yScale.type !== "ordinal" ? oldYScale : yScale;
			var exitingYScale = oldYScale.type === yScale.type && oldYScale.type !== "ordinal" ? yScale : oldYScale;
			var enteringY2Scale = oldY2Scale.type === y2Scale.type && oldY2Scale.type !== "ordinal" ? oldY2Scale : y2Scale;
			var exitingY2Scale = oldY2Scale.type === y2Scale.type && oldY2Scale.type !== "ordinal" ? y2Scale : oldY2Scale;

			var animation_duration = oldXScale ? instance.animationDuration() : 0;

			var getTicksForGridlines = function(axis) {
				// If the user has switched the whole axis off don't return any ticks
				if (axis === "x" && state.x.axis_position === "off") return [];
				else if (axis !== "x" && !state[axis].axis_visible) return [];
				// If the user has switched gridlines off don't return any ticks
				if (!state[axis].gridlines_visible) return [];
				var hide = instance[axis + "Hide"]();
				// If the developer has switched gridlines off don't return any ticks
				if (hide && !hide.keep_gridlines) return [];
				// Else return array of tick objects
				return instance[axis + "Ticks"]();
			};

			var x_ticks = getTicksForGridlines("x");
			var y_ticks = getTicksForGridlines("y");
			var y2_ticks = getTicksForGridlines("y2");

			var v_data = x_ticks.map(function(d) {
				return {
					type: d.type,
					value: d.value,
					dasharray: getDashArray(x.gridline_style),
					stroke: x.gridline_color,
					width: remToPx(x.gridline_width, true),
					x_enter: enteringXScale(d.value),
					x: xScale(d.value),
				};
			});


			if (x.gridline_category_dividers && xScale.step) {
				var x_step = xScale.step();
				v_data.pop();
				v_data.forEach(function(gridline) {
					gridline.x_enter += x_step/2;
					gridline.x += x_step/2;
					if (x.gridline_category_dividers_extend) {
						var extend_top = measurements.x && measurements.x.pos == "top",
						    extend_bottom = measurements.x && measurements.x.pos == "bottom";
						if (extend_top) gridline.y2 = measurements.x.extended_gridline;
						else if (extend_bottom) gridline.y1 = measurements.x.extended_gridline;
					}
				});
			}

			var y_data = y_ticks.map(function(d) {
				return {
					axis: "y",
					type: d.type,
					value: d.value,
					dasharray: getDashArray(y.gridline_style),
					stroke: y.gridline_color,
					width: remToPx(y.gridline_width, true),
					y_enter: enteringYScale(d.value),
					y: yScale(d.value),
				};
			});

			if (y.gridline_category_dividers && yScale.step) {
				var y_step = yScale.step();
				y_data.pop();
				y_data.forEach(function(gridline) {
					gridline.y_enter -= y_step/2;
					gridline.y -= y_step/2;
					if (y.gridline_category_dividers_extend) {
						gridline.x1 = measurements.y.extended_gridline;
					}
				});
			}

			var y2_data = y2_ticks.map(function(d) {
				return {
					axis: "y2",
					type: d.type,
					value: d.value,
					dasharray: getDashArray(y2.gridline_style),
					stroke: y2.gridline_color,
					width: remToPx(y2.gridline_width),
					y_enter: enteringY2Scale(d.value),
					y: y2Scale(d.value),
				};
			});

			if (y2.gridline_category_dividers && y2Scale.step) {
				var y2_step = y2Scale.step();
				y2_data.pop();
				y2_data.forEach(function(gridline) {
					gridline.y_enter -= y2_step/2;
					gridline.y -= y2_step/2;
					if (y2.gridline_category_dividers_extend) {
						gridline.x2 = measurements.y2.extended_gridline;
					}
				});
			}

			var h_data = y_data.concat(y2_data);

			var vertical_lines = vertical.selectAll("line")
				.data(v_data, function(d) { return d.type + "-" + d.value; });

			vertical_lines.exit()
				.attr("stroke-dasharray", function(d) { return d.dasharray; })
				.style("stroke", function(d) { return d.stroke; })
				.style("stroke-width", function(d) { return d.width; })
				.transition()
				.duration(animation_duration)
				.attr("x1", function(d) { return exitingXScale(d.value); })
				.attr("x2", function(d) { return exitingXScale(d.value); })
				.attr("y1", y_bottom)
				.attr("y2", y_top)
				.style("opacity", 0)
				.remove();

			var vertical_lines_enter = vertical_lines.enter().append("line")
				.style("shape-rendering", "crispEdges")
				.attr("x1", function(d) { return d.x_enter; })
				.attr("x2", function(d) { return d.x_enter; })
				.attr("y1", y_bottom_old)
				.attr("y2", y_top_old)
				.style("opacity", 0);

			vertical_lines.merge(vertical_lines_enter)
				.attr("stroke-dasharray", function(d) { return d.dasharray; })
				.style("stroke", function(d) { return d.stroke; })
				.style("stroke-width", function(d) { return d.width; })
				.transition()
				.duration(animation_duration)
				.attr("x1", function(d) { return d.x; })
				.attr("x2", function(d) { return d.x; })
				.attr("y1", y_bottom)
				.attr("y2", y_top)
				.style("opacity", 1);

			var horizontal_lines = horizontal.selectAll("line")
				.data(h_data, function(d) { return d.axis + "-" + d.type + "-" + d.value; });

			horizontal_lines.exit()
				.attr("stroke-dasharray", function(d) { return d.dasharray; })
				.style("stroke", function(d) { return d.stroke; })
				.style("stroke-width", function(d) { return d.width; })
				.transition()
				.duration(animation_duration)
				.attr("x1", x_left)
				.attr("x2", x_right)
				.attr("y1", function(d) { return d.axis === "y" ? exitingYScale(d.value) : exitingY2Scale(d.value); })
				.attr("y2", function(d) { return d.axis === "y" ? exitingYScale(d.value) : exitingY2Scale(d.value); })
				.style("opacity", 0)
				.remove();

			var horizontal_lines_enter = horizontal_lines.enter().append("line")
				.style("shape-rendering", "crispEdges")
				.attr("x1", x_left_old)
				.attr("x2", x_right_old)
				.attr("y1", function(d) { return d.y_enter; })
				.attr("y2", function(d) { return d.y_enter; })
				.style("opacity", 0);

			horizontal_lines.merge(horizontal_lines_enter)
				.attr("stroke-dasharray", function(d) { return d.dasharray; })
				.style("stroke", function(d) { return d.stroke; })
				.style("stroke-width", function(d) { return d.width; })
				.transition()
				.duration(animation_duration)
				.attr("x1", x_left)
				.attr("x2", x_right)
				.attr("y1", function(d) { return d.y; })
				.attr("y2", function(d) { return d.y; })
				.style("opacity", 1);

			oldXScale = xScale;
			oldYScale = yScale;
			oldY2Scale = y2Scale;
			x_left_old = x_left;
			x_right_old = x_right;
		};
	}

	function initUpdate(instance, state) {
		var updateTransform = function() {
			var transform = null;
			if (instance.offsetLeft() || instance.offsetTop()) {
				transform = "translate(" + instance.offsetLeft() + "," + instance.offsetTop() + ")";
			}
			instance.chart.attr("transform", transform);
		};


		var updateDebug = initDebugUpdating(instance);
		var updateTicks = initTickUpdating(instance, state);
		var updateMargins = function(margins) { instance.margins._update(margins); };
		var updateClip = initClipUpdating(instance, state);
		var updateBackground = initBackgroundUpdating(instance, state);
		var updateAxes = initAxisUpdating(instance, state);
		var updateGridlines = initGridlineUpdating(instance, state);

		return function(opts) {
			opts = opts || {};
			updateRemToPx();
			updateTransform();
			updateDebug();
			updateTicks();
			updateMargins(opts.margins);
			if (opts.skip_rendering) return instance;
			updateClip();
			updateBackground();
			var measurements = updateAxes();
			updateGridlines(measurements);
			return instance;
		};
	}

	function initChartLayout(target, state) {
		state = prepareState(state);

		var instance = {};
		var containers = getContainers(target);
		Object.defineProperty(instance, "svg", { get: containers.getSvg });
		instance.container = containers.container;
		instance.chart = addChart(instance);

		instance.data_background = instance.chart.select("g.fl-data-background");
		instance.data_foreground = instance.chart.select("g.fl-data-foreground");

		instance.identifier = initIdentifier(instance);
		instance.debug = initDebug(instance);
		instance.debugColor = initDebugColor(instance);
		instance.clip = initClip(instance);
		instance.animationDuration = initAnimationDuration(instance);

		var dimensions = initDimensions(instance);
		instance.width = dimensions.width;
		instance.height = dimensions.height;
		instance.plotAspect = dimensions.plotAspect;

		Object.defineProperty(instance, "plot_width", { get: dimensions.plotWidth });
		Object.defineProperty(instance, "plot_height", { get: dimensions.plotHeight });
		Object.defineProperty(instance, "x_left", { get: dimensions.xLeft });
		Object.defineProperty(instance, "x_right", { get: dimensions.xRight });
		Object.defineProperty(instance, "y_bottom", { get: dimensions.yBottom });
		Object.defineProperty(instance, "y_top", { get: dimensions.yTop });

		instance.offsetLeft = initOffsetLeft(instance);
		instance.offsetTop = initOffsetTop(instance);

		instance.margins = initMargins(instance, state);

		instance.xData = initData(instance);
		instance.yData = initData(instance);
		instance.y2Data = initData(instance);
		instance.xFormat = initFormat(instance);
		instance.yFormat = initFormat(instance);
		instance.y2Format = initFormat(instance);
		instance.xNumberParse = initNumberParse(instance);
		instance.yNumberParse = initNumberParse(instance);
		instance.y2NumberParse = initNumberParse(instance);
		instance.xDatetimeParse = initDatetimeParse(instance);
		instance.yDatetimeParse = initDatetimeParse(instance);
		instance.y2DatetimeParse = initDatetimeParse(instance);
		instance.xTitle = initXTitle(instance, state); // Implicitly adds instance.xAutoTitle
		instance.yTitle = initYTitle(instance, state); // Implicitly adds instance.yAutoTitle
		instance.y2Title = initY2Title(instance, state); // Implicitly adds instance.y2AutoTitle
		instance.xTicks = initXTicks(instance, state);
		instance.yTicks = initYTicks(instance, state);
		instance.y2Ticks = initY2Ticks(instance, state);
		instance.xAutoTicks = initXAutoTicks(instance);
		instance.yAutoTicks = initYAutoTicks(instance);
		instance.y2AutoTicks = initY2AutoTicks(instance);
		instance.xScale = initXScale(instance, state);
		instance.yScale = initYScale(instance, state);
		instance.y2Scale = initY2Scale(instance, state);
		instance.xPadding = initXPadding(instance);
		instance.yPadding = initYPadding(instance);
		instance.y2Padding = initY2Padding(instance);
		instance.xMinStep = initXMinStep(instance);
		instance.yMinStep = initYMinStep(instance);
		instance.y2MinStep = initY2MinStep(instance);
		instance.xFlipAxis = initFlipAxis(instance);
		instance.yFlipAxis = initFlipAxis(instance);
		instance.y2FlipAxis = initFlipAxis(instance);
		instance.xZeroAxis = initZeroAxis(instance);
		instance.yZeroAxis = initZeroAxis(instance);
		instance.y2ZeroAxis = initZeroAxis(instance);
		instance.xHide = initHide(instance);
		instance.yHide = initHide(instance);
		instance.y2Hide = initHide(instance);

		instance.y2Hide(true);

		instance.update = initUpdate(instance, state);

		return instance;
	}

	return initChartLayout;

})));
