var remToPx;
function updateRemToPx() {
	var multiplier = parseFloat(getComputedStyle(document.documentElement).fontSize);
	var dpr = window.devicePixelRatio;

	remToPx = function(rem, round) {
		if (!rem) return 0;
		if (!round) return rem * multiplier;
		return Math.max(Math.round(rem * multiplier * dpr), 1) / dpr;
	};
}


function getFont(container_selection, size_in_rem, weight) {
	var family_string = getComputedStyle(container_selection.node()).fontFamily;
	var size = remToPx(size_in_rem);
	var size_string = size + "px ";
	var weight_string = weight ? weight + " " : "";
	return weight_string + size_string + family_string;
}


function xyToTranslate(x, y) {
	return "translate(" + x + "," + y +")";
}


function angleToRotate(angle, x, y) {
	x = x || 0;
	y = y || 0;
	return "rotate(" + angle + "," + x + "," + y + ")";
}


var log10 = Math.log10 || function(x) { return Math.log(x) * Math.LOG10E; };


function getExponent(value) {
	return Math.floor(log10(Math.abs(value)));
}


// Based on https://stackoverflow.com/a/22885197
function getSignificantDigitCount(v) {
	if (v === 0) return 0;
	var value = Math.abs(String(v).replace(".", "")); // remove decimal and make positive
	while (value !== 0 && value % 10 === 0) value /= 10; // kill the 0s at the end of n
	return getExponent(value) + 1; // get number of digits
}


// Based on https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
function linesIntersect(p, q) {
	var x1 = p[0][0], x2 = p[1][0], x3 = q[0][0], x4 = q[1][0];
	var y1 = p[0][1], y2 = p[1][1], y3 = q[0][1], y4 = q[1][1];
	var denominator = (x1-x2) * (y3-y4) - (x3-x4) * (y1-y2);

	// Parallel lines
	if (!denominator) {
		if (
			(x1 < x3 && x1 < x4 && x2 < x3 && x2 < x4) // p is left of q
			|| (x1 > x3 && x1 > x4 && x2 > x3 && x2 > x4) // p is right of q
			|| (y1 < y3 && y1 < y4 && y2 < y3 && y2 < y4) // p is above q
			|| (y1 > y3 && y1 > y4 && y2 > y3 && y2 > y4) // p is below q
		) return false;
		return true;
	}

	var t = ((x1-x3)*(y3-y4) - (y1-y3)*(x3-x4)) / denominator;
	if (t < 0 || t > 1) return false; // point of intersection does not fall within the p line segment
	var u = -((x1-x2)*(y1-y3) - (y1-y2)*(x1-x3)) / denominator;
	if (u < 0 || u > 1) return false; // point of intersection does not fall within the q line segment

	return true;
}


function sign(val) {
	if (!val || typeof val !== "number") return 0;
	return val > 0 ? 1 : -1;
}


// The safeScale function wraps a standard d3-scale, preventing it from returning a NaN value or +-Infinity
// which can lead to errors when being used for translations during transitions - eg from a linear scale to
// a log scale or vice versa
function safeScale(scale) {
	var type = scale.type; // Store the type since scale.copy won't copy that custom property across
	scale = scale.copy(); // Use a copy of the scale so it can't be tampered with from outside
	scale.type = type; // Add the type information to the new scale
	var SAFE_POSITION = -1e6; // The +-1e6th pixel should not be on screen
	var COPIED_METHODS = ["domain", "range"];

	var scaleWrapper = function(unscaled_value) {
		var val = scale(unscaled_value);
		// Catch values that will break SVG transforms
		if (isNaN(val) || Math.abs(val) === Infinity) {
			// Work out whether should be off top/left (flipped === false) or bottom/right (flipped)
			var flipped;
			var range = scale.range();
			if (type !== "numeric") flipped = range[0] > range[1] ? true : false;
			else {
				var domain = scale.domain();
				// flipped true for ordinary y axis or x axis is set so go largest -> smallest
				flipped = sign(domain[1] - domain[0]) !== sign(range[1] - range[0]);
			}
			val = SAFE_POSITION * (flipped ? -1 : 1);
		}
		return val;
	};

	// Having the range and domain easily accessible is useful, so apply these functions
	COPIED_METHODS.forEach(function(name) {
		scaleWrapper[name] = function() {
			var result = scale[name].apply(scale, arguments);
			// Return the wrapper rather than the wrapped scale object
			return result === scale ? scaleWrapper : result;
		};
	});

	// Add a custom copy method and the type and step properties to the wrapper
	scaleWrapper.copy = function() { return safeScale(scale); };
	scaleWrapper.type = scale.type;
	scaleWrapper.step = scale.step;

	return scaleWrapper;
}


function isDate(entity) {
	return Object.prototype.toString.call(entity) === "[object Date]";
}


function isValidDate(entity) {
	return isDate(entity) && !isNaN(entity.getTime());
}


function textareaToArray(text_string) {
	return text_string.split("\n")
		.filter(function(d) { return d; })
		.map(function(d) { return d.trim(); });
}

export {
	updateRemToPx,
	remToPx,
	getFont,
	xyToTranslate,
	angleToRotate,
	linesIntersect,
	log10,
	getExponent,
	getSignificantDigitCount,
	safeScale,
	isDate,
	isValidDate,
	textareaToArray
};
