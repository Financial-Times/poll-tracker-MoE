import { remToPx, getFont } from "../common";


function getXTitleHeight(instance, state) {
	var x = state.x;
	var title_text = instance.xTitle();
	if (x.axis_visible === "off" || !title_text) return 0;

	var title_container = instance.chart.select(".fl-x-axis .fl-axis-title");
	var font = getFont(title_container, x.title_size, x.title_weight);

	var title_selection = title_container.append("text")
		.text(title_text)
		.style("opacity", 0)
		.style("font", font);

	var title_height = title_selection.node().getBoundingClientRect().height;
	title_selection.remove();
	return title_height + 2 * remToPx(x.title_padding);
}


function getYTitleHeight(instance, state) {
	var y = state.y;
	var title_text = instance.yTitle();
	if (!y.axis_visible || !title_text) return 0;

	var title_container = instance.chart.select(".fl-left-axis .fl-axis-title");
	var font = getFont(title_container, y.title_size, y.title_weight);

	var title_selection = title_container.append("text")
		.text(title_text)
		.style("opacity", 0)
		.style("font", font);

	var title_height = title_selection.node().getBoundingClientRect().height;
	title_selection.remove();
	return title_height + 2 * remToPx(y.title_padding);
}

// TODO. This function is almost identical to the above so should maybe be combined
// and take arguments for the state property (y/y2) and the container.
function getY2TitleHeight(instance, state) {
	var y = state.y2;
	var title_text = instance.y2Title();
	if (!y.axis_visible || !title_text) return 0;

	var title_container = instance.chart.select(".fl-right-axis .fl-axis-title");
	var font = getFont(title_container, y.title_size, y.title_weight);

	var title_selection = title_container.append("text")
		.text(title_text)
		.style("opacity", 0)
		.style("font", font);

	var title_height = title_selection.node().getBoundingClientRect().height;
	title_selection.remove();
	return title_height + 2 * remToPx(y.title_padding);
}


function getXAxisSpace(instance, state) {
	// Space for x axis
	var x = state.x;
	var pos = x.axis_position;
	if (pos === "off") return 0;
	var tick_space = 0;
	var tick_padding = 0;
	var tick_label_space = 0;
	if (pos === "top" || pos == "bottom") {
		var ticks = instance.xTicks();
		tick_space = ticks.length && x.tick_side === "out" && x.tick_label_position === "default" ? remToPx(x.tick_length) : 0;
		tick_label_space = ticks.max_box_height || 0;
		tick_padding = ticks.length ? remToPx(x.tick_padding) : 0;
	}
	var title_space = getXTitleHeight(instance, state);
	return tick_space + tick_padding + tick_label_space + title_space;
}


function getTopMargin(instance, state) {
	var x = state.x;
	var x_axis_space = 0;
	if (!instance.xHide() && ["top", "float-above"].indexOf(x.axis_position) !== -1) {
		x_axis_space = getXAxisSpace(instance, state);
	}

	var y_offset = 0, y2_offset = 0;
	var y_ticks = !instance.yHide() ? instance.yTicks() : [];
	if (y_ticks.length) {
		var last_y_tick = y_ticks[y_ticks.length - 1]; // Assume last tick is placed at the top of the axis
		if (state.y.tick_label_position == "default") y_offset = 0.9 * last_y_tick.box_height_above;
		else if (state.y.tick_label_position == "above") y_offset += last_y_tick.box_height;
	}
	var y2_ticks = !instance.y2Hide() ? instance.y2Ticks() : [];
	if (y2_ticks.length) {
		var last_y2_tick = y2_ticks[y2_ticks.length - 1]; // Assume last tick is placed at the top of the axis
		if (state.y2.tick_label_position == "default") y2_offset = 0.9 * last_y2_tick.box_height_above;
		else if (state.y2.tick_label_position == "above") y2_offset += last_y2_tick.box_height;
	}
	var y_overflow = Math.max(remToPx(0.25), y_offset, y2_offset);
	return Math.max(x_axis_space, y_overflow);
}


function getBottomMargin(instance, state) {
	var x = state.x;
	var x_axis_space = 0;
	if (!instance.xHide() && ["bottom", "float-below"].indexOf(x.axis_position) !== -1) {
		x_axis_space = getXAxisSpace(instance, state);
	}
	var y_offset = 0, y2_offset = 0;
	var y_ticks = !instance.yHide() ? instance.yTicks() : [];
	if (y_ticks.length) {
		var first_y_tick = y_ticks[0]; // Assume first tick is placed at the bottom of the axis
		if (state.y.tick_label_position == "default") y_offset = 0.9 * first_y_tick.box_height_below;
		else if (state.y.tick_label_position == "below") y_offset += first_y_tick.box_height;
	}
	var y2_ticks = !instance.y2Hide() ? instance.y2Ticks() : [];
	if (y2_ticks.length) {
		var first_y2_tick = y2_ticks[0]; // Assume first tick is placed at the bottom of the axis
		if (state.y2.tick_label_position == "default") y2_offset = 0.9 * first_y2_tick.box_height_below;
		else if (state.y2.tick_label_position == "below") y2_offset += first_y2_tick.box_height;
	}
	var y_overflow = Math.max(remToPx(0.25), y_offset, y2_offset);
	return Math.max(x_axis_space, y_overflow);
}


function getLeftMargin(instance, state) {
	// Space for y axis
	var y = state.y;
	var axis_width = 0;
	if (y.axis_visible) {
		var ticks = !instance.yHide() ? instance.yTicks() : [];
		var tick_space = ticks.length && y.tick_side === "out" && y.tick_label_position === "default" ? remToPx(y.tick_length) : 0;
		var tick_padding = ticks.length ? remToPx(y.tick_padding) : 0;
		var tick_label_space = ticks.max_box_width || 0;
		var title_space = !instance.yHide() ? getYTitleHeight(instance, state) : 0;
		axis_width = tick_space + tick_padding + tick_label_space + title_space;
	}

	// Space for overflowing x tick
	var x_overflow = remToPx(0.25), offset = 0;
	var x_ticks = !instance.xHide() ? instance.xTicks() : [];
	if (x_ticks.length) {
		var first_x_tick = x_ticks[0]; // Assume first tick is placed at the left edge of the axis
		if (state.x.tick_label_position == "default") offset = 0.9 * first_x_tick.box_width_left;
		else if (state.x.tick_label_position == "left") offset = first_x_tick.box_width;
		x_overflow = Math.max(x_overflow, offset);
	}

	return Math.max(axis_width, x_overflow);
}


function getRightMargin(instance, state) {
	// Space for y axis
	var y2 = state.y2;
	var axis_width = 0;
	if (y2.axis_visible) {
		var y2_ticks = !instance.y2Hide() ? instance.y2Ticks() : [];
		var tick_space = y2_ticks.length && (y2.tick_side === "out" && y2.tick_label_position === "default") ? remToPx(y2.tick_length) : 0;
		var tick_padding = y2_ticks.length ? remToPx(y2.tick_padding) : 0;
		var tick_label_space = y2_ticks.max_box_width || 0;
		var title_space = !instance.y2Hide() ? getY2TitleHeight(instance, state) : 0;
		axis_width = tick_space + tick_padding + tick_label_space + title_space;
	}

	// Space for overflowing x tick
	var x_overflow = remToPx(0.25), offset = 0;
	var x_ticks = !instance.xHide() ? instance.xTicks() : [];
	if (x_ticks.length) {
		var last_x_tick = x_ticks[x_ticks.length - 1]; // Assume last tick is placed at the right edge of the axis
		if (state.x.tick_label_position == "default") offset = 0.9 * last_x_tick.box_width_right;
		else if (state.x.tick_label_position == "right") offset = last_x_tick.box_width;
		x_overflow = Math.max(x_overflow, offset);
	}

	return Math.max(axis_width, x_overflow);
}


function initMargins(instance, state) {
	var top, right, bottom, left;

	var updateMargins = function(overrides) {
		overrides = overrides || {};
		top = overrides.top !== undefined ? overrides.top : getTopMargin(instance, state);
		right = overrides.right !== undefined ? overrides.right : getRightMargin(instance, state);
		bottom = overrides.bottom !== undefined ? overrides.bottom : getBottomMargin(instance, state);
		left = overrides.left !== undefined ? overrides.left : getLeftMargin(instance, state);
	};

	var margins = function() {
		return { top: top, right: right, bottom: bottom, left: left };
	};

	margins._update = updateMargins;

	Object.defineProperty(margins, "top", { get: function() { return top; } });
	Object.defineProperty(margins, "right", { get: function() { return right; } });
	Object.defineProperty(margins, "bottom", { get: function() { return bottom; } });
	Object.defineProperty(margins, "left", { get: function() { return left; } });

	return margins;
}


export { initMargins };
