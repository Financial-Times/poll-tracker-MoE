import { scaleLinear, scaleLog, scalePoint, scaleTime } from "d3-scale";

var LOG_SCALE_FACTOR = 1000;


function getPointScale(data, {edge_padding, flip}) {
	var domain = flip ? data.unique().reverse() : data.unique();
	var scale = scalePoint().domain(domain).padding(edge_padding/100);
	scale.type = "ordinal";
	return scale;
}


function getLinearDomain(data, {min, max, include_zero, nice, flip}) {
	const FALLBACK_DOMAIN_RANGE = 100; // If we can't construct a sensible default domain, make an arbitrary one this wide
	if (min === max) min = max = null; // If min and max are equal then ignore them both
	// If we have min and max then it's easy
	if (min !== null && max !== null) return flip ? [max, min] : [min, max];

	let domain;
	if (data.range) { // Standard case: multiple different values
		domain = data.extent();
		if (nice) domain = scaleLinear().domain(domain).nice().domain();
		if (include_zero) {
			if (domain[0] >= 0) domain[0] = 0;
			else if (domain[1] < 0) domain[1] = 0;
		}
	}
	else if (data.length) { // Only one unique value
		var value = data.min;
		if (value > 0) domain = [0, 2 * value]; // Place value in middle of domain starting at 0
		else if (value < 0) domain = [2 * value, 0]; // Place value in middle of domain ending at 0
		else domain = [-FALLBACK_DOMAIN_RANGE/2, FALLBACK_DOMAIN_RANGE/2]; // Domain centred on 0 with arbitrary min and max
	}
	else domain = [0, FALLBACK_DOMAIN_RANGE]; // No values at all: pick arbitrary domain values

	if (min !== null) {
		domain[0] = min;
		// If domain values now match we need to do something, so change the non-specified max value
		if (domain[0] === domain[1]) domain[1] = min + (data.range || FALLBACK_DOMAIN_RANGE);
	}
	else if (max !== null) {
		domain[1] = max;
		// If domain values now match we need to do something, so change the non-specified min value
		if (domain[0] === domain[1]) domain[0] = max - (data.range || FALLBACK_DOMAIN_RANGE);
	}

	return flip ? domain.reverse() : domain;
}


function getLinearScale(data, settings) {
	var domain = getLinearDomain(data, settings);
	var scale = scaleLinear().domain(domain);
	scale.type = "numeric";
	return scale;
}


function getLogScale(data, {min, max, nice, flip}) {
	// Get suitable values for the domain based on data
	const extent = data.extent();
	if (extent[0] <= 0) {
		if (extent[1] > 0) extent[0] = Math.min(1, extent[1]/LOG_SCALE_FACTOR);
		else extent[0] = 1;
	}
	if (extent[1] <= extent[0]) extent[1] = LOG_SCALE_FACTOR * extent[0];
	const scale = scaleLog().domain(extent);
	if (nice) scale.nice();
	const domain = scale.domain();

	// Override domain values if min and/or max appropriate
	if (min === max) min = max = null;
	if (min > 0) domain[0] = min;
	if (max > 0) domain[1] = max;
	scale.domain(flip ? domain.reverse() : domain);
	scale.type = "numeric";

	return scale;
}


function getDatetimeScale(data, {min, max, format, nice, flip}) {
	const extent = data.extent();
	const scale = scaleTime().domain(extent);
	if (nice) scale.nice();
	if (format) scale.tickFormat(null, format);
	const domain = scale.domain();

	if (min === max) min = max = null;
	if (min) domain[0] = format(min);
	if (max) domain[1] = format(max);
	scale.domain(flip ? domain.reverse() : domain);
	scale.type = "datetime";

	return scale;
}


export {
	getPointScale,
	getLinearScale,
	getLogScale,
	getDatetimeScale
};
