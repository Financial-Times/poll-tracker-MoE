import { getPointScale, getLinearScale, getLogScale, getDatetimeScale } from "./scales";
import { minStep } from "./utils";


function initXPadding(instance) {
	const UNITS = [ "px", "steps" ];
	let left = 0;
	let right = 0;
	let unit = "px";

	return function(values) {
		if (values === undefined) return { left, right, unit };
		const u = values.unit;
		if (u && !UNITS.includes(u)) throw new Error(`Unit "${u}" not recognised`);
		({ left = left, right = right, unit = unit } = values);
		return instance;
	};
}


function getXPadding(instance, x_state, domain) {
	const no_padding = { left: 0, right: 0 };
	const x_data = instance.xData();
	// Ignore developer-set padding on categorical axes because of user-set padding
	if (x_data.string_array) return no_padding;

	const { left, right, unit } = instance.xPadding();

	// Ignore developer-set padding on logarithmic axes if not in px
	if (x_data.numeric_array && x_state.numeric_scale_type !== "linear" && unit !== "px") return no_padding;

	if (unit === "px" || (!left && !right)) return { left, right };

	const unique_values = x_data.uniqueAscending();
	const n = unique_values.length;
	if (n < 2) return no_padding;

	let min_data_step = Infinity;
	for (let i = 1; i < n; i++) {
		const step = Math.abs(unique_values[i] - unique_values[i-1]);
		min_data_step = Math.min(min_data_step, step);
	}

	const domain_width = Math.max(...domain) - Math.min(...domain); // in domain units
	const full_width = domain_width + ((left + right) * min_data_step); // in domain units
	const n_min_steps = full_width / min_data_step;
	const step_width = instance.plot_width / n_min_steps; // in pixels

	return { left: left * step_width, right: right * step_width };
}


function initXScale(instance, state) {
	const x = state.x;

	return function(opts = {}) {
		const x_data = instance.xData();
		const settings = { nice: x.nice, flip: instance.xFlipAxis() !== x.flip };
		let getScale;
		if (x_data.string_array) {
			getScale = getPointScale;
			settings.edge_padding = x.edge_padding;
		}
		else if (x_data.datetime_array) {
			getScale = getDatetimeScale;
			settings.min = x.datetime_min;
			settings.max = x.datetime_max;
			settings.format = instance.xDatetimeParse();
		}
		else if (x.numeric_scale_type === "log") {
			getScale = getLogScale;
			settings.min = x.log_min;
			settings.max = x.log_max;
		}
		else {
			getScale = getLinearScale;
			settings.min = x.linear_min;
			settings.max = x.linear_max;
			settings.include_zero = x.zero_axis === "off" ? false : (x.zero_axis === "on" ? true : instance.xZeroAxis());
		}

		const xScale = getScale(x_data, settings);
		if (opts.domain_only) return xScale;

		const x_width = instance.plot_width;
		const left_margin = instance.margins.left;
		const { left, right } = getXPadding(instance, x, xScale.domain());
		const effective_width = x_width - (left + right);
		const range_start = left_margin + left;
		let range = [ range_start, range_start + effective_width ];
		const offset = opts.global && instance.offsetLeft();
		if (offset) range = range.map(function(x) { return x + offset; });

		return xScale.range(range);
	};
}


function initXMinStep(instance) {
	return function() {
		return minStep(instance.xData(), instance.xScale());
	};
}


export { initXScale, initXMinStep, initXPadding };
