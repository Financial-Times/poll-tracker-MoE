import { getPointScale, getLinearScale, getLogScale, getDatetimeScale } from "./scales";
import { minStep } from "./utils";


function initYPadding(instance) {
	const UNITS = [ "px", "steps" ];
	let bottom = 0;
	let top = 0;
	let unit = "px";

	return function(values) {
		if (values === undefined) return { bottom, top, unit };
		const u = values.unit;
		if (u && !UNITS.includes(u)) throw new Error(`Unit "${u}" not recognised`);
		({ bottom = bottom, top = top, unit = unit } = values);
		return instance;
	};
}


function getYPadding(instance, y_state, domain) {
	const no_padding = { bottom: 0, top: 0 };
	const y_data = instance.yData();
	// Ignore developer-set padding on categorical axes because of user-set padding
	if (y_data.string_array) return no_padding;

	const { bottom, top, unit } = instance.yPadding();

	// Ignore developer-set padding on logarithmic axes if not in px
	if (y_data.numeric_array && y_state.numeric_scale_type !== "linear" && unit !== "px") return no_padding;

	if (unit === "px" || (!bottom && !top)) return { bottom, top };

	const unique_values = y_data.uniqueAscending();
	const n = unique_values.length;
	if (n < 2) return no_padding;

	let min_data_step = Infinity;
	for (let i = 1; i < n; i++) {
		const step = Math.abs(unique_values[i] - unique_values[i-1]);
		min_data_step = Math.min(min_data_step, step);
	}

	const domain_width = Math.max(...domain) - Math.min(...domain); // in domain units
	const full_width = domain_width + ((bottom + top) * min_data_step); // in domain units
	const n_min_steps = full_width / min_data_step;
	const step_width = instance.plot_height / n_min_steps; // in pixels

	return { bottom: bottom * step_width, top: top * step_width };
}


function initYScale(instance, state) {
	const y = state.y;

	return function(opts = {}) {
		var y_data = instance.yData();

		const settings = { nice: y.nice, flip: instance.yFlipAxis() !== y.flip };
		let getScale;
		if (y_data.string_array) {
			getScale = getPointScale;
			settings.edge_padding = y.edge_padding;
		}
		else if (y_data.datetime_array) {
			getScale = getDatetimeScale;
			settings.min = y.datetime_min;
			settings.max = y.datetime_max;
			settings.format = instance.yDatetimeParse();
		}
		else if (y.numeric_scale_type === "log") {
			getScale = getLogScale;
			settings.min = y.log_min;
			settings.max = y.log_max;
		}
		else {
			getScale = getLinearScale;
			settings.min = y.linear_min;
			settings.max = y.linear_max;
			settings.include_zero = y.zero_axis === "off" ? false : (y.zero_axis === "on" ? true : instance.yZeroAxis());
		}

		const yScale = getScale(y_data, settings);
		if (opts.domain_only) return yScale;

		const y_height = instance.plot_height;
		const top_margin = instance.margins.top;
		const { bottom, top } = getYPadding(instance, y, yScale.domain());
		const effective_height = y_height - (bottom + top);
		const offset = opts.global && instance.offsetTop();
		const range_start = top_margin + top;
		let range = [ range_start + effective_height, range_start ];
		if (offset) range = range.map(function(y) { return y + offset; });

		return yScale.range(range);
	};
}


function initYMinStep(instance) {
	return function() {
		return minStep(instance.yData(), instance.yScale());
	};
}


export { initYScale, initYMinStep, initYPadding };
