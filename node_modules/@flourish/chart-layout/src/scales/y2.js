import { getPointScale, getLinearScale, getLogScale, getDatetimeScale } from "./scales";
import { minStep } from "./utils";


function initY2Padding(instance) {
	const UNITS = [ "px", "steps" ];
	let bottom = 0;
	let top = 0;
	let unit = "px";

	return function(values) {
		if (values === undefined) return { bottom, top, unit };
		const u = values.unit;
		if (u && !UNITS.includes(u)) throw new Error(`Unit "${u}" not recognised`);
		({ bottom = bottom, top = top, unit = unit } = values);
		return instance;
	};
}


function getY2Padding(instance, y2_state, domain) {
	const no_padding = { bottom: 0, top: 0 };
	const y2_data = instance.y2Data();
	// Ignore developer-set padding on categorical axes because of user-set padding
	if (y2_data.string_array) return no_padding;

	const { bottom, top, unit } = instance.y2Padding();

	// Ignore developer-set padding on logarithmic axes if not in px
	if (y2_data.numeric_array && y2_state.numeric_scale_type !== "linear" && unit !== "px") return no_padding;

	if (unit === "px" || (!bottom && !top)) return { bottom, top };

	const unique_values = y2_data.uniqueAscending();
	const n = unique_values.length;
	if (n < 2) return no_padding;

	let min_data_step = Infinity;
	for (let i = 1; i < n; i++) {
		const step = Math.abs(unique_values[i] - unique_values[i-1]);
		min_data_step = Math.min(min_data_step, step);
	}

	const domain_width = Math.max(...domain) - Math.min(...domain); // in domain units
	const full_width = domain_width + ((bottom + top) * min_data_step); // in domain units
	const n_min_steps = full_width / min_data_step;
	const step_width = instance.plot_width / n_min_steps; // in pixels

	return { bottom: bottom * step_width, top: top * step_width };
}


function initY2Scale(instance, state) {
	const y2 = state.y2;

	return function(opts = {}) {
		var y2_data = instance.y2Data();

		const settings = { nice: y2.nice, flip: instance.y2FlipAxis() !== y2.flip };
		let getScale;
		if (y2_data.string_array) {
			getScale = getPointScale;
			settings.edge_padding = y2.edge_padding;
		}
		else if (y2_data.datetime_array) {
			getScale = getDatetimeScale;
			settings.min = y2.datetime_min;
			settings.max = y2.datetime_max;
			settings.format = instance.y2DatetimeParse();
		}
		else if (y2.numeric_scale_type === "log") {
			getScale = getLogScale;
			settings.min = y2.log_min;
			settings.max = y2.log_max;
		}
		else {
			getScale = getLinearScale;
			settings.min = y2.linear_min;
			settings.max = y2.linear_max;
			settings.include_zero = y2.zero_axis === "off" ? false : (y2.zero_axis === "on" ? true : instance.y2ZeroAxis());
		}

		const yScale = getScale(y2_data, settings);
		if (opts.domain_only) return yScale;

		const y2_height = instance.plot_height;
		const top_margin = instance.margins.top;
		const { bottom, top } = getY2Padding(instance, y2, yScale.domain());
		const effective_height = y2_height - (bottom + top);
		const offset = opts.global && instance.offsetTop();
		const range_start = top_margin + top;
		let range = [ range_start + effective_height, range_start ];
		if (offset) range = range.map(function(y) { return y + offset; });

		return yScale.range(range);
	};
}


function initY2MinStep(instance) {
	return function() {
		return minStep(instance.y2Data(), instance.y2Scale());
	};
}


export { initY2Scale, initY2MinStep, initY2Padding };
