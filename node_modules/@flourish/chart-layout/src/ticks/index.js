import { select } from "d3-selection";
import { remToPx, getFont, getSignificantDigitCount, getExponent } from "../common";

var DUMMY_TEXT = "Testing";


function degToRad(deg) {
	return deg * (Math.PI / 180);
}


function dropRepeatedLabels(tick_array, format) {
	var last_value;
	return tick_array.filter(function(value) {
		var fv = format(value);
		if (fv === last_value) return;
		last_value = fv;
		return true;
	});
}

function getFitTextFunction(params) {
	var max_space = params.max_space !== undefined ? params.max_space : 100;
	var text_height = params.text_height !== undefined ? params.text_height : remToPx(1);
	var max_lines = params.max_lines;
	var angle = params.angle || 0;
	var canvas = document.createElement("canvas");
	var ctx = canvas.getContext("2d");
	ctx.font = params.font;

	var max_width = max_space;
	var theta = degToRad(angle);
	max_width = (max_space - text_height * Math.sin(theta)) / Math.cos(theta);

	return function(text) {
		var lines = [];
		var max_line_width = 0;

		// Everything fits in one line, so leave as a single string
		var text_width = ctx.measureText(text).width;
		if (text_width <= max_width) {
			lines.push(text);
			max_line_width = text_width;
		}

		// Otherwise…
		else {
			// Create array of words
			var words = text.trim().split(/\s+/g);
			// Loop through the words, adding them until they won't fit
			var current_line = "";
			for (var i = 0; i < words.length; i++) {
				var word = words[i];
				var string = current_line + (current_line ? " " : "") + word;
				var string_width = ctx.measureText(string).width;
				// If the string including the next word fits, update the
				// current_line and the max_width
				if (string_width <= max_width) {
					current_line = string;
					max_line_width = Math.max(max_line_width, string_width);
				}
				// If we reach this point, the text has overflowed,
				// so should always result in a truncation or a new line
				else {
					var last_line = lines.length + 1 == max_lines;
					if (!last_line && current_line) {
						lines.push(current_line);
						var word_width = ctx.measureText(word).width;
						if (word_width <= max_width) {
							current_line = word;
							continue;
						}
					}
					// Truncate
					var remove_counter = 1;
					var truncated_string = string;
					do {
						truncated_string = string.substring(0, string.length - remove_counter) + "…";
						string_width = ctx.measureText(truncated_string).width;
					}
					while ((string_width > max_width) && (++remove_counter < string.length));
					max_line_width = Math.max(max_line_width, string_width);
					current_line = truncated_string;
					break;
				}
			}
			lines.push(current_line);
		}
		return { lines: lines, text_width: max_line_width };
	};
}


function getAutoLabelSpaceFunction(instance, dimension) {
	var UNITS = [ "px", "rem", "fraction" ];
	dimension = dimension || "width";
	var value = 0.3;
	var unit = "fraction";

	var getValues = function() {
		var dim = instance[dimension]();
		var px = unit === "px" ? value : (unit === "rem" ? remToPx(value) : (value * dim));
		return {
			px: px,
			rem: unit === "rem" ? value : px / remToPx(1),
			fraction: unit === "fraction" ? value : px / dim,
			unit: unit
		};
	};

	return function(v, u) {
		if (v === undefined) return getValues();
		value = Math.max(v, 0);
		unit = UNITS.indexOf(u) !== -1 ? u : "px";
		return instance;
	};
}


function initXTicks(instance, state) {
	var x = state.x;
	var ticks = Object.freeze([]);
	var group = instance.chart.select(".fl-x-axes");

	var setTicks = function(tick_array) {
		var type = instance.xData().string_array ? "string" : "numeric";
		var font = getFont(select(".fl-x-axes"), x.tick_label_size, x.tick_label_weight);
		var angle = x.tick_label_position === "default" ? +x.tick_label_angle : 90;
		var max_box_height = 0;
		var format = instance.xFormat();
		var text_height;
		var font_size = remToPx(x.tick_label_size);
		// Used in conjunction with line height for estimating the height of each line
		// in a multiline label

		group.append("text")
			.style("opacity", 0)
			.style("font", font)
			.each(function() {
				var bounds = select(this).text(DUMMY_TEXT).node().getBoundingClientRect();
				text_height = bounds.height;
			})
			.remove();

		// filter out dates that will give repeated tick labels
		if (typeof tick_array[0] === "object") tick_array = dropRepeatedLabels(tick_array, format);

		var max_space = remToPx(x.tick_label_space);
		if (x.tick_label_space_mode === "auto") max_space = instance.xTicks.autoLabelSpace().px;
		var params =  { text_height: text_height, max_space: max_space, font: font, angle: 90 - angle, max_lines: x.tick_label_max_lines };
		var fitText = getFitTextFunction(params);

		ticks = tick_array.map(function(value, index) {
			var result = fitText(format(value));
			var lines = result.lines;
			var text_width = result.text_width;
			var box_width, box_height, box_width_left, box_width_right, box_height_left, box_height_right;
			var multiline_offset = 0;

			var total_text_height = (text_height * lines.length) + ((lines.length - 1) * x.tick_label_line_height);
			if (angle === 0 || angle === 90) {
				// Add extra padding for non-rotated text
				box_width = angle === 0 ? text_width + remToPx(0.5) : total_text_height;
				box_height = angle === 0 ? total_text_height : text_width;
				box_width_left = box_width_right = box_width / 2;
				box_height_left = box_height;
				box_height_right = box_height;
				if (angle === 90) multiline_offset = lines.length < 2 ? 0 : ((lines.length - 1)/2 * (font_size * x.tick_label_line_height));
			}
			else {
				/*
			   tl------tr <- rotate about tr
				 |        |
				 bl------br
			*/
				var theta = degToRad(angle);
				var sinTheta = Math.sin(theta);
				var cosTheta = Math.cos(theta);
				box_width_left = text_width * cosTheta; // horizontal distance between tl and tr after rotation
				box_width_right = total_text_height * sinTheta; // horizontal distance between br and tr after rotation
				box_height_left = text_width * sinTheta; // vertical distance between tl and tr after rotation
				box_height_right = total_text_height * cosTheta; // vertical distance between br and tr after rotation
				box_width = box_width_left + box_width_right; // total bounding box width after rotation
				box_height = box_height_left + box_height_right; // total bounding box height after rotation
			}

			// Reverse left and right when axis is at top
			// This can probably be simplified with some basic trigonometry
			if (x.axis_position === "top" || x.axis_position === "float-above") {
				var temp = box_width_left;
				box_width_left = box_width_right;
				box_width_right = temp;
				temp = box_height_left;
				box_height_left = box_height_right;
				box_height_right = temp;

				// Also adjust multiline offsets for angled top/above ticks, since we want
				// the lines to flow upwards not downwards
				if (angle !== 0 && angle !== 90) multiline_offset = lines.length < 2 ? 0 : (lines.length - 1) * (font_size * x.tick_label_line_height);
			}

			max_box_height = Math.max(max_box_height, box_height);
			var significant_digits = type === "numeric" ? getSignificantDigitCount(value) : null;
			var exponent = type === "numeric" ? getExponent(value) : null;

			return Object.freeze({
				index: index,
				value: value,
				lines: lines,
				significant_digits: significant_digits,
				exponent: exponent,
				text_width: text_width,
				text_height: text_height,
				box_width: box_width,
				box_height: box_height,
				box_width_left: box_width_left,
				box_width_right: box_width_right,
				box_height_left: box_height_left,
				box_height_right: box_height_right,
				multiline_offset: multiline_offset
			});
		});

		ticks.type = type;
		ticks.max_box_height = x.tick_label_space_mode === "fixed" ? remToPx(x.tick_label_space) : max_box_height;
		Object.freeze(ticks);

		return instance;
	};

	var getTicks = function() { return ticks; };
	getTicks._update = setTicks;
	getTicks.autoLabelSpace = getAutoLabelSpaceFunction(instance, "height");

	return getTicks;
}


function initVerticalTicks(instance, state, y_name) {
	var y = state[y_name];
	var data_name = y_name + "Data";
	var format_name = y_name + "Format";
	var ticks_name = y_name + "Ticks";
	var ticks = Object.freeze([]);
	var group = instance.chart.select(".fl-y-axes");

	var setTicks = function(tick_array) {
		var type = instance[data_name]().string_array ? "string" : "numeric";
		var font = getFont(select(".fl-y-axes"), y.tick_label_size, y.tick_label_weight);
		var angle = y.tick_label_position === "default" ? +y.tick_label_angle : 0;
		var max_box_width = 0;
		var format = instance[format_name]();
		var text_height;

		group.append("text")
			.style("opacity", 0)
			.style("font", font)
			.each(function() {
				var bounds = select(this).text(DUMMY_TEXT).node().getBoundingClientRect();
				text_height = bounds.height;
			})
			.remove();

		// filter out dates that will give repeated tick labels
		if (typeof tick_array[0] === "object") tick_array = dropRepeatedLabels(tick_array, format);

		var max_space = remToPx(y.tick_label_space);
		if (y.tick_label_space_mode === "auto") max_space = instance[ticks_name].autoLabelSpace().px;
		var params =  { text_height: text_height, max_space: max_space, font: font, angle: angle, max_lines: angle ? 1 : y.tick_label_max_lines };
		var fitText = getFitTextFunction(params);

		ticks = tick_array.map(function(value, index) {
			var result = fitText(format(value));
			var lines = result.lines;
			var text_width = result.text_width;
			var box_width, box_height, box_width_above, box_width_below, box_height_above, box_height_below;
			var multiline_offset = 0;

			var total_text_height = (text_height * lines.length) + ((lines.length - 1) * y.tick_label_line_height);
			if (angle === 0 || angle === 90) {
				box_width = !angle ? text_width : total_text_height;
				// Add extra padding for text rotated by 90 degrees
				box_height = !angle ? total_text_height : text_width + remToPx(0.5);
				box_width_above = box_width;
				box_width_below = box_width;
				box_height_above = box_height_below = box_height / 2;
				if (angle === 0) multiline_offset = lines.length < 2 ? 0 : ((lines.length - 1)/2 * (text_height * y.tick_label_line_height));
			}
			else {
				/*
			   tl------tr
				 |        |
				 bl------br <- rotate about br
				*/
				var theta = degToRad(angle);
				var sinTheta = Math.sin(theta);
				var cosTheta = Math.cos(theta);
				box_width_above = total_text_height * sinTheta; // horizontal distance between tr and br after rotation
				box_width_below = text_width * cosTheta; // horizontal distance between bl and br after rotation
				box_height_above = total_text_height * cosTheta; // vertical distance between tr and br after rotation
				box_height_below = text_width * sinTheta; // vertical distance between bl and br after rotation
				box_width = box_width_above + box_width_below; // total bounding box width after rotation
				box_height = box_height_above + box_height_below; // total bounding box height after rotation
			}

			max_box_width = Math.max(max_box_width, box_width);
			var significant_digits = type === "numeric" ? getSignificantDigitCount(value) : null;
			var exponent = type === "numeric" ? getExponent(value) : null;

			return Object.freeze({
				index: index,
				value: value,
				lines: lines,
				type: type,
				significant_digits: significant_digits,
				exponent: exponent,
				text_width: text_width,
				text_height: text_height,
				box_width: box_width,
				box_height: box_height,
				box_width_above: box_width_above,
				box_width_below: box_width_below,
				box_height_above: box_height_above,
				box_height_below: box_height_below,
				multiline_offset: multiline_offset
			});
		});

		ticks.type = type;
		ticks.max_box_width = y.tick_label_space_mode === "fixed" ? remToPx(y.tick_label_space) : max_box_width;
		Object.freeze(ticks);

		return instance;
	};

	var getTicks = function() { return ticks; };
	getTicks._update = setTicks;
	getTicks.autoLabelSpace = getAutoLabelSpaceFunction(instance);

	return getTicks;
}

// TODO: Maybe this should take an object?
function initYTicks(instance, state) {
	return initVerticalTicks(instance, state, "y");
}

function initY2Ticks(instance, state) {
	return initVerticalTicks(instance, state, "y2");
}


function initAutoTicks(instance, axis = "x") {
	const DEFAULT = () => instance[axis + "Scale"]({ "domain_only": true }).ticks();
	let value = DEFAULT;

	return function(v) {
		if (v === undefined) return value;
		if (v === null) value = DEFAULT;
		else value = v;
		return instance;
	};
}


function initXAutoTicks(instance) {
	const func = initAutoTicks(instance, "x");
	return v => func(v);
}


function initYAutoTicks(instance) {
	const func = initAutoTicks(instance, "y");
	return v => func(v);
}


function initY2AutoTicks(instance) {
	const func = initAutoTicks(instance, "y2");
	return v => func(v);
}


export { initXTicks, initYTicks, initY2Ticks, initXAutoTicks, initYAutoTicks, initY2AutoTicks };
