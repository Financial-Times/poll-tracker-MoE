import { select } from "d3-selection";
import { remToPx, xyToTranslate, angleToRotate, linesIntersect, safeScale } from "../../common";
import { tickSorter, userSelectNone, getDirectionAttribute } from "./common";


function initXAxisUpdating(instance, state) {
	var x = state.x;
	var xScale, yScale, animation_duration;
	var line_color, line_width, tick_label_color;
	var tick_length, tick_label_size, tick_label_distance;
	var title_size, title_text;
	var x_left, x_mid, x_right, x_left_old, x_right_old;
	var oldXScale, enteringXScale, exitingXScale, oldYScale;

	function setValues() {
		xScale = safeScale(instance.xScale());
		yScale = safeScale(instance.yScale());
		animation_duration = oldXScale ? instance.animationDuration() : 0;
		x_left = instance.x_left;
		x_right = instance.x_right;
		x_mid = (x_left + x_right) / 2;
		if (x_left_old === undefined) x_left_old = x_left;
		if (!oldXScale) oldXScale = xScale;
		enteringXScale = oldXScale.type === xScale.type && xScale.type !== "ordinal" ? oldXScale : xScale;
		exitingXScale = oldXScale.type === xScale.type && oldXScale.type !== "ordinal" ? xScale : oldXScale;
		line_color = x.line_and_tick_color;
		line_width = remToPx(x.line_and_tick_width, true);
		tick_label_color = x.tick_label_color;

		var ticks_labels_below = x.tick_label_position === "default";
		var x_ticks = instance.xTicks();
		var axis_height = x_ticks.max_box_height;
		var tick_padding = x_ticks.length ? remToPx(x.tick_padding) : 0;
		if (x.axis_position == "top" || x.axis_position == "bottom") axis_height += tick_padding;
		var ticks_out = x.tick_side === "out";
		tick_length = ticks_labels_below ? (remToPx(x.tick_length) * (ticks_out ? 1 : -1)) : axis_height;
		tick_label_size = remToPx(x.tick_label_size);
		tick_label_distance = (ticks_out && ticks_labels_below ? tick_length : 0) + tick_padding;
		title_size = remToPx(x.title_size);
		title_text = instance.xTitle();
	}

	var updateBottomAxis = (function() {
		var bottom = instance.chart.select("g.fl-bottom-axis");
		var line_container = bottom.select("g.fl-axis-line");
		var tick_container = bottom.select("g.fl-axis-ticks");
		var title_container = bottom.select("g.fl-axis-title");
		var y_bottom_old;

		return function() {
			var pos = x.axis_position;
			var measurements = { pos: pos };
			var show_this_axis = (!instance.xHide() && ["bottom", "float-below"].indexOf(pos) !== -1);
			var ticks = show_this_axis ? instance.xTicks() : [];
			var y_bottom = instance.y_bottom;
			if (y_bottom_old === undefined) y_bottom_old = y_bottom;
			var title_distance = y_bottom + remToPx(x.title_padding);
			if (pos === "bottom") {
				title_distance += tick_label_distance + ticks.max_box_height;
				measurements.extended_gridline = y_bottom + tick_label_distance + ticks.max_box_height;
			}

			function getAxisPosition(value, fallback) {
				if (value === undefined || isNaN(value)) return fallback;
				return value;
			}

			var axis_y_position_old = y_bottom_old;
			var axis_y_position = y_bottom;
			if (pos === "float-below") {
				axis_y_position_old = getAxisPosition((oldYScale || yScale)(x.y_axis_position), y_bottom_old);
				axis_y_position = getAxisPosition(yScale(x.y_axis_position), y_bottom);
			}

			var line = line_container.selectAll("line")
				.data(show_this_axis && x.line_visible ? [xScale.domain()] : []);

			line.exit()
				.style("stroke", line_color)
				.style("stroke-width", line_width)
				.transition()
				.duration(animation_duration)
				.attr("x1", x_left)
				.attr("x2", x_right)
				.attr("y1", axis_y_position)
				.attr("y2", axis_y_position)
				.style("opacity", 0)
				.remove();

			var line_enter = line.enter()
				.append("line")
				.style("shape-rendering", "crispEdges")
				.style("stroke-linecap", "square")
				.style("stroke-width", line_width)
				.attr("x1", x_left_old)
				.attr("x2", x_right_old)
				.attr("y1", axis_y_position_old)
				.attr("y2", axis_y_position_old)
				.style("opacity", 0);

			line.merge(line_enter)
				.style("stroke", line_color)
				.style("stroke-width", line_width)
				.transition()
				.duration(animation_duration)
				.attr("x1", x_left)
				.attr("x2", x_right)
				.attr("y1", axis_y_position)
				.attr("y2", axis_y_position)
				.style("opacity", 1);

			var sorted_ticks = show_this_axis ? ticks : [];
			if (ticks.type === "numeric" && x.tick_mode !== "custom") {
				sorted_ticks = ticks.slice().sort(tickSorter);
			}

			var tickLabelTransform = function(d) {
				var angle = x.tick_label_position == "default" ? -x.tick_label_angle : -90;
				var rotate = angleToRotate(angle, 0, 0);
				if (x.tick_label_position !== "default") {
					var y_offset = x.tick_label_position === "left" ? -0.3 : 1;
					return xyToTranslate(0, tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size * y_offset);
				}
				if (angle === 0) {
					return xyToTranslate(d.text_width/2, tick_label_distance + tick_label_size*0.66);
				}
				else if (angle === -90) {
					return xyToTranslate(0, tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size*0.33 - d.multiline_offset);
				}
				else {
					return xyToTranslate(0, tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size*0.66);
				}
			};

			var tick_g = tick_container.selectAll("g")
				.data(sorted_ticks, function(d) { return d.type + "-" + d.value; });

			var tick_g_exit = tick_g.exit();

			tick_g_exit.transition()
				.duration(animation_duration)
				.attr("transform", function(d) { return xyToTranslate(exitingXScale(d.value), axis_y_position); })
				.style("opacity", 0)
				.remove();

			tick_g_exit.each(function() {
				var sel = select(this);
				// Tick lines
				sel.select("line")
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("y2", tick_length);
				// Tick labels
				sel.select("text")
					.style("fill", tick_label_color)
					.style("font-size", tick_label_size + "px")
					.style("font-weight", x.tick_label_weight)
					.attr("transform", tickLabelTransform)
					.transition()
					.duration(animation_duration);
			});

			var tick_g_enter = tick_g.enter().append("g")
				.style("opacity", 0);

			tick_g_enter
				.attr("transform", function(d) { return xyToTranslate(enteringXScale(d.value), axis_y_position_old); });

			tick_g_enter.each(function() {
				var sel = select(this);
				// Tick lines
				sel.append("line")
					.attr("y2", tick_length);
				// Tick labels
				sel.append("text").attr("text-anchor", "middle")
					.attr("transform", tickLabelTransform)
					.call(userSelectNone);
			});

			var tick_g_update = tick_g.merge(tick_g_enter);

			tick_g_update.transition()
				.duration(animation_duration)
				.style("opacity", 1)
				.attr("transform", function(d) { return xyToTranslate(xScale(d.value), axis_y_position); });

			var setTickOpacity = (function() {
				var placed_ticks = [];
				var y_anchor = axis_y_position + tick_label_distance;
				return function(d) {
					var x_anchor = xScale(d.value);
					if (pos === "float-below") {
						var range = xScale.range();
						if (state.y.axis_visible) {
							var left = x_anchor - d.box_width_left;
							if (left < range[0]) return 0;
						}
						if (state.y2.axis_visible) {
							var right = x_anchor + d.box_width_right;
							if (right > range[1]) return 0;
						}
					}
					var p1q1 = [ x_anchor, y_anchor ];
					var p2 = [ x_anchor + d.box_width_right, y_anchor + d.box_height_right];
					var q2 = [ x_anchor - d.box_width_left, y_anchor + d.box_height_left];
					var p = [ p1q1, p2 ];
					var q = [ p1q1, q2 ];
					for (var i = 0; i < placed_ticks.length; i++) {
						var placed_tick = placed_ticks[i];
						if (x_anchor <= placed_tick.x_anchor) {
							if (linesIntersect(p, placed_tick.q)) return 0;
						}
						else {
							if (linesIntersect(placed_tick.p, q)) return 0; // eslint-disable-line no-lonely-if
						}
					}
					placed_ticks.push({ x_anchor: x_anchor, p: p, q: q });
					return 1;
				};
			})();
			const read_direction = getDirectionAttribute();

			tick_g_update.each(function() {
				var sel = select(this);
				// Tick lines
				sel.select("line")
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("y2", tick_length);
				// Tick labels
				sel.select("text")
					.each(function() {
						var tspans = select(this).selectAll("tspan").data(function(d) { return d.lines; });
						tspans.merge(tspans.enter().append("tspan"))
							.attr("x", 0)
							.attr("dy", function(d, i) { return i ? x.tick_label_line_height + "em" : 0; })
							.text(function(d) { return d; });
						tspans.exit().remove();
					})
					.attr("text-anchor", read_direction === "rtl" ? "start" : "end")
					.style("fill", tick_label_color)
					.style("font-size", tick_label_size + "px")
					.style("font-weight", x.tick_label_weight)
					.transition()
					.duration(animation_duration)
					.style("opacity", setTickOpacity)
					.attr("transform", tickLabelTransform);
			});

			var title = title_container.selectAll("text")
				.data(show_this_axis && title_text ? [title_text] : []);

			title.exit().remove();

			title.enter().append("text")
				.attr("text-anchor", "middle")
				.style("font-size", title_size + "px")
				.style("fill", x.title_color)
				.style("font-weight", x.title_weight)
				.call(userSelectNone)
				.transition()
				.duration(0)
				.delay(animation_duration)
				.text(function(d) { return d; })
				.attr("x", x_mid)
				.attr("y", title_distance)
				.attr("dy", title_size);

			title.text(function(d) { return d; })
				.style("fill", x.title_color)
				.style("font-size", title_size + "px")
				.style("font-weight", x.title_weight)
				.transition()
				.duration(animation_duration)
				.attr("x", x_mid)
				.attr("y", title_distance)
				.attr("dy", title_size);

			y_bottom_old = y_bottom;

			return pos == "bottom" ? measurements : null;
		};
	})();

	var updateTopAxis = (function() {
		var top = instance.chart.select("g.fl-top-axis");
		var line_container = top.select("g.fl-axis-line");
		var tick_container = top.select("g.fl-axis-ticks");
		var title_container = top.select("g.fl-axis-title");
		var y_top_old;

		return function() {
			var pos = x.axis_position;
			var measurements = { pos: pos };
			var show_this_axis = (!instance.xHide() && ["top", "float-above"].indexOf(pos) !== -1);
			var ticks = show_this_axis ? instance.xTicks() : [];
			var y_top = instance.y_top;
			if (y_top_old === undefined) y_top_old = y_top;
			var title_distance = y_top - remToPx(x.title_padding);
			if (pos === "top") {
				title_distance -= tick_label_distance + ticks.max_box_height;
				measurements.extended_gridline = y_top - (tick_label_distance + ticks.max_box_height);
			}

			var axis_y_position_old = pos === "float-above" ? (oldYScale || yScale)(x.y_axis_position) : y_top_old;
			var axis_y_position = pos === "float-above" ? yScale(x.y_axis_position) : y_top;

			var line = line_container.selectAll("line")
				.data(show_this_axis && x.line_visible ? [xScale.domain()] : []);

			line.exit()
				.style("stroke", line_color)
				.style("stroke-width", line_width)
				.transition()
				.duration(animation_duration)
				.attr("x1", x_left)
				.attr("x2", x_right)
				.attr("y1", axis_y_position)
				.attr("y2", axis_y_position)
				.style("opacity", 0)
				.remove();

			var line_enter = line.enter()
				.append("line")
				.style("shape-rendering", "crispEdges")
				.style("stroke-linecap", "square")
				.style("stroke-width", line_width)
				.attr("x1", x_left_old)
				.attr("x2", x_left_old)
				.attr("y1", axis_y_position_old)
				.attr("y2", axis_y_position_old)
				.style("opacity", 0);

			line.merge(line_enter)
				.style("stroke", line_color)
				.style("stroke-width", line_width)
				.transition()
				.duration(animation_duration)
				.attr("x1", x_left)
				.attr("x2", x_right)
				.attr("y1", axis_y_position)
				.attr("y2", axis_y_position)
				.style("opacity", 1);

			var sorted_ticks = [];
			if (show_this_axis) {
				sorted_ticks = ticks.type === "numeric" ? ticks.slice().sort(tickSorter) : ticks;
			}

			var tickLabelTransform = function(d) {
				var angle = x.tick_label_position == "default" ? -x.tick_label_angle : -90;
				var rotate = angleToRotate(angle, 0, 0);
				if (x.tick_label_position !== "default") {
					var y_offset = x.tick_label_position === "left" ? -0.3 : 1;
					return xyToTranslate(0, -tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size * y_offset);
				}
				if (angle === 0) {
					return xyToTranslate(-d.text_width/2, -(tick_label_distance + tick_label_size*0.33));
				}
				else if (angle === -90) {
					return xyToTranslate(0, -tick_label_distance) + " " + rotate + " " + xyToTranslate(0, tick_label_size*0.33 - d.multiline_offset);
				}
				else {
					return xyToTranslate(0, -tick_label_distance) + " " + rotate + xyToTranslate(0, -d.multiline_offset); // + " " + xyToTranslate(0, tick_label_size*0.66);
				}
			};

			var tick_g = tick_container.selectAll("g")
				.data(sorted_ticks, function(d) { return d.type + "-" + d.value; });

			var tick_g_exit = tick_g.exit();

			tick_g_exit.transition()
				.duration(animation_duration)
				.attr("transform", function(d) { return xyToTranslate(exitingXScale(d.value), axis_y_position); })
				.style("opacity", 0)
				.remove();

			tick_g_exit.each(function() {
				var sel = select(this);
				// Tick lines
				sel.select("line")
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("y2", -tick_length);
				// Tick labels
				sel.select("text")
					.style("fill", tick_label_color)
					.style("font-size", tick_label_size + "px")
					.style("font-weight", x.tick_label_weight)
					.attr("transform", tickLabelTransform)
					.transition()
					.duration(animation_duration);
			});

			var tick_g_enter = tick_g.enter().append("g")
				.style("opacity", 0);

			tick_g_enter
				.attr("transform", function(d) { return xyToTranslate(enteringXScale(d.value), axis_y_position_old); });

			tick_g_enter.each(function() {
				var sel = select(this);
				// Tick lines
				sel.append("line")
					.attr("y2", -tick_length);
				// Tick labels
				sel.append("text").attr("text-anchor", "middle")
					.attr("transform", tickLabelTransform)
					.call(userSelectNone);
			});

			var tick_g_update = tick_g.merge(tick_g_enter);

			tick_g_update.transition()
				.duration(animation_duration)
				.style("opacity", 1)
				.attr("transform", function(d) { return xyToTranslate(xScale(d.value), axis_y_position); });

			var setTickOpacity = (function() {
				var placed_ticks = [];
				var y_anchor = axis_y_position + tick_label_distance;
				return function(d) {
					var x_anchor = xScale(d.value);
					if (pos === "float-above") {
						var range = xScale.range();
						if (state.y.axis_visible) {
							var left = x_anchor - d.box_width_left;
							if (left < range[0]) return 0;
						}
						if (state.y2.axis_visible) {
							var right = x_anchor + d.box_width_right;
							if (right > range[1]) return 0;
						}
					}
					var p1q1 = [ x_anchor, y_anchor ];
					var p2 = [ x_anchor - d.box_width_left, y_anchor - d.box_height_left];
					var q2 = [ x_anchor + d.box_width_right, y_anchor - d.box_height_right];
					var p = [ p1q1, p2 ];
					var q = [ p1q1, q2 ];
					for (var i = 0; i < placed_ticks.length; i++) {
						var placed_tick = placed_ticks[i];
						if (x_anchor <= placed_tick.x_anchor) {
							if (linesIntersect(q, placed_tick.p)) return 0;
						}
						else {
							if (linesIntersect(p, placed_tick.q)) return 0; // eslint-disable-line no-lonely-if
						}
					}
					placed_ticks.push({ x_anchor: x_anchor, p: p, q: q });
					return 1;
				};
			})();
			const read_direction = getDirectionAttribute();

			tick_g_update.each(function() {
				var sel = select(this);
				// Tick lines
				sel.select("line")
					.style("stroke", line_color)
					.style("stroke-width", line_width)
					.transition()
					.duration(animation_duration)
					.attr("y2", -tick_length);
				// Tick labels
				sel.select("text")
					.each(function() {
						var tspans = select(this).selectAll("tspan").data(function(d) { return d.lines; });
						tspans.merge(tspans.enter().append("tspan"))
							.attr("x", 0)
							.attr("dy", function(d, i) { return i ? x.tick_label_line_height + "em" : 0; })
							.text(function(d) { return d; });
						tspans.exit().remove();
					})
					.attr("text-anchor", read_direction === "rtl" ? "end" : "start")
					.style("fill", tick_label_color)
					.style("font-size", tick_label_size + "px")
					.style("font-weight", x.tick_label_weight)
					.transition()
					.duration(animation_duration)
					.style("opacity", setTickOpacity)
					.attr("transform", tickLabelTransform);
			});

			var title = title_container.selectAll("text")
				.data(show_this_axis && title_text ? [title_text] : []);

			title.exit().remove();

			title.enter().append("text")
				.attr("text-anchor", "middle")
				.style("font-size", title_size + "px")
				.style("fill", x.title_color)
				.style("font-weight", x.title_weight)
				.call(userSelectNone)
				.transition()
				.duration(0)
				.delay(animation_duration)
				.text(function(d) { return d; })
				.attr("x", x_mid)
				.attr("y", title_distance)
				.attr("dy", -0.33 * title_size);

			title.text(function(d) { return d; })
				.style("fill", x.title_color)
				.style("font-size", title_size + "px")
				.style("font-weight", x.title_weight)
				.transition()
				.duration(animation_duration)
				.attr("x", x_mid)
				.attr("y", title_distance)
				.attr("dy", -0.33 * title_size);

			y_top_old = y_top;

			return pos == "top" ? measurements : null;
		};
	})();

	return function() {
		setValues();
		var bottom = updateBottomAxis();
		var top = updateTopAxis();
		oldXScale = xScale;
		oldYScale = yScale;
		x_left_old = x_left;
		x_right_old = x_right;
		return bottom || top;
	};
}


export { initXAxisUpdating };
