import { remToPx, safeScale } from "../../common";

var DASH_ARRAYS = {
	solid: null,
	dash: [ 4, 1 ],
	dot: [ 1, 1 ],
	dot_dash: [4, 1, 1, 1]
};


function getDashArray(style) {
	if (style === "solid") return null;
	var multiplier = remToPx(1) / 4;
	return DASH_ARRAYS[style].map(function(d) { return d * multiplier; }).join(" ");
}


function initGridlineUpdating(instance, state) {
	var x = state.x;
	var y = state.y;
	var y2 = state.y2;
	var vertical = instance.chart.select("g.fl-gridlines-vertical");
	var horizontal = instance.chart.select("g.fl-gridlines-horizontal");
	var oldXScale, oldYScale, oldY2Scale;
	var x_left_old, x_right_old, y_bottom_old, y_top_old;

	return function(measurements) {
		var xScale = safeScale(instance.xScale());
		var yScale = safeScale(instance.yScale());
		var y2Scale = safeScale(instance.y2Scale());
		var x_left = instance.x_left;
		var x_right = instance.x_right;
		if (x_left_old === undefined) x_left_old = x_left;
		if (x_right_old === undefined) x_right_old = x_right;
		var y_bottom = instance.y_bottom;
		var y_top = instance.y_top;
		if (y_bottom_old === undefined) y_bottom_old = y_bottom;
		if (y_top_old === undefined) y_top_old = y_top;
		oldXScale = oldXScale || xScale;
		oldYScale = oldYScale || yScale;
		oldY2Scale = oldY2Scale || y2Scale;
		var enteringXScale = oldXScale.type === xScale.type && xScale.type !== "ordinal" ? oldXScale : xScale;
		var exitingXScale = oldXScale.type === xScale.type && oldXScale.type !== "ordinal" ? xScale : oldXScale;
		var enteringYScale = oldYScale.type === yScale.type && yScale.type !== "ordinal" ? oldYScale : yScale;
		var exitingYScale = oldYScale.type === yScale.type && oldYScale.type !== "ordinal" ? yScale : oldYScale;
		var enteringY2Scale = oldY2Scale.type === y2Scale.type && oldY2Scale.type !== "ordinal" ? oldY2Scale : y2Scale;
		var exitingY2Scale = oldY2Scale.type === y2Scale.type && oldY2Scale.type !== "ordinal" ? y2Scale : oldY2Scale;

		var animation_duration = oldXScale ? instance.animationDuration() : 0;

		var getTicksForGridlines = function(axis) {
			// If the user has switched the whole axis off don't return any ticks
			if (axis === "x" && state.x.axis_position === "off") return [];
			else if (axis !== "x" && !state[axis].axis_visible) return [];
			// If the user has switched gridlines off don't return any ticks
			if (!state[axis].gridlines_visible) return [];
			var hide = instance[axis + "Hide"]();
			// If the developer has switched gridlines off don't return any ticks
			if (hide && !hide.keep_gridlines) return [];
			// Else return array of tick objects
			return instance[axis + "Ticks"]();
		};

		var x_ticks = getTicksForGridlines("x");
		var y_ticks = getTicksForGridlines("y");
		var y2_ticks = getTicksForGridlines("y2");

		var v_data = x_ticks.map(function(d) {
			return {
				type: d.type,
				value: d.value,
				dasharray: getDashArray(x.gridline_style),
				stroke: x.gridline_color,
				width: remToPx(x.gridline_width, true),
				x_enter: enteringXScale(d.value),
				x: xScale(d.value),
			};
		});


		if (x.gridline_category_dividers && xScale.step) {
			var x_step = xScale.step();
			v_data.pop();
			v_data.forEach(function(gridline) {
				gridline.x_enter += x_step/2;
				gridline.x += x_step/2;
				if (x.gridline_category_dividers_extend) {
					var extend_top = measurements.x && measurements.x.pos == "top",
					    extend_bottom = measurements.x && measurements.x.pos == "bottom";
					if (extend_top) gridline.y2 = measurements.x.extended_gridline;
					else if (extend_bottom) gridline.y1 = measurements.x.extended_gridline;
				}
			});
		}

		var y_data = y_ticks.map(function(d) {
			return {
				axis: "y",
				type: d.type,
				value: d.value,
				dasharray: getDashArray(y.gridline_style),
				stroke: y.gridline_color,
				width: remToPx(y.gridline_width, true),
				y_enter: enteringYScale(d.value),
				y: yScale(d.value),
			};
		});

		if (y.gridline_category_dividers && yScale.step) {
			var y_step = yScale.step();
			y_data.pop();
			y_data.forEach(function(gridline) {
				gridline.y_enter -= y_step/2;
				gridline.y -= y_step/2;
				if (y.gridline_category_dividers_extend) {
					gridline.x1 = measurements.y.extended_gridline;
				}
			});
		}

		var y2_data = y2_ticks.map(function(d) {
			return {
				axis: "y2",
				type: d.type,
				value: d.value,
				dasharray: getDashArray(y2.gridline_style),
				stroke: y2.gridline_color,
				width: remToPx(y2.gridline_width),
				y_enter: enteringY2Scale(d.value),
				y: y2Scale(d.value),
			};
		});

		if (y2.gridline_category_dividers && y2Scale.step) {
			var y2_step = y2Scale.step();
			y2_data.pop();
			y2_data.forEach(function(gridline) {
				gridline.y_enter -= y2_step/2;
				gridline.y -= y2_step/2;
				if (y2.gridline_category_dividers_extend) {
					gridline.x2 = measurements.y2.extended_gridline;
				}
			});
		}

		var h_data = y_data.concat(y2_data);

		var vertical_lines = vertical.selectAll("line")
			.data(v_data, function(d) { return d.type + "-" + d.value; });

		vertical_lines.exit()
			.attr("stroke-dasharray", function(d) { return d.dasharray; })
			.style("stroke", function(d) { return d.stroke; })
			.style("stroke-width", function(d) { return d.width; })
			.transition()
			.duration(animation_duration)
			.attr("x1", function(d) { return exitingXScale(d.value); })
			.attr("x2", function(d) { return exitingXScale(d.value); })
			.attr("y1", y_bottom)
			.attr("y2", y_top)
			.style("opacity", 0)
			.remove();

		var vertical_lines_enter = vertical_lines.enter().append("line")
			.style("shape-rendering", "crispEdges")
			.attr("x1", function(d) { return d.x_enter; })
			.attr("x2", function(d) { return d.x_enter; })
			.attr("y1", y_bottom_old)
			.attr("y2", y_top_old)
			.style("opacity", 0);

		vertical_lines.merge(vertical_lines_enter)
			.attr("stroke-dasharray", function(d) { return d.dasharray; })
			.style("stroke", function(d) { return d.stroke; })
			.style("stroke-width", function(d) { return d.width; })
			.transition()
			.duration(animation_duration)
			.attr("x1", function(d) { return d.x; })
			.attr("x2", function(d) { return d.x; })
			.attr("y1", y_bottom)
			.attr("y2", y_top)
			.style("opacity", 1);

		var horizontal_lines = horizontal.selectAll("line")
			.data(h_data, function(d) { return d.axis + "-" + d.type + "-" + d.value; });

		horizontal_lines.exit()
			.attr("stroke-dasharray", function(d) { return d.dasharray; })
			.style("stroke", function(d) { return d.stroke; })
			.style("stroke-width", function(d) { return d.width; })
			.transition()
			.duration(animation_duration)
			.attr("x1", x_left)
			.attr("x2", x_right)
			.attr("y1", function(d) { return d.axis === "y" ? exitingYScale(d.value) : exitingY2Scale(d.value); })
			.attr("y2", function(d) { return d.axis === "y" ? exitingYScale(d.value) : exitingY2Scale(d.value); })
			.style("opacity", 0)
			.remove();

		var horizontal_lines_enter = horizontal_lines.enter().append("line")
			.style("shape-rendering", "crispEdges")
			.attr("x1", x_left_old)
			.attr("x2", x_right_old)
			.attr("y1", function(d) { return d.y_enter; })
			.attr("y2", function(d) { return d.y_enter; })
			.style("opacity", 0);

		horizontal_lines.merge(horizontal_lines_enter)
			.attr("stroke-dasharray", function(d) { return d.dasharray; })
			.style("stroke", function(d) { return d.stroke; })
			.style("stroke-width", function(d) { return d.width; })
			.transition()
			.duration(animation_duration)
			.attr("x1", x_left)
			.attr("x2", x_right)
			.attr("y1", function(d) { return d.y; })
			.attr("y2", function(d) { return d.y; })
			.style("opacity", 1);

		oldXScale = xScale;
		oldYScale = yScale;
		oldY2Scale = y2Scale;
		x_left_old = x_left;
		x_right_old = x_right;
	};
}


export { initGridlineUpdating };
