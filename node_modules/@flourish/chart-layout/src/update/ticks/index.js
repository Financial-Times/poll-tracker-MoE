import { isDate, isValidDate, textareaToArray } from "../../common";


function removeDuplicates(arr) {
	if (!arr.length) return arr.slice();

	// For datetimes we must convert datetime objects to timestamps before removing duplicates
	// Then we must convert timestamps back to date objects
	if (isDate(arr[0])) {
		return Array.from(new Set(arr.map(d => d.getTime()))).map(d => new Date(d));
	}

	return Array.from(new Set(arr));
}


function getTickValues(instance, state, axis = "x") {
	const axis_state = state[axis];
	const scale = instance[axis + "Scale"]({ "domain_only": true });
	const data = instance[axis + "Data"]();
	let ticks;
	const ticks_hidden = axis === "x" ? axis_state.axis_position === "off" : !axis_state.axis_visible;

	if (ticks_hidden) ticks = [];
	else if (data.string_array) ticks = scale.domain();
	else if (axis_state.tick_mode === "number") ticks = scale.ticks(axis_state.tick_number);
	else {
		let tick_list;
		const is_datetime = data.datetime_array;
		if (axis_state.tick_mode === "custom") {
			const parser_name = axis + (is_datetime ? "Datetime" : "Number") + "Parse";
			const parser = instance[parser_name]();
			tick_list = textareaToArray(axis_state.tick_custom).map(d => parser(d));
		}
		else {
			const auto = instance[axis + "AutoTicks"]();
			tick_list = Array.isArray(auto) ? auto : auto();
		}
		tick_list = removeDuplicates(tick_list);
		const domain = scale.domain();
		const min = Math.min(...domain);
		const max = Math.max(...domain);
		if (is_datetime) ticks = tick_list.filter(d => isValidDate(d) && d >= min && d <= max);
		else ticks = tick_list.filter(d => !isNaN(d) && d >= min && d <= max);
	}

	return ticks;
}


function initTickUpdating(instance, state) {
	var updateXTicks = function() {
		instance.xTicks._update(getTickValues(instance, state, "x"));
	};

	var updateYTicks = function() {
		instance.yTicks._update(getTickValues(instance, state, "y"));
	};

	var updateY2Ticks = function() {
		instance.y2Ticks._update(getTickValues(instance, state, "y2"));
	};

	return function() {
		updateXTicks();
		updateYTicks();
		updateY2Ticks();
	};
}


export { initTickUpdating };
