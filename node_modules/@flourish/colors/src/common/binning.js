import { scaleQuantize, scaleQuantile, scaleThreshold } from "d3-scale";

export function binnedScale(state, domain, values, interpolator) {
	var domain_min = domain[0];
	var domain_max = domain[domain.length - 1];
	var centers = [], thresholds, n;

	if (state.bin_mode == "custom") {
		thresholds = state.bin_thresholds
			.split(";")
			.map(parseFloat)
			.filter(function (val) {
				if (isNaN(val)) return false;
				return val > domain_min && val < domain_max;
			})
			.sort(ascendingSort);
		n = thresholds.length + 1;
	}
	else {
		n = Math.floor(state.bin_count);
		thresholds = [];
	}

	var palette = interpolatePalette(interpolator, n, domain);
	var scale;
	if (state.bin_mode == "fixed") scale = scaleQuantize().domain([domain_min, domain_max]);
	else if (state.bin_mode == "quantile") scale = scaleQuantile().domain(values);
	else scale = scaleThreshold().domain(thresholds);
	scale.range(palette.colors);

	if (!thresholds.length) {
		palette.colors.forEach(function (color, i) {
			if (i) thresholds.push(scale.invertExtent(color)[0]);
		});
	}

	thresholds.forEach(function (threshold, i) {
		if (i < (thresholds.length - 1)) centers.push((thresholds[i + 1] + threshold) / 2);
	});

	var colorScale = function (value) {
		return !isNaN(value) ? scale(value) : null;
	};

	colorScale.domain = Object.freeze(domain);
	colorScale.thresholds = Object.freeze(thresholds);
	colorScale.centers = Object.freeze(centers);

	return colorScale;
}

function interpolatePalette(interpolator, n, domain) {
	var step = 1 / n;
	var positions = [];
	for (var i = 0; i < n; i++) {
		var pos = i / n + step / 2;
		var val = domain[0] + pos * (domain[domain.length - 1] - domain[0]);
		positions.push(val);
	}
	var colors = positions.map(interpolator);
	return { positions: positions, colors: colors };
}

function ascendingSort(a, b) { return a - b; }
