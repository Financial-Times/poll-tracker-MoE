(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.enhanced_arrays = {}));
}(this, (function (exports) { 'use strict';

	function getUniqueValues(arr) {
		var uniq_arr = [];
		var uniq_obj = {};
		arr.forEach(function(d) {
			if (uniq_obj[d]) return;
			uniq_arr.push(d);
			uniq_obj[d] = true;
		});
		return uniq_arr;
	}

	var isArray = Array.isArray;

	function identity(x) {
		return x;
	}

	function createAdder(obj) {
		var prop = function(name, value) {
			Object.defineProperty(obj, name, { value: value, enumerable: true });
		};

		var getter = function(name, func) {
			Object.defineProperty(obj, name, { get: func, enumerable: true });
		};

		var method = function(name, func) {
			Object.defineProperty(obj, name, { value: func });
		};

		return {
			prop: prop,
			getter: getter,
			method: method
		};
	}

	// 1 2 2 4
	function best(sorted_values, lowest_first) {
		var reducer = lowest_first ? "reduce" : "reduceRight";
		var rank = 1;
		return sorted_values[reducer](function(lookup, d) {
			if (!lookup[d]) lookup[d] = rank;
			rank += 1;
			return lookup;
		}, {});
	}

	// 1 3 3 4
	function worst(sorted_values, lowest_first) {
		var reducer = lowest_first ? "reduce" : "reduceRight";
		var rank = 1;
		return sorted_values[reducer](function(lookup, d) {
			lookup[d] = rank++;
			return lookup;
		}, {});
	}

	// 1 2 2 3
	function dense(sorted_values, lowest_first) {
		var reducer = lowest_first ? "reduce" : "reduceRight";
		var rank = 1;
		return sorted_values[reducer](function(lookup, d) {
			if (!lookup[d]) lookup[d] = rank++;
			return lookup;
		}, {});
	}

	// 1 2.5 2.5 4
	function fractional(sorted_values, lowest_first) {
		var ll = best(sorted_values, lowest_first);
		var hl = worst(sorted_values, lowest_first);
		return Object.keys(ll).reduce(function(obj, key) {
			obj[key] = (ll[key] + hl[key]) / 2;
			return obj;
		}, {});
	}


	function rank(unsorted_values, sorted_values, lowest_first, ties_method) {
		var lookup;
		if (ties_method === "dense") lookup = dense(sorted_values, lowest_first);
		else if (ties_method === "fractional") lookup = fractional(sorted_values, lowest_first);
		else if (ties_method === "worst") lookup = worst(sorted_values, lowest_first);
		else lookup = best(sorted_values, lowest_first);

		var mapFunc = function(d) { return lookup[d]; };
		// ties_method ordinal (1 2 3 4) uses lowest lookup but then modifies it in place
		if (ties_method === "ordinal") mapFunc = function(d) { return lookup[d]++; };

		return unsorted_values.map(mapFunc);
	}

	function getRandomIntegerGenerator(nextRandom) {
		nextRandom = nextRandom || Math.random;
		return function(first, last) {
			var n = (last - first) + 1;
			return Math.floor(nextRandom() * n) + first;
		};
	}


	function randomFromArray(values, nextRandom) {
		var index = getRandomIntegerGenerator(nextRandom)(0, values.length-1);
		return values[index];
	}


	function sampleArray(values, n_samples, replace, nextRandom) {
		var n_points = values.length;
		replace = n_samples !== undefined ? replace : false;
		n_samples = n_samples !== undefined ? Math.floor(n_samples) : n_points;

		if (!n_points || n_samples < 1) return [];

		var out;
		var getRandomInteger = getRandomIntegerGenerator(nextRandom);

		if (replace || n_samples === 1) {
			out = [];
			for (var i = 0; i < n_samples; i++) {
				out.push(values[getRandomInteger(0, n_points - 1)]);
			}
			return out;
		}

		out = values.slice();
		var n = Math.min(n_points, n_samples);

		for (var i = 0; i < n; i++) {
			var pick_index = getRandomInteger(i, n_points - 1);
			if (pick_index === i) continue;
			var pick = out[pick_index];
			var temp = out[i];
			out[i] = pick;
			out [pick_index] = temp;
		}

		out.length = n;

		return out;
	}

	function uncleanArray(dataset, dropped_indexes, dirty_value) {
		if (!dropped_indexes.length) return dataset.slice();

		var counter = 0;
		var unclean_data = dataset.reduce(function(arr, d) {
			while (arr.length === dropped_indexes[counter]) {
				arr.push(dirty_value);
				counter++;
			}
			arr.push(d);
			return arr;
		}, []);
		while (dropped_indexes[counter++]) unclean_data.push(dirty_value);

		return unclean_data;
	}

	function addSorting(add) {
		add.method("unsorted", function() { return this.values.slice(); });
		add.method("ascending", function() { return this.sorted_values.slice(); });
		add.method("descending", function() { return this.sorted_values.slice().reverse(); });
		add.method("unique", function() { return getUniqueValues(this.values); });
		add.method("uniqueAscending", function() { return getUniqueValues(this.sorted_values); });
		add.method("uniqueDescending", function() { return getUniqueValues(this.sorted_values).reverse(); });
	}

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);

	function number(x) {
	  return x === null ? NaN : +x;
	}

	function d3_variance(values, valueof) {
	  var n = values.length,
	      m = 0,
	      i = -1,
	      mean = 0,
	      value,
	      delta,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  if (m > 1) return sum / (m - 1);
	}

	function d3_quantile(values, p, valueof) {
	  if (valueof == null) valueof = number;
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	}

	function quantiles(sorted_data, vals) {
		if (!isArray(vals)) return d3_quantile(sorted_data, vals);
		return vals.map(function(d) { return d3_quantile(sorted_data, d); });
	}


	function addSummaries(add) {
		var variance = function() {
			return d3_variance(this.values);
		};

		var sd = function() {
			return Math.sqrt(this.variance);
		};

		var quartiles = function() {
			return quantiles(this.sorted_values, [ 0.25, 0.5, 0.75 ]);
		};

		var median = function() {
			return quantiles(this.sorted_values, 0.5);
		};

		var iqr = function() {
			var iq = quantiles(this.sorted_values, [ 0.25, 0.75 ]);
			return iq[1] - iq[0];
		};

		add.getter("variance", variance);
		add.getter("sd", sd);
		add.getter("median", median);
		add.getter("iqr", iqr);
		add.method("quantiles", function(vals) { return quantiles(this.sorted_values, vals); });
		add.method("quartiles", quartiles);
	}

	function addSampling(add) {
		add.method("random", function(nextRandom) {
			return randomFromArray(this.values, nextRandom);
		});

		add.method("sample", function(n_samples, replace, nextRandom) {
			return sampleArray(this.values, n_samples, replace, nextRandom);
		});
	}

	function addRanking(add) {
		add.method("rank", function(lowest_first, ties_method) {
			return rank(this.values, this.sorted_values, lowest_first, ties_method);
		});
	}

	function addUncleaning(add) {
		add.method("unclean", function(dataset) {
			if (dataset && dataset.length < this.values.length) throw new RangeError("dataset is too short");
			if (dataset && dataset.length > this.values.length) throw new RangeError("dataset is too long");
			dataset = dataset || this.values;
			return uncleanArray(dataset, this.dropped_indexes, NaN);
		});
	}

	function isLatitude(value) { return value >= -90 && value <= 90; }
	function isLongitude(value) { return value >= -180 && value <= 180; }


	function getScore(instance, func, predicate_mode) {
		if (!instance.length) return null;
		if (predicate_mode) return func(instance.min) && func(instance.max) ? 1 : 0;
		return instance.values.reduce(function(count, value) { return count + func(value); }, 0) / instance.length;
	}


	function addGeographic(add) {
		add.method("latitudeScore", function(predicate_mode) {
			return getScore(this, isLatitude, predicate_mode);
		});

		add.method("longitudeScore", function(predicate_mode) {
			return getScore(this, isLongitude, predicate_mode);
		});
	}

	function init() {
		var proto = {};
		var add = createAdder(proto);
		addSorting(add);
		addSummaries(add);
		addSampling(add);
		addRanking(add);
		addUncleaning(add);
		addGeographic(add);
		return proto;
	}

	function isAscending(arr) {
		var prev = -Infinity;
		return arr.every(function(d) {
			if (d >= prev) {
				prev = d;
				return true;
			}
		});
	}

	function isDescending(arr) {
		var prev = Infinity;
		return arr.every(function(d) {
			if (d <= prev) {
				prev = d;
				return true;
			}
		});
	}

	function init$1(obj, input_data, accessor) {
		accessor = accessor || identity;

		var min = Infinity;
		var max = -Infinity;
		var sorted_values = null;
		var sum = 0;
		var dropped_indexes = [];

		var values = Object.freeze(input_data.reduce(function(arr, d, i) {
			var value = accessor(d);
			if (typeof value === "number" && !isNaN(value)) {
				arr.push(value);
				min = Math.min(min, value);
				max = Math.max(max, value);
				sum += value;
			}
			else dropped_indexes.push(i);
			return arr;
		}, []));

		var add = createAdder(obj);

		add.prop("enhanced_array", true);
		add.prop("numeric_array", true);
		add.prop("values", values);
		add.prop("min", values.length ? min : null);
		add.prop("max", values.length ? max : null);
		add.prop("sum", sum);
		add.prop("mean", values.length ? sum / values.length : null);
		add.prop("range", values.length ? max - min : null);
		add.prop("length", values.length);
		add.prop("dropped_indexes", Object.freeze(dropped_indexes));
		add.method("extent", function() { return [this.min, this.max]; });

		add.getter("sorted_values", function() {
			if (!sorted_values) {
				if (isAscending(values)) sorted_values = values;
				if (isDescending(values)) sorted_values = Object.freeze(values.slice().reverse());
				else sorted_values = Object.freeze(values.slice().sort(ascending));
			}
			return sorted_values;
		});

		return obj;
	}

	var proto = init();

	function init$2(input_data, accessor) {
		var obj = Object.create(proto);
		init$1(obj, input_data, accessor);
		return obj;
	}

	var PROPS_TO_STEAL = Object.freeze([ "min", "max", "mean" ]);

	var METHODS_TO_STEAL = Object.freeze([
		"extent",
		"random", "sample",
		"unsorted", "ascending", "descending", "unique", "uniqueAscending", "uniqueDescending",
		"quartiles", "quantiles",
		"unclean"
	]);


	function isValidDate(entity) {
		return Object.prototype.toString.call(entity) === "[object Date]" && !isNaN(entity.getTime());
	}


	function numberToDate(num) {
		if (typeof num !== "number") return null;
		return new Date(num);
	}


	function _stealMethod(numeric_array, method) {
		return function() {
			var res = numeric_array[method].apply(numeric_array, arguments);
			return Array.isArray(res) ? res.map(numberToDate) : numberToDate(res);
		};
	}


	function init$3(obj, input_data, accessor) {
		accessor = accessor || identity;

		var numeric_array = init$2(
			input_data.map(function(d) {
				var dt = accessor(d);
				return isValidDate(dt) ? dt.getTime(): null;
			})
		);

		var add = createAdder(obj);

		add.prop("enhanced_array", true);
		add.prop("datetime_array", true);
		add.getter("values", function() { return Object.freeze(numeric_array.values.map(numberToDate)); });
		add.getter("sorted_values", function() { return Object.freeze(numeric_array.sorted_values.map(numberToDate)); });
		add.getter("median", function() { return numberToDate(numeric_array.median); });
		add.prop("length", numeric_array.values.length);
		add.prop("dropped_indexes", numeric_array.dropped_indexes);
		add.method("rank", function() { return numeric_array.rank(arguments); });

		var stealMethod = _stealMethod.bind(null, numeric_array);
		PROPS_TO_STEAL.forEach(function(prop) { add.prop(prop, numberToDate(numeric_array[prop])); });
		METHODS_TO_STEAL.forEach(function(method) { add.method(method, stealMethod(method)); });

		return obj;
	}

	// import initProto from "./proto";

	// var proto = initProto();

	function init$4(input_data, accessor) {
		var obj = {}; // Object.create(proto);
		init$3(obj, input_data, accessor);
		return obj;
	}

	function addSorting$1(add) {
		add.method("unsorted", function() { return this.values.slice(); });
		add.method("ascending", function() { return this.sorted_values.slice(); });
		add.method("descending", function() { return this.sorted_values.slice().reverse(); });
		add.method("unique", function() { return getUniqueValues(this.values); });
		add.method("uniqueAscending", function() { return getUniqueValues(this.sorted_values); });
		add.method("uniqueDescending", function() { return getUniqueValues(this.sorted_values).reverse(); });
	}

	function addSampling$1(add) {
		add.method("random", function(nextRandom) {
			return randomFromArray(this.values, nextRandom);
		});

		add.method("sample", function(n_samples, replace, nextRandom) {
			return sampleArray(this.values, n_samples, replace, nextRandom);
		});
	}

	function addRanks(add) {
		add.method("rank", function(lowest_first, ties_method) {
			return rank(this.values, this.sorted_values, lowest_first, ties_method);
		});
	}

	function addUncleaning$1(add) {
		add.method("unclean", function(dataset) {
			if (dataset && dataset.length < this.values.length) throw new RangeError("dataset is too short");
			if (dataset && dataset.length > this.values.length) throw new RangeError("dataset is too long");
			dataset = dataset || this.values;
			return uncleanArray(dataset, this.dropped_indexes);
		});
	}

	function init$5() {
		var proto = {};
		var add = createAdder(proto);
		addSorting$1(add);
		addSampling$1(add);
		addRanks(add);
		addUncleaning$1(add);
		return proto;
	}

	function isAscending$1(arr) {
		if (arr.length < 2) return true;
		var prev = arr[0];
		return arr.every(function(d) {
			if (d >= prev) {
				prev = d;
				return true;
			}
		});
	}

	function isDescending$1(arr) {
		if (arr.length < 2) return true;
		var prev = arr[0];
		return arr.every(function(d) {
			if (d <= prev) {
				prev = d;
				return true;
			}
		});
	}

	function init$6(obj, input_data, accessor) {
		accessor = accessor || identity;

		var sorted_values = null;
		var dropped_indexes = [];
		var n_empty = 0;

		var min = null;
		var i = 0;
		while (min === null && i < input_data.length) {
			var val = accessor(input_data[i++]);
			if (typeof val === "string") min = val;
		}
		var max = min;

		var values = Object.freeze(input_data.reduce(function(arr, d, i) {
			var value = accessor(d);
			if (typeof value === "string") {
				arr.push(value);
				min = value < min ? value : min;
				max = value > max ? value : max;
				if (!value) n_empty++;
			}
			else dropped_indexes.push(i);
			return arr;
		}, []));

		var add = createAdder(obj);

		add.prop("enhanced_array", true);
		add.prop("string_array", true);
		add.prop("values", values);
		add.prop("min", min);
		add.prop("max", max);
		add.prop("length", values.length);
		add.prop("dropped_indexes", Object.freeze(dropped_indexes));
		add.prop("n_empty", n_empty);
		add.method("extent", function() { return [this.min, this.max]; });

		add.getter("sorted_values", function() {
			if (!sorted_values) {
				if (isAscending$1(values)) sorted_values = values;
				if (isDescending$1(values)) sorted_values = Object.freeze(values.slice().reverse());
				else sorted_values = Object.freeze(values.slice().sort());
			}
			return sorted_values;
		});

		return obj;
	}

	var proto$1 = init$5();

	function init$7(input_data, accessor) {
		var obj = Object.create(proto$1);
		init$6(obj, input_data, accessor);
		return obj;
	}

	exports.createDatetimeArray = init$4;
	exports.createNumericArray = init$2;
	exports.createStringArray = init$7;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
