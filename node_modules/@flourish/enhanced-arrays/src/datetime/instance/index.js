import { createAdder, identity } from "../../common";
import createNumericArray from "../../numeric";

var PROPS_TO_STEAL = Object.freeze([ "min", "max", "mean" ]);

var METHODS_TO_STEAL = Object.freeze([
	"extent",
	"random", "sample",
	"unsorted", "ascending", "descending", "unique", "uniqueAscending", "uniqueDescending",
	"quartiles", "quantiles",
	"unclean"
]);


function isValidDate(entity) {
	return Object.prototype.toString.call(entity) === "[object Date]" && !isNaN(entity.getTime());
}


function numberToDate(num) {
	if (typeof num !== "number") return null;
	return new Date(num);
}


function _stealMethod(numeric_array, method) {
	return function() {
		var res = numeric_array[method].apply(numeric_array, arguments);
		return Array.isArray(res) ? res.map(numberToDate) : numberToDate(res);
	};
}


function init(obj, input_data, accessor) {
	accessor = accessor || identity;

	var numeric_array = createNumericArray(
		input_data.map(function(d) {
			var dt = accessor(d);
			return isValidDate(dt) ? dt.getTime(): null;
		})
	);

	var add = createAdder(obj);

	add.prop("enhanced_array", true);
	add.prop("datetime_array", true);
	add.getter("values", function() { return Object.freeze(numeric_array.values.map(numberToDate)); });
	add.getter("sorted_values", function() { return Object.freeze(numeric_array.sorted_values.map(numberToDate)); });
	add.getter("median", function() { return numberToDate(numeric_array.median); });
	add.prop("length", numeric_array.values.length);
	add.prop("dropped_indexes", numeric_array.dropped_indexes);
	add.method("rank", function() { return numeric_array.rank(arguments); });

	var stealMethod = _stealMethod.bind(null, numeric_array);
	PROPS_TO_STEAL.forEach(function(prop) { add.prop(prop, numberToDate(numeric_array[prop])); });
	METHODS_TO_STEAL.forEach(function(method) { add.method(method, stealMethod(method)); });

	return obj;
}


export default init;
