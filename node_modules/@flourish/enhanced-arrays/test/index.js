const { expect } = require("chai");
const { quantile, variance, deviation: sd, median } = require("d3-array");
const { createNumericArray } = require("../enhanced-arrays");
const { sortAscending, sortDescending, reverse, arrayMin, arrayMax, arraySum } = require("./utils");


const a0 = [];
const a1 = [1, 3, 2, 7, 7, 5.5, 3, 1];
const a2 = [3, 20, 130];
const a3 = [1000, 800, 70];
const a4 = a1.map(d => d.toString());
const a5 = [{x: 7, y: 2}, {y: 4}, {a: 4, x: 12}, {x: NaN}, {x: "3"}];


describe("For a numeric enhanced array", () => {
	// ---- Instance ---- //
	describe("the values getter", () => {
		it("should return the unsorted numeric values stored in the object", () => {
			const test = function(arr, comp, func) { expect(createNumericArray(arr, func).values).to.deep.equal(comp); };
			test(a0, a0);
			test(a1, a1);
			test(a2, a2);
			test(a3, a3);
			test(a4, []);
			test(a4, a1, d => parseFloat(d));
			test(a5, [7, 12], d => d.x);
			test(a5, [7, 12, 3], d => parseFloat(d.x));
		});
	});

	describe("the sorted_values getter", () => {
		it("should return the sorted numeric values stored in the object", () => {
			const test = function(arr, comp, func) { expect(createNumericArray(arr, func).sorted_values).to.deep.equal(comp); };
			test(a0, a0);
			test(a1, sortAscending(a1));
			test(a2, a2);
			test(a3, reverse(a3));
			test(a4, sortAscending(a1), d => parseFloat(d));
			test(a5, [3, 7, 12], d => parseFloat(d.x));
		});
	});

	describe("the length property", () => {
		it("should return the length of the values array", () => {
			const test = function(arr, comp, func) { expect(createNumericArray(arr, func).length).to.equal(comp); };
			test(a0, a0.length);
			test(a1, a1.length);
			test(a2, a2.length);
			test(a3, a3.length);
			test(a4, 0);
			test(a4, a4.length, d => parseFloat(d));
			test(a5, 2, d => d.x);
			test(a5, 3, d => parseFloat(d.x));
		});
	});

	describe("the dropped_indexes getter", () => {
		it("should return an array with values corresponding to the indexes of the original array that were dropped", () => {
			const test = function(arr, comp, func) { expect(createNumericArray(arr, func).dropped_indexes).to.deep.equal(comp); };
			test(a0, []);
			test(a1, []);
			test(a2, []);
			test(a3, []);
			test(a4, a4.map((d, i) => i));
			test(a4, [], d => parseFloat(d));
			test(a5, [1, 3, 4], d => d.x);
			test(a5, [1, 3], d => parseFloat(d.x));
		});
	});

	[{x: 7, y: 2}, {y: 4}, {a: 4, x: 12}, {x: NaN}, {x: "3"}];

	describe("the enhanced_array property", () => {
		it("should be true", () => {
			const test = function(arr) { expect(createNumericArray(arr).enhanced_array).to.equal(true); };
			test(a0);
			test(a1);
		});
	});

	describe("the numeric_array property", () => {
		it("should be true", () => {
			const test = function(arr) { expect(createNumericArray(arr).numeric_array).to.equal(true); };
			test(a0);
			test(a1);
		});
	});

	describe("the min property", () => {
		it("should equal the mimimum value in the array (null if empty)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).min).to.equal(comp); };
			test(a0, null);
			test(a1, arrayMin(a1));
			test(a2, arrayMin(a2));
			test(a3, arrayMin(a3));
		});
	});

	describe("the max property", () => {
		it("should equal the maximum value in the array (null if empty)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).max).to.equal(comp); };
			test(a0, null);
			test(a1, arrayMax(a1));
			test(a2, arrayMax(a2));
			test(a3, arrayMax(a3));
		});
	});

	describe("the range property", () => {
		it("should equal the difference between max and min values (null if empty)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).range).to.equal(comp); };
			test(a0, null);
			test(a1, arrayMax(a1) - arrayMin(a1));
			test(a2, arrayMax(a2) - arrayMin(a2));
			test(a3, arrayMax(a3) - arrayMin(a3));
		});
	});

	describe("the extent method", () => {
		it("should give an array of min and max values (or nulls if empty)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).extent()).to.deep.equal(comp); };
			test(a0, [null, null]);
			test(a1, [arrayMin(a1), arrayMax(a1)]);
			test(a2, [arrayMin(a2), arrayMax(a2)]);
			test(a3, [arrayMin(a3), arrayMax(a3)]);
		});
	});

	describe("the sum property", () => {
		it("should be the sum of the values in the array (0 if empty)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).sum).to.equal(comp); };
			test(a0, 0);
			test(a1, arraySum(a1));
			test(a2, arraySum(a2));
			test(a3, arraySum(a3));
		});
	});

	describe("the mean property", () => {
		it("should be the mean of the values in the array (or null if empty)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).mean).to.equal(comp); };
			test(a0, null);
			test(a1, arraySum(a1) / a1.length);
			test(a2, arraySum(a2) / a2.length);
			test(a3, arraySum(a3) / a3.length);
		});
	});

	// ---- Sorting ---- //
	describe("the unsorted method", () => {
		it("should return an unsorted array of values that isn't identical to the values array", () => {
			const test = function(arr) {
				var ea = createNumericArray(arr);
				expect(ea.unsorted()).to.deep.equal(ea.values);
				expect(ea.unsorted() === ea.values).to.equal(false);
			};
			test(a0);
			test(a1);
			test(a2);
			test(a3);
		});
	});

	describe("the ascending method", () => {
		it("should return a sorted array of values that isn't identical to the sorted_values array", () => {
			const test = function(arr) {
				var ea = createNumericArray(arr);
				expect(ea.ascending()).to.deep.equal(ea.sorted_values);
				expect(ea.ascending() === ea.sorted_values).to.equal(false);
			};
			test(a0);
			test(a1);
			test(a2);
			test(a3);
		});
	});

	describe("the descending method", () => {
		it("should return an array sorted from highest to lowest", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).descending()).to.deep.equal(comp); };
			test(a0, sortDescending(a0));
			test(a1, sortDescending(a1));
			test(a2, sortDescending(a2));
			test(a3, sortDescending(a3));
		});
	});

	describe("the unique method", () => {
		it("should return an unsorted array of unique values", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).unique()).to.deep.equal(comp); };
			test(a0, a0);
			test(a1, [...new Set(a1)]);
			test(a2, a2);
			test(a3, a3);
		});
	});

	describe("the uniqueAscending method", () => {
		it("should return an array of unique values in ascending order", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).uniqueAscending()).to.deep.equal(comp); };
			test(a0, a0);
			test(a1, sortAscending([...new Set(a1)]));
			test(a2, a2);
			test(a3, reverse(a3));
		});
	});

	describe("the uniqueDescending method", () => {
		it("should return an array of unique values in descending order", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).uniqueDescending()).to.deep.equal(comp); };
			test(a0, a0);
			test(a1, sortDescending([...new Set(a1)]));
			test(a2, reverse(a2));
			test(a3, a3);
		});
	});

	// ---- Summaries ---- //
	describe("the variance getter", () => {
		it("should give the variance of the values in the array (or undefined if empty)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).variance).to.equal(comp); };
			test(a0, undefined);
			test(a1, variance(a1));
			test(a2, variance(a2));
			test(a3, variance(a3));
		});
	});

	describe("the sd getter", () => {
		it("should give the standard deviation of the values in the array (or NaN if empty)", () => {
			const test = function(arr, comp) {
				if (!arr.length) expect(createNumericArray(arr).sd).to.be.NaN;
				else expect(createNumericArray(arr).sd).to.equal(comp);
			};
			test(a0, NaN);
			test(a1, sd(a1));
			test(a2, sd(a2));
			test(a3, sd(a3));
		});
	});

	describe("the median getter", () => {
		it("should give the median of the values in the array (or undefined if empty)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).median).to.equal(comp); };
			test(a0, undefined);
			test(a1, median(a1));
			test(a2, median(a2));
			test(a3, median(a3));
		});
	});

	describe("the iqr getter", () => {
		it("should give the interquartile range of the values in the array (or NaN if empty)", () => {
			const test = function(arr) {
				if (!arr.length) expect(createNumericArray(arr).iqr).to.be.NaN;
				else {
					var sorted = sortAscending(arr);
					var iqr = quantile(sorted, 0.75) - quantile(sorted, 0.25);
					expect(createNumericArray(arr).iqr).to.equal(iqr);
				}
			};
			test(a0);
			test(a1);
			test(a2);
			test(a3);
		});
	});

	describe("the quartiles method", () => {
		it("should give the quartiles of the values in the array (or NaNs if empty)", () => {
			const test = function(arr) {
				if (!arr.length) expect(createNumericArray(arr).quartiles().every(d => isNaN(d))).to.equal(true);
				else {
					var sorted = sortAscending(arr);
					var quartiles = [quantile(sorted, 0.25), quantile(sorted, 0.5), quantile(sorted, 0.75)];
					expect(createNumericArray(arr).quartiles()).to.deep.equal(quartiles);
				}
			};
			test(a0);
			test(a1);
			test(a2);
			test(a3);
		});
	});

	// ---- Geographic ---- //
	describe("the latitudeScore method tests whether numbers lie between -90 and 90 and", () => {
		it("should return a proportional value between 0 and 1 when not in use_predicate_mode (or null for empty array)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).latitudeScore()).to.equal(comp); };
			test(a0, null);
			test(a1, 1);
			test(a2, 2/3);
			test(a3, 1/3);
		});
		it("should return a binary value of 0 and 1 when in use_predicate_mode (or null for empty array)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).latitudeScore(true)).to.equal(comp); };
			test(a0, null);
			test(a1, 1);
			test(a2, 0);
			test(a3, 0);
		});
	});

	describe("the longitudeScore method tests whether numbers lie between -180 and 180 and", () => {
		it("should return a proportional value between 0 and 1 when not in use_predicate_mode (or null for empty array)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).longitudeScore()).to.equal(comp); };
			test(a0, null);
			test(a1, 1);
			test(a2, 1);
			test(a3, 1/3);
		});
		it("should return a binary value of 0 and 1 when in use_predicate_mode (or null for empty array)", () => {
			const test = function(arr, comp) { expect(createNumericArray(arr).longitudeScore(true)).to.equal(comp); };
			test(a0, null);
			test(a1, 1);
			test(a2, 1);
			test(a3, 0);
		});
	});
});
