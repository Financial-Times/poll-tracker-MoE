(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.infoPopup = factory());
}(this, (function () { 'use strict';

    var BORDER = 25,
        CORNER_RADIUS = 5,
        TRIANGLE_HALFWIDTH = 10,
        TRIANGLE_HEIGHT = 10;

    var locateTriangle = {};

    locateTriangle.bottom = function locateTriangle_bottom(w, h) {
    	return {
    		shape: [ -TRIANGLE_HALFWIDTH, -TRIANGLE_HEIGHT,  TRIANGLE_HALFWIDTH, -TRIANGLE_HEIGHT ],
    		pos: [w/2, h + TRIANGLE_HEIGHT]
    	};
    };

    locateTriangle.top = function locateTriangle_top(w, h) {
    	return {
    		shape: [ -TRIANGLE_HALFWIDTH, TRIANGLE_HEIGHT,  TRIANGLE_HALFWIDTH, TRIANGLE_HEIGHT ],
    		pos: [w/2, -TRIANGLE_HEIGHT]
    	};
    };

    locateTriangle.left = function locateTriangle_left(w, h) {
    	return {
    		shape: [ TRIANGLE_HEIGHT, TRIANGLE_HALFWIDTH,  TRIANGLE_HEIGHT, -TRIANGLE_HALFWIDTH ],
    		pos: [-TRIANGLE_HEIGHT, h/2]
    	};
    };

    locateTriangle.right = function locateTriangle_right(w, h) {
    	return {
    		shape: [ -TRIANGLE_HEIGHT, TRIANGLE_HALFWIDTH, -TRIANGLE_HEIGHT, -TRIANGLE_HALFWIDTH ],
    		pos: [w + TRIANGLE_HEIGHT, h/2]
    	};
    };

    locateTriangle.topLeft = function locateTriangle_topLeft(w, h) {
    	return {
    		shape: [ TRIANGLE_HEIGHT + CORNER_RADIUS, TRIANGLE_HEIGHT,
    		         TRIANGLE_HEIGHT, TRIANGLE_HEIGHT + CORNER_RADIUS ],
    		pos: [-TRIANGLE_HEIGHT, -TRIANGLE_HEIGHT]
    	};
    };

    locateTriangle.bottomLeft = function locateTriangle_bottomLeft(w, h) {
    	return {
    		shape: [ TRIANGLE_HEIGHT + CORNER_RADIUS, -TRIANGLE_HEIGHT,
    			       TRIANGLE_HEIGHT, -TRIANGLE_HEIGHT - CORNER_RADIUS ],
    		pos: [-TRIANGLE_HEIGHT, h + TRIANGLE_HEIGHT]
    	};
    };

    locateTriangle.topRight = function locateTriangle_topRight(w, h) {
    	return {
    		shape: [ -TRIANGLE_HEIGHT - CORNER_RADIUS, TRIANGLE_HEIGHT,
    			       -TRIANGLE_HEIGHT, TRIANGLE_HEIGHT + CORNER_RADIUS ],
    		pos: [w + TRIANGLE_HEIGHT, -TRIANGLE_HEIGHT]
    	};
    };

    locateTriangle.bottomRight = function locateTriangle_bottomRight(w, h) {
    	return {
    		shape: [ -TRIANGLE_HEIGHT - CORNER_RADIUS, -TRIANGLE_HEIGHT,
    			       -TRIANGLE_HEIGHT, -TRIANGLE_HEIGHT - CORNER_RADIUS ],
    		pos: [w + TRIANGLE_HEIGHT, h + TRIANGLE_HEIGHT]
    	};
    };

    function hFlexTriangle(w, h, x, y, cb, y_factor, y_pos) {
    	var l = x - w/2 - TRIANGLE_HEIGHT, r = x + w/2 + TRIANGLE_HEIGHT,
    	    px = w/2 + Math.min(0, l - cb.left) + Math.max(0, r - cb.right),
    	    shape;

    	if (px - TRIANGLE_HALFWIDTH < CORNER_RADIUS) {
    		shape = [ -px , (-TRIANGLE_HEIGHT - CORNER_RADIUS) * y_factor,
    				Math.max(TRIANGLE_HALFWIDTH, CORNER_RADIUS - px), -TRIANGLE_HEIGHT * y_factor ];
    	}
    	else if (px + TRIANGLE_HALFWIDTH > w - CORNER_RADIUS) {
    		shape = [ Math.min(-TRIANGLE_HALFWIDTH, w-px-CORNER_RADIUS), -TRIANGLE_HEIGHT * y_factor,
    			Math.min(TRIANGLE_HALFWIDTH, w - px), (-TRIANGLE_HEIGHT - CORNER_RADIUS) * y_factor ];
    	}
    	else {
    		shape = [ -TRIANGLE_HALFWIDTH, -TRIANGLE_HEIGHT * y_factor,
    				TRIANGLE_HALFWIDTH, -TRIANGLE_HEIGHT * y_factor ];
    	}

    	return { pos: [px, y_pos], shape: shape }
    }
    function vFlexTriangle(w, h, x, y, cb, x_factor, x_pos) {
    	var t = y - h/2 - TRIANGLE_HEIGHT, b = y + h/2 + TRIANGLE_HEIGHT,
    	    py = h/2 + Math.min(0, t - cb.top) + Math.max(0, b - cb.bottom),
    	    shape;

    	if (py - TRIANGLE_HALFWIDTH < CORNER_RADIUS) {
    		shape = [ (-TRIANGLE_HEIGHT - CORNER_RADIUS) * x_factor, -py,
    				-TRIANGLE_HEIGHT * x_factor, Math.max(TRIANGLE_HALFWIDTH, CORNER_RADIUS - py) ];
    	}
    	else if (py + TRIANGLE_HALFWIDTH > h - CORNER_RADIUS) {
    		shape = [ -TRIANGLE_HEIGHT * x_factor, Math.min(-TRIANGLE_HALFWIDTH, h-py-CORNER_RADIUS),
    			(-TRIANGLE_HEIGHT - CORNER_RADIUS) * x_factor, Math.min(TRIANGLE_HALFWIDTH, h - py) ];
    	}
    	else {
    		shape = [ -TRIANGLE_HEIGHT * x_factor, -TRIANGLE_HALFWIDTH,
    				-TRIANGLE_HEIGHT * x_factor, TRIANGLE_HALFWIDTH ];
    	}

    	return { pos: [x_pos, py], shape: shape }
    }
    locateTriangle.bottomFlexible = function locateTriangle_bottomFlexible(w, h, x, y, cb) {
    	return hFlexTriangle(w, h, x, y, cb, +1, h + TRIANGLE_HEIGHT);
    };

    locateTriangle.topFlexible = function locateTriangle_topFlexible(w, h, x, y, cb) {
    	return hFlexTriangle(w, h, x, y, cb, -1, -TRIANGLE_HEIGHT);
    };

    locateTriangle.rightFlexible = function locateTriangle_rightFlexible(w, h, x, y, cb) {
    	return vFlexTriangle(w, h, x, y, cb, +1, w + TRIANGLE_HEIGHT);
    };

    locateTriangle.leftFlexible = function locateTriangle_leftFlexible(w, h, x, y, cb) {
    	return vFlexTriangle(w, h, x, y, cb, -1, -TRIANGLE_HEIGHT);
    };

    function boxBounds(dir, w, h, x, y, cb) {
    	var lt = locateTriangle[dir](w, h, x, y, cb),
    	    left = x - BORDER - lt.pos[0],
    	    top = y - BORDER - lt.pos[1];
    	return { left: left, top: top, right: left + w + 2*BORDER, bottom: top + h + 2*BORDER };
    }

    function positionBox(dir, s, path, w, h, x, y, clientX, clientY, cb) {
    	var lt = locateTriangle[dir](w, h, clientX, clientY, cb);
    	s.left = (x - BORDER - lt.pos[0]) + "px";
    	s.top = (y - BORDER - lt.pos[1]) + "px";
    	path.setAttribute("d", "M0,0L" + lt.shape.join(",") + "Z");
    	path.setAttribute("transform", "translate(" + (lt.pos[0] + BORDER) + "," + (lt.pos[1] + BORDER) + ")");
    }

    function Popup_draw() {
    	var popup = this;

    	popup.is_visible = true;

    	function maxContentWidth(cb) {
    		if (popup._maxWidth.match(/^\d+(?:\.\d+)?%$/)) {
    			return cb.width * parseFloat(popup._maxWidth) / 100;
    		}
    		if (popup._maxWidth.match(/^\d+(?:\.\d+)?(?:px)?$/)) {
    			return parseFloat(popup._maxWidth);
    		}
    		if (popup._maxWidth != null) {
    			console.error("Popup: Unknown value for maxWidth: " + popup._maxWidth);
    		}
    		return cb.width;
    	}

    	if (!popup._point) {
    		console.error("Popup: cannot draw popup till point() has been specified");
    		return;
    	}

    	var doc_rect = document.documentElement.getBoundingClientRect(),
    	    clientX = popup._point[0], clientY = popup._point[1],
    	    cb = popup._container.getBoundingClientRect();

    	if (clientX < cb.left) clientX = cb.left;
    	else if (clientX > cb.right) clientX = cb.right;
    	if (clientY < cb.top) clientY = cb.top;
    	else if (clientY > cb.bottom) clientY = cb.bottom;

    	var x = clientX - doc_rect.left, y = clientY - doc_rect.top;

    	var el = popup._getElement(), s = el.style,
    	svg = el.querySelector(".flourish-popup-svg"),
    	g = svg.querySelector("g"),
    	rect = g.querySelector("rect"),
    	path = g.querySelector("path"),
    	content = el.querySelector(".flourish-popup-content");

    	s.display = "block";
    	content.style.maxWidth = maxContentWidth(cb) + "px";
    	if (popup._inner_html != popup._html) {
    		content.innerHTML = popup._inner_html = popup._html;
    	}
    	var content_box = content.getBoundingClientRect(),
    	    w, h;
    	do {
    		w = Math.ceil(content_box.width);
    		h = Math.ceil(content_box.height);
    		s.width = (w + 2*BORDER) + "px";
    		s.height = (h + 2*BORDER) + "px";
    		content_box = content.getBoundingClientRect();
    	} while (w != Math.ceil(content_box.width) || h != Math.ceil(content_box.height));

    	rect.setAttribute("width", w);
    	rect.setAttribute("height", h);
    	svg.setAttribute("width", w + 2*BORDER);
    	svg.setAttribute("height", h + 2*BORDER);

    	var overlap = BORDER - TRIANGLE_HEIGHT;
    	var first_fit = null, best_horizontal_fit = null, best_vertical_fit = null,
    	    least_horizontal_protrusion = Infinity, least_vertical_protrusion = Infinity,
    	    vp_at_least_hp, hp_at_least_vp;
    	for (var i = 0; i < popup._directions.length; i++) {
    		var dir = popup._directions[i],
    		    b = boxBounds(dir, w, h, clientX, clientY, cb),
    		    horizontal_protrusion = Math.max(0, Math.floor(cb.left) - b.left - overlap)
    		    	+ Math.max(0, b.right - Math.ceil(cb.right) - overlap),
    		    vertical_protrusion = Math.max(0, Math.floor(cb.top) - b.top - overlap)
    		    	+ Math.max(0, b.bottom - Math.ceil(cb.bottom) - overlap);

    		if (horizontal_protrusion == 0 && vertical_protrusion == 0) {
    			first_fit = dir;
    			break;
    		}
    		if (horizontal_protrusion < least_horizontal_protrusion
    		|| (horizontal_protrusion == least_horizontal_protrusion
    		    && vertical_protrusion < vp_at_least_hp))
    		{
    			least_horizontal_protrusion = horizontal_protrusion;
    			vp_at_least_hp = vertical_protrusion;
    			best_horizontal_fit = dir;
    		}
    		if (vertical_protrusion < least_vertical_protrusion
    		|| (vertical_protrusion == least_vertical_protrusion
    		    && horizontal_protrusion < hp_at_least_vp))
    		{
    			least_vertical_protrusion = vertical_protrusion;
    			hp_at_least_vp = horizontal_protrusion;
    			best_vertical_fit = dir;
    		}
    	}

    	// If the box can be fit completely within the container, do that
    	if (first_fit) {
    		dir = first_fit;
    	}
    	// Otherwise use the fallback fit (horizontal or vertical) if specified
    	else if (popup._fallbackFit == "horizontal") {
    		dir = best_horizontal_fit;
    	}
    	else if (popup._fallbackFit == "vertical") {
    		dir = best_vertical_fit;
    	}
    	// If all else fails, issue a warning and use the first specified direction.
    	else {
    		console.warn("Popup: failed to point box of size (" + w + ", " + h + ")" +
    			" at (" + clientX + ", " + clientY + ") within (" +
    			cb.left + ", " + cb.top +", " + cb.right + ", " + cb.bottom + ")");
    		dir = popup._directions[0];
    	}

    	// Position the box and return
    	positionBox(dir, s, path, w, h, x, y, clientX, clientY, cb);
    	return popup;
    }

    function svgElement(tagName, attrs, styles) {
    	var element = document.createElementNS("http://www.w3.org/2000/svg", tagName);
    	var k;
    	if (attrs) for (k in attrs) element.setAttribute(k, attrs[k]);

    	var s = element.style;
    	if (styles) for (k in styles) s[k] = styles[k];

    	return element;
    }

    function Popup__getElement() {
    	var popup = this;
    	var id = "flourish-popup-" + popup.unique_id;
    	var el = document.getElementById(id);
    	if (!el) {
    		el = document.createElement("div");
    		el.className = "flourish-popup";
    		el.id = id;

    		var s = el.style;
    		s.display = "none";
    		s.margin = s.padding = 0;
    		s.position = "absolute";
    		s.width = "80px";
    		s.height = "40px";
    		s.boxSizing = "border-box";

    		el.addEventListener("click", function(e) {
    			popup.fire("click", e);
    		}, false);

    		var svg = svgElement("svg", {"class": "flourish-popup-svg"}, {
    			position: "absolute",
    			top: 0, left: 0, bottom: 0, right: 0
    		});

    		var filter = svgElement("filter", {id: "dropshadow-" + popup.unique_id, height: "130%"});
    		filter.appendChild(svgElement("feGaussianBlur", {"in": "SourceAlpha", stdDeviation: 5}));
    		filter.appendChild(svgElement("feOffset", {dx: 0, dy: 2, result: "offsetblur"}));
    		var fe_component_transfer = svgElement("feComponentTransfer");
    		fe_component_transfer.appendChild(svgElement("feFuncA", {type: "linear", slope: 0.2}));
    		filter.appendChild(fe_component_transfer);
    		var fe_merge = svgElement("feMerge");
    		filter.appendChild(fe_merge);
    		fe_merge.appendChild(svgElement("feMergeNode"));
    		fe_merge.appendChild(svgElement("feMergeNode", {"in": "SourceGraphic"}));
    		svg.appendChild(filter);

    		var g = svgElement("g", {
    			filter: "url(#dropshadow-" + popup.unique_id + ")",
    			fill: "white",
    			stroke: "none"
    		});
    		g.appendChild(svgElement("rect", {x: BORDER, y: BORDER, rx: CORNER_RADIUS}));
    		g.appendChild(svgElement("path"));
    		svg.appendChild(g);
    		el.appendChild(svg);

    		var content = document.createElement("div");
    		content.className = "flourish-popup-content";
    		s = content.style;
    		s.position = "absolute";
    		s.top = s.left = BORDER + "px";
    		s.padding = "10px";
    		el.appendChild(content);

    		popup._getConstrainer().appendChild(el);
    	}

    	popup._resizeConstrainer();
    	return el;
    }

    /* The popup element can technically be partly outside the page, even though
       visually it is not. This causes the page to become horizontally scrollable,
       which can lead to problems like kiln/flourish#1267.

       This code adds an absolutely-positioned “constrainer” element containing the
       popup that has overlow:hidden, which covers the entire document.

       It’s surprisingly hard to achieve that – or at least I failed to find an easy
       way – and so we explicitly set the dimensions of the constrainer to match the
       document, and recompute them when the popup is redrawn.
    */

    // There is one constrainer for the entire page, however many Popup instances
    // there are, so these variables are global rather than properties of the instance.
    var constrainer, style;

    function Popup__getConstrainer() {
    	if (constrainer) return constrainer;

    	constrainer = document.createElement("div");
    	constrainer.id = "flourish-popup-constrainer";
    	style = constrainer.style;

    	style.overflow = "hidden";
    	style.pointerEvents = "none";
    	style.position = "absolute";
    	style.left = "0";
    	style.top = "0";
    	style.margin = "0";
    	style.padding = "0";

    	document.body.appendChild(constrainer);
    	this._resizeConstrainer();

    	return constrainer;
    }
    function Popup__resizeConstrainer() {
    	if (!constrainer) Popup__getConstrainer.call(this);
    	// The element must be hidden before we compute the dimensions, or
    	// it will affect those dimensions itself, with the effect that the
    	// constrainer can only grow and never shrink.
    	var old_display = style.display;
    	style.display = "none";
    	style.width = document.documentElement.scrollWidth + "px";
    	style.height = document.documentElement.scrollHeight + "px";
    	style.display = old_display;
    }

    var VERSION = "2.1.5";
    var next_unique_id$1 = 1;
    var OPTIONS$1 = {
    	container: document.body,
    	maxWidth: "70%",
    	point: null,
    	html: null,
    	directions: [
        	"bottom", "top", "left", "right",
        	"topLeft", "bottomLeft", "topRight", "bottomRight",
        	"bottomFlexible", "topFlexible", "leftFlexible", "rightFlexible"
        ],
    	fallbackFit: "horizontal" // or "vertical"
    };

    function Popup() {
    	this.unique_id = next_unique_id$1++;
    	this.is_visible = true;

    	for (var k in OPTIONS$1) this["_" + k] = OPTIONS$1[k];

    	this.handlers = {
    		"click": []
    	};
    }

    // Create accessor methods for all the options
    function accessor$1(k) {
    	Popup.prototype[k] = function(v) {
    		if (typeof v == "undefined") return this["_" + k];
    		this["_" + k] = v;
    		return this;
    	};
    }
    for (var k$1 in OPTIONS$1) accessor$1(k$1);

    // Custom accessor method for .point
    Popup.prototype.point = function(arg1, arg2) {
    	if (typeof arg1 == "undefined") return this._point;
    	if (Array.isArray(arg1)) this._point = [ arg1[0], arg1[1] ];
    	else if (typeof arg2 != "undefined") this._point = [ arg1, arg2 ];
    	else if (arg1 instanceof HTMLElement || arg1 instanceof SVGElement) {
    		var r = arg1.getBoundingClientRect();
    		this._point = [ Math.floor(r.left + r.width/2), Math.floor(r.top + r.height/2) ];
    	}
    	else {
    		console.error("Popup: could not understand argument");
    	}

    	return this;
    };

    Popup.prototype.directions = function(arg) {
    	if (typeof arg === "undefined") return this._directions;
    	if (typeof arg === "string") arg = [ arg ];
    	this._directions = arg.slice();
    	return this;
    };

    function textToHtml(text) {
    	return text.replace(/[&<>]/g, function (s) {
    		return ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" })[s];
    	});
    }

    // Accessor (setter only) for setting plain text
    Popup.prototype.text = function Popup_text(t) {
    	this._html = textToHtml(t);
    	return this;
    };

    // Attach event handlers
    Popup.prototype.on = function Popup_on(event, handler) {
    	if (!(event in this.handlers)) throw new Error("Popup.on: No such event: " + event);
    	this.handlers[event].push(handler);
    	return this;
    };

    // Fire event
    Popup.prototype.fire = function Popup_fire(event, d) {
    	if (!(event in this.handlers)) throw new Error("Popup.fire: No such event: " + event);
    	var handlers = this.handlers[event];
    	for (var i = 0; i < handlers.length; i++) {
    		handlers[i].call(this, d);
    	}
    	return this;
    };


    Popup.prototype._getElement = Popup__getElement;
    Popup.prototype._getConstrainer = Popup__getConstrainer;
    Popup.prototype._resizeConstrainer = Popup__resizeConstrainer;

    Popup.prototype.draw = Popup_draw;

    Popup.prototype.hide = function Popup_hide() {
    	if (!this.is_visible) return this;
    	this.is_visible = false;
    	this._getElement().style.display = "none";
    	return this;
    };


    function Flourish_popup() {
    	return new Popup();
    }
    Flourish_popup.version = VERSION;

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none() {}

    function selector(selector) {
      return selector == null ? none : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function empty() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty : function() {
        return this.querySelectorAll(selector);
      };
    }

    function selection_selectAll(select) {
      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$1(x) {
      return function() {
        return x;
      };
    }

    var keyPrefix = "$"; // Protect against keys like “__proto__”.

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = {},
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
          if (keyValue in nodeByKeyValue) {
            exit[i] = node;
          } else {
            nodeByKeyValue[keyValue] = node;
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = keyPrefix + key.call(parent, data[i], i, data);
        if (node = nodeByKeyValue[keyValue]) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue[keyValue] = null;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
          exit[i] = node;
        }
      }
    }

    function selection_data(value, key) {
      if (!value) {
        data = new Array(this.size()), j = -1;
        this.each(function(d) { data[++j] = d; });
        return data;
      }

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$1(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = value.call(parent, parent && parent.__data__, j, parents),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
      if (onupdate != null) update = onupdate(update);
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(selection) {

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      var nodes = new Array(this.size()), i = -1;
      this.each(function() { nodes[++i] = this; });
      return nodes;
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      var size = 0;
      this.each(function() { ++size; });
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    var filterEvents = {};

    var event$1 = null;

    if (typeof document !== "undefined") {
      var element = document.documentElement;
      if (!("onmouseenter" in element)) {
        filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
      }
    }

    function filterContextListener(listener, index, group) {
      listener = contextListener(listener, index, group);
      return function(event) {
        var related = event.relatedTarget;
        if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
          listener.call(this, event);
        }
      };
    }

    function contextListener(listener, index, group) {
      return function(event1) {
        var event0 = event$1; // Events can be reentrant (e.g., focus).
        event$1 = event1;
        try {
          listener.call(this, this.__data__, index, group);
        } finally {
          event$1 = event0;
        }
      };
    }

    function parseTypenames$1(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, capture) {
      var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
      return function(d, i, group) {
        var on = this.__on, o, listener = wrap(value, i, group);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
            this.addEventListener(o.type, o.listener = listener, o.capture = capture);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, capture);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, capture) {
      var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      if (capture == null) capture = false;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    var root = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root);
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root);
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval) interval = clearInterval(interval);
      } else {
        if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(function(elapsed) {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    var noop = {value: function() {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color, {
      copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    var deg2rad = Math.PI / 180;
    var rad2deg = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    var K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0 = 4 / 29,
        t1 = 6 / 29,
        t2 = 3 * t1 * t1,
        t3 = t1 * t1 * t1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function lab(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab, extend(Color, {
      brighter: function(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
    }

    function lab2xyz(t) {
      return t > t1 ? t * t * t : t2 * (t - t0);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * rad2deg;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function hcl(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * deg2rad;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl, extend(Color, {
      brighter: function(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker: function(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb: function() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B = +1.78277,
        C = -0.29227,
        D = -0.90649,
        E = +1.97294,
        ED = E * D,
        EB = E * B,
        BC_DA = B * C - D * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B * sinh)),
          255 * (l + a * (C * cosh + D * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function constant(x) {
      return function() {
        return x;
      };
    }

    function linear(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear(a, d) : constant(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    var degrees = 180 / Math.PI;

    var identity = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var cssNode,
        cssRoot,
        cssView,
        svgNode;

    function parseCss(value) {
      if (value === "none") return identity;
      if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
      cssNode.style.transform = value;
      value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
      cssRoot.removeChild(cssNode);
      value = value.slice(7, -1).split(",");
      return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
    }

    function parseSvg(value) {
      if (value == null) return identity;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get(node, id).value[name];
      };
    }

    function interpolate(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color ? interpolateRgb
          : (c = color(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get(this.node(), id).ease;
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      end: transition_end
    };

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          return defaultTiming.time = now(), defaultTiming;
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var next_unique_id = 1;

    var OPTIONS = {
    	container: document.body,
    	point: [window.innerWidth/2, window.innerHeight/2],
    	html: "",
    	open_duration: 250,
    	close_duration: 250,
    	popup_custom_template: "",
    	position: "overlay",
    	shadow: true,
    	underlay_color: "rgba(255, 255, 255, 0.75)",

    	width_side: 35,
    	height_side: 35,
    	width_overlay: 80,
    	height_overlay: 80,
    	vertical_position: "click",
    	max_width: null,
    	max_height: null,
    	closeable: true
    };

    function Panel() {
    	var panel = this;
    	panel.unique_id = next_unique_id++;
    	panel._is_open = false;
    	panel._onclose = null;
    	for (var k in OPTIONS) panel["_" + k] = OPTIONS[k];
    }

    // Create accessor methods for all the options
    function accessor(k) {
    	Panel.prototype[k] = function(v) {
    		if (typeof v == "undefined") return this["_" + k];
    		this["_" + k] = v;
    		return this;
    	};
    }
    for (var k in OPTIONS) accessor(k);

    // Custom accessor method for .point
    Panel.prototype.point = function(arg1, arg2) {
    	if (typeof arg1 == "undefined") return this._point;
    	if (Array.isArray(arg1)) this._point = [ arg1[0], arg1[1] ];
    	else if (typeof arg2 != "undefined") this._point = [ arg1, arg2 ];
    	else if (arg1 instanceof HTMLElement || arg1 instanceof SVGElement) {
    		var r = arg1.getBoundingClientRect();
    		this._point = [ Math.floor(r.left + r.width/2), Math.floor(r.top + r.height/2) ];
    	}
    	else {
    		console.error("Panel: could not understand argument");
    	}
    	return this;
    };

    Panel.prototype.container = function(container) {
    	if (container) this._container = container;
    	return this;
    };

    function fadeOutPanel(panel) {
    	panel._getElement().style.pointerEvents = "none";
    	panel._is_open = false;
    	var duration = panel._close_duration;
    	select(panel._getElement())
    		.transition().duration(duration)
    		.style("background", "rgba(255, 255, 255, 0)")
    		.on("interrupt", function() {
    			select(this).style("display", panel._is_open ? "block" : "none");
    		})
    		.on("end", function() {
    			select(this).style("display", "none");
    		})
    		.select(".flourish-panel-close")
    		.style("opacity", "0");

    	select(panel._inner)
    		.transition().duration(duration)
    		.style("opacity", 0);

    	select(panel._content)
    		.transition().duration(duration/2)
    		.style("opacity", 0);
    }


    Panel.prototype.hide = function() {
    	var panel = this;
    	if (!panel._is_open) return;
    	fadeOutPanel(panel);
    	return this;
    };

    Panel.prototype.close = Panel.prototype.hide;

    function addCloseButton(panel) {
    	select(panel._inner).append("svg")
    		.attr("class", "flourish-panel-close")
    		.attr("viewBox", "0 0 40 40")
    		.style("width", "1.25rem")
    		.style("height", "1.25rem")
    		.style("position", "absolute")
    		.style("right", "1rem")
    		.style("top", "1rem")
    		.style("cursor", "pointer")
    		.style("opacity", 0)
    		.on("mouseover", function() { if (panel._closeable) this.style.opacity = 0.66; })
    		.on("mouseout", function() { if (panel._closeable) this.style.opacity = 1; })
    		.on("click", function () {
    			event$1.stopPropagation();
    			panel.hide();
    			if (panel._onclose) panel._onclose();
    		})
    		.on("touch", function() {
    			event$1.stopPropagation();
    			panel.hide();
    			if (panel._onclose) panel._onclose();
    		})
    		.append("path")
    		.attr("stroke", "#333333")
    		.attr("stroke-width", "0.5rem")
    		.attr("stroke-linecap", "round")
    		.attr("d", "M 10,10 L 30,30 M 30,10 L 10,30");
    }

    Panel.prototype.draw = function() {
    	var panel = this;
    	panel._content.innerHTML = panel._html;
    	openPanel(panel);
    	return this;
    };

    Panel.prototype.on = function(event, callback) {
    	if (event == "close") {
    		if (callback) this._onclose = callback;
    	}
    	else console.error("Panel .on() method only supports 'close' events");
    	return this;
    };

    function openPanel(panel) {
    	var duration = panel._is_open || panel._html == panel._default ? 0 : panel._open_duration;

    	var window_w = window.innerWidth, window_h = window.innerHeight;

    	var overlay = panel._position == "overlay",
    	    full_width = panel._position == "top" || panel._position == "bottom",
    	    full_height = panel._position == "left" || panel._position == "right",
    	    max_w_percent = 100 * (panel._max_width || Infinity)/window_w,
    	    max_h_percent = 100 * (panel._max_height || Infinity)/window_h,
    	    y_percent = (100 * panel._point[1] / window_h);

    	var position_click = panel._vertical_position == "click" && !Flourish.fixed_height;

    	var end_w_percent = overlay ? Math.min(panel._width_overlay, max_w_percent) : (full_width ? 100 : Math.min(panel._width_side, max_w_percent)),
    	    end_h_percent = overlay ? Math.min(panel._height_overlay, max_h_percent) : (full_height ? 100 : Math.min(panel._height_side, max_h_percent));

    	var end_l_percent = overlay ? (100 - end_w_percent) / 2 : (panel._position == "right" ? (100 - end_w_percent) : 0),
    	    end_t_percent_overlay = position_click ? Math.max(1, Math.min((y_percent - (end_h_percent / 2)), 99 - end_h_percent)) : (100 - end_h_percent) / 2,
    	    end_t_percent = overlay ? end_t_percent_overlay : (panel._position == "bottom" ? (100 - end_h_percent) : 0);

    	var start_w_percent = overlay ? 0 : end_w_percent,
    	    start_h_percent = overlay ? 0 : end_h_percent,
    	    start_l_percent = overlay ? (100 * panel._point[0]/window_w) : (panel._position == "right" ? 100 : (panel._position == "left" ? -end_w_percent : 0)),
    	    start_t_percent = overlay ? y_percent : (panel._position == "bottom" ? 100 : (panel._position == "top" ? -end_h_percent : 0));

    	select(panel._getElement()).style("display", "block")
    		.transition().duration(duration).delay(duration * 0.25)
    		.style("background", overlay ? panel._underlay_color : "rgba(255, 255, 255, 0)")
    		.style("pointer-events", overlay ? null : "none");

    	select(panel._inner)
    		.style("opacity", 1)
    		.style("display", "block")
    		.style("pointer-events", "none")
    		.style("width", start_w_percent + "%")
    		.style("height", start_h_percent + "%")
    		.style("left", start_l_percent + "%")
    		.style("top", start_t_percent + "%")
    		.transition().duration(duration)
    		.style("width", end_w_percent + "%")
    		.style("height", end_h_percent + "%")
    		.style("left", end_l_percent + "%")
    		.style("top", end_t_percent + "%")
    		.on("end", function() {
    			select(panel._inner)
    				.style("pointer-events", "all")
    				.style("width", end_w_percent + "%")
    				.style("height", end_h_percent + "%")
    				.style("left", end_l_percent + "%")
    				.style("top", end_t_percent + "%");
    		})
    		.on("interrupt", function() {
    			select(panel._inner)
    				.style("pointer-events", "all")
    				.style("width", end_w_percent + "%")
    				.style("height", end_h_percent + "%")
    				.style("left", end_l_percent + "%")
    				.style("top", end_t_percent + "%");
    		});

    	var offset_panel_content = full_height && position_click;

    	select(panel._content)
    		.transition().duration(duration/4).delay(duration)
    		.style("opacity", 1)
    		.on("interrupt", function() {
    			select(this).style("opacity", 1);
    		});

    	select(panel._content).select(".flourish-panel-content-inner")
    		.style("position", offset_panel_content ? "absolute" : null)
    		.style("top", offset_panel_content ? y_percent + "%" : null)
    		.style("transform", offset_panel_content ? "translateY(-50%)" : null);

    	select(panel._inner).select(".flourish-panel-close")
    		.style("opacity", 0)
    		.transition().duration(duration / 4).delay(duration)
    		.style("opacity", panel._closeable ? 1 : 0);

    	panel._is_open = true;

    	timerFlush();
    }

    Panel.prototype.margins = function() {
    	var margins = { top: 0, right: 0, bottom: 0, left: 0 };
    	if (this._is_open && this._position != "overlay") {
    		var rect = this._getElement().getBoundingClientRect();
    		if (this._position == "top") margins.top = rect.top + rect.height;
    		if (this._position == "right") margins.right = rect.left;
    		if (this._position == "bottom") margins.bottom = rect.top;
    		if (this._position == "left") margins.left = rect.left + rect.width;
    	}
    	margins.css = margins.top + "px " + margins.right + "px " + margins.bottom + "px " + margins.left + "px";
    	return margins;
    };

    Panel.prototype._getElement = function() {
    	var panel = this;
    	var id = "flourish-panel-" + panel.unique_id;
    	var el = document.getElementById(id);
    	if (!el) {
    		el = document.createElement("div");
    		el.className = "flourish-panel";
    		el.id = id;
    		el.addEventListener("click", function(e) {
    			e.stopPropagation();
    			panel.hide();
    			if (panel._onclose) panel._onclose();
    		});

    		var s = el.style;
    		s.position = "absolute";
    		s.zIndex = "999999";
    		s.pointerEvents = "none";
    		s.width = "100%";
    		s.height = "100%";
    		s.top = "0";
    		s.left = "0";
    		s.background = "rgba(255, 255, 255, 0)";

    		var inner = document.createElement("div");
    		inner.className = "flourish-panel-inner";
    		el.appendChild(inner);
    		panel._inner = inner;

    		s = inner.style;
    		s.width = "0";
    		s.height = "0";
    		s.position = "absolute";
    		s.boxSizing = "border-box";

    		var shadow = document.createElement("div");
    		shadow.className = "flourish-panel-shadow";
    		inner.appendChild(shadow);

    		var content = document.createElement("div");
    		content.className = "flourish-panel-content";
    		inner.appendChild(content);
    		panel._content = content;

    		s = content.style;
    		s.opacity = "0";
    		s.overflowY = "auto";
    		s.height = "100%";

    		addCloseButton(panel);

    		panel._container.appendChild(el);
    	}
    	return el;
    };

    function initPanel() {
    	return new Panel();
    }

    var DEFAULTS = {
    	mode: "popup",

    	// If truthy, means panel or popup are locked
    	locked_id: null,

    	// Popup content
    	popup_is_custom: false,
    	popup_custom_header: "Popup header",
    	popup_custom_main: "Popup main content. Write your column names in between double curly brackets to display dynamic content.",
    	popup_teaser_default: "Click to see more",

    	// Popup styles
    	popup_text_color: "#333333",
    	popup_align: "start",
    	popup_font_size: 1,
    	popup_width: 12,
    	popup_background: "#ffffff",
    	popup_background_opacity: 1,
    	popup_padding: 0.5,
    	popup_radius: 0.2,
    	popup_shadow: true,
    	popup_pointer: true,
    	popup_header_background: "#333333",
    	popup_header_text_color: "#ffffff",
    	popup_header_type: "block",
    	popup_list_type: "table",
    	popup_list_label_weight: "normal",
    	popup_list_separator: ": ",

    	// Panel content
    	panel_is_custom: false,
    	panel_custom_header: "Custom panel header",
    	panel_custom_main: "Custom panel main content",
    	panel_side_default_content: "<h1>Tap or click to explore</h1>",
    	panel_side_fixed: false,

    	// Panel layout
    	panel_position: "overlay",
    	panel_width_overlay: 80,
    	panel_height_overlay: 80,
    	panel_vertical_position: "center",
    	panel_width_side: 35,
    	panel_height_side: 35,
    	panel_max_width: null,
    	panel_max_height: null,

    	// Panel styles
    	panel_text_color: "#333333",
    	panel_align: "start",
    	panel_font_size: 1.25,
    	panel_background: "#ffffff",
    	panel_background_opacity: 0.9,
    	panel_padding: 1.2,
    	panel_radius: 0.2,
    	panel_shadow: true,
    	panel_open_duration: 250,
    	panel_close_duration: 250,
    	panel_list_type: "table",
    	panel_list_label_weight: "normal",
    	panel_list_separator: ": ",
    };

    function getDefaultHTML(instance, d, mode) {
    	var html = "<div class='flourish-panel-content-inner'>";
    	var custom_default = instance["_" + mode + "_default_template"];
    	var list_mode = instance._state[mode + "_list_type"];
    	var separator = instance._state[mode + "_list_separator"];
    	var separator_is_line_break = separator === "<br />";
    	var character_separator = separator_is_line_break ? "" : separator;
    	var line_break = separator_is_line_break ? separator : "";

    	if (!custom_default) {
    		// By default just show all the selected columns
    		var col_name;
    		var col_names_in_popup = {};
    		if (d[instance._title_key] || d[instance._subtitle_key]) {
    			html += "<header>";
    			if (d[instance._title_key]) {
    				html += "<h1>" + d[instance._title_key] + "</h1>";
    				col_name = instance._column_names[instance._title_key];
    				col_names_in_popup[col_name] = true;
    			}
    			if (d[instance._subtitle_key]) {
    				html += "<h2>" + d[instance._subtitle_key] + "</h2>";
    				col_name = instance._column_names[instance._subtitle_key];
    				col_names_in_popup[col_name] = true;
    			}
    			html += "</header>";
    		}
    		var main_content = "";
    		for (var binding in instance._column_names) {
    			if (binding == instance._title_key) continue;
    			if (binding == instance._subtitle_key) continue;
    			else if (Array.isArray(d[binding])) {
    				for (var m = 0; m < d[binding].length; m++) {
    					col_name = instance._column_names[binding][m];
    					if (col_names_in_popup[col_name]) continue;
    					col_names_in_popup[col_name] = true;
    					if (list_mode == "table") main_content += "<tr><td class='table-col-label'><span class='data-heading'>" + col_name + "</span></td><td class='table-col-value'>" + d[binding][m] + "</td></tr>";
    					else if (list_mode == "ul") main_content += "<li><span class='data-heading'>" + col_name + character_separator +" </span> "+ line_break + d[binding][m] + "</li>";
    				}
    			}
    			else {
    				col_name = instance._column_names[binding];
    				if (col_names_in_popup[col_name]) continue;
    				col_names_in_popup[col_name] = true;
    				if (list_mode == "table") main_content += "<tr><td class='table-col-label'><span class='data-heading'>" + col_name + "</span></td><td class='table-col-value'>" + d[binding] + "</td></tr>";
    				else if (list_mode == "ul") main_content += "<li><span class='data-heading'>" + col_name + character_separator + " </span> " + line_break + d[binding] + "</li>";
    			}
    		}
    		if (main_content !== "") {
    			html += "<div class='main-content'><" + list_mode + ">";
    			html += main_content;
    			html += "</" + list_mode + "></div></div>";
    		}
    	}
    	else {
    		html += custom_default.replace(/\{\{((?:[^}]|\}[^}])*)\}\}/g, function(_, target_col_name) {
    			var value;
    			if (Array.isArray(instance._column_names[target_col_name])) {
    				var column_name = instance._column_names[target_col_name];
    				if (column_name.length == 0) return "";
    				value = "<ul>";
    				column_name.forEach(function(name, i) {
    					value += "<li>" + name + separator + d[target_col_name][i] + "</li>";
    				});
    				value += "</ul>";
    			}
    			else {
    				value = d[target_col_name];
    			}
    			if (value !== undefined) return value;
    			return "";
    		});
    	}
    	return html;
    }

    function getValueFromColumnName(instance, target_col_name, d) {
    	var value;
    	Object.keys(instance._column_names).some(function(key) {
    		if (Array.isArray(instance._column_names[key])) {
    			var index = instance._column_names[key].indexOf(target_col_name);
    			if (index >= 0) {
    				value = d[key][index];
    				return true;
    			}
    		}
    		else if (instance._column_names[key] == target_col_name) {
    			value = d[key];
    			return true;
    		}
    	});
    	if (value !== undefined) return value;
    	return "";
    }

    function getCustomHTML(instance, content_header_raw, content_main_raw, d) {
    	var content = "";

    	// TODO. Add handlebars proper to extend this to support else statements and nested conditions
    	var content_header_parsed = getParsedContent(content_header_raw, instance, d);
    	var content_main_parsed = getParsedContent(content_main_raw, instance, d);

    	if (content_header_parsed) content += "<header>" + content_header_parsed + "</header>";
    	if (content_main_parsed) content += "<div class='main-content'>" + content_main_parsed + "</div>";

    	return content;
    }

    function getParsedContent(content_raw, instance, d) {
    	var condition_regex = /\{\{#if ((?:[^}]|\}[^}])*)\}\}([\s\S]*?)\{\{\/if\}\}/g;
    	var variable_regex = /\{\{((?:[^}]|\}[^}])*)\}\}/g;
    	return content_raw
    		.replace(condition_regex, function (_, target_col_name, if_contents) {
    			return getValueFromColumnName(instance, target_col_name, d) == "" ? "" : if_contents;
    		})
    		.replace(variable_regex, function (_, target_col_name) {
    			return getValueFromColumnName(instance, target_col_name, d);
    		}).trim();
    }

    function getPopupHTML(instance, d, teaser) {
    	var html = "";
    	if (teaser && !instance._state.popup_is_custom) html += "<div class='main-content'>" + instance._state.popup_teaser_default + "</div>";
    	else if (!teaser && !instance._state.popup_is_custom) html += getDefaultHTML(instance, d, "popup");
    	else html += getCustomHTML(instance, instance._state.popup_custom_header, instance._state.popup_custom_main, d);
    	return html;
    }

    function getPanelHTML(instance, d) {
    	var html = "";
    	if (!instance._state.panel_is_custom) html += getDefaultHTML(instance, d, "panel");
    	else html += getCustomHTML(instance, instance._state.panel_custom_header, instance._state.panel_custom_main, d);
    	return html;
    }

    function Stylesheet() {
    	this.declarations = [];
    	return this;
    }

    Stylesheet.prototype.select = function(selector) {
    	if (!selector) return this;
    	var declaration = new Declaration(selector, this);
    	declaration.parent = this;
    	this.addDeclaration(declaration);

    	return declaration;
    };

    Stylesheet.prototype.addDeclaration = function(declaration) {
    	this.declarations.push(declaration);
    	return this;
    };

    Stylesheet.prototype.print = function() {
    	var text = "";
    	this.declarations.forEach(function(declaration) {
    		text += declaration.selector + " {\n";
    		declaration.styles.forEach(function(style) {
    			text += "\t" + style[0] + ": " + style[1] + ";\n";
    		});
    		text += "}\n\n";
    	});
    	return text;
    };

    Stylesheet.prototype.clear = function() {
    	this.declarations = [];
    	return this;
    };

    function Declaration(selector) {
    	this.selector = selector;
    	this.styles = [];
    	return this;
    }

    Declaration.prototype.style = function(property, _value) {
    	var value = typeof value_ == "function" ? _value() : _value;
    	if (value !== "" && value !== null && value !== undefined) this.styles.push([property, value]);
    	return this;
    };

    Declaration.prototype.select = function(selector) {
    	return this.parent.select(this.selector + " " + selector);
    };

    function appendStyles(instance) {
    	if (!document.querySelector("#popup-styles")) {
    		var css = document.createElement("style");
    		css.id = "popup-styles";
    		document.head.appendChild(css);
    	}
    	var styles = new Stylesheet();
    	var header_block = instance._state.popup_header_type == "block";
    	var header_background = color(instance._state.popup_header_background || "transparent");
    	header_background.opacity = instance._state.popup_header_background ? instance._state.popup_background_opacity : 0;
    	var panel_pos = instance._state.panel_position;
    	styles.select(".flourish-panel .flourish-panel-shadow")
    		.style("pointer-events", "none")
    		.style("position", "absolute")
    		.style("display", panel_pos == "overlay" || !instance._state.panel_shadow ? "none" : "block")
    		.style("top", panel_pos == "bottom" ? "-3rem" : panel_pos == "top" ? "auto" : 0)
    		.style("right", panel_pos == "left" ? "-3rem" : panel_pos == "right" ? "auto" : 0)
    		.style("bottom", panel_pos == "top" ? "-3rem" : panel_pos == "bottom" ? "auto" : 0)
    		.style("left", panel_pos == "right" ? "-3rem" : panel_pos == "left" ? "auto" : 0)
    		.style("width", panel_pos == "left" || panel_pos == "right" ? "3rem" : "100%")
    		.style("height", panel_pos == "top" || panel_pos == "bottom" ? "3rem" : "100%")
    		.style("z-index", "-1")
    		.style("overflow", "hidden");

    	styles.select(".flourish-panel .flourish-panel-shadow:before")
    		.style("content", "''")
    		.style("display", "block")
    		.style("position", "absolute")
    		.style("width", panel_pos == "left" || panel_pos == "right" ? "1.5rem" : "100%")
    		.style("height", panel_pos == "top" || panel_pos == "bottom" ? "1.5rem" : "100%")
    		.style("border-radius", "50%")
    		.style("background", "rgba(0,0,0,0.3)")
    		.style("bottom", panel_pos == "bottom" ? "-50%" : panel_pos == "top" ? "auto" : 0)
    		.style("left", panel_pos == "left" ? "-50%" : panel_pos == "right" ? "auto" : 0)
    		.style("top", panel_pos == "top" ? "-50%" : panel_pos == "bottom" ? "auto" : 0)
    		.style("right", panel_pos == "right" ? "-50%" : panel_pos == "left" ? "auto" : 0)
    		.style("filter", "blur(15px)");

    	styles.select(".flourish-popup")
    		.style("pointer-events", "none")
    		.select(".flourish-popup-content")
    		.style("pointer-events", "auto")
    		.style("max-width", instance._state.popup_width == null ? null : instance._state.popup_width + "rem !important");

    	styles.select(".flourish-popup header, .flourish-panel header")
    		.style("margin", "0");

    	styles.select(".flourish-popup header")
    		.style("font-weight", "bold")
    		.style("color", header_block ? instance._state.popup_header_text_color : null)
    		.style("background", header_block ? header_background.rgb() : null)
    		.style("padding", instance._state.popup_padding + "rem")
    		.style("border-radius", instance._state.popup_radius + "rem " + instance._state.popup_radius + "rem 0 0");

    	// If a header is not the last child that means the popup has content
    	const headers_with_content = styles.select(".flourish-popup header:not(:last-child)");
    	// We want the padding bottom to be zero only when the popup has content and has an inline header
    	headers_with_content.style("padding-bottom", header_block ? null : "0");

    	// Header which isn't the last child has content following it. If it's an
    	// inline header, there should be no extra padding between it and the content.
    	styles.select(".flourish-popup header:not(:last-child)")
    		.style("padding-bottom", header_block ? null : "0");


    	styles.select(".flourish-panel .flourish-panel-content-inner")
    		.style("overflow", "auto");

    	styles.select(".flourish-panel header")
    		.style("font-weight", "bold")
    		.style("margin-bottom", "0.5em")
    		.style("padding-right", "1rem");

    	styles.select(".flourish-popup .main-content")
    		.style("padding", instance._state.popup_padding + "rem");

    	styles.select(".flourish-popup header + .main-content")
    		.style("padding", instance._state.popup_padding + "rem")
    		.style("padding-top", !header_block ? "0" : null);


    	styles.select(".flourish-popup h1, .flourish-panel h1")
    		.style("font-size", "1em")
    		.style("margin", "0");


    	styles.select(".flourish-popup h1, .flourish-popup h2, .flourish-popup ul li")
    		.style("text-align", instance._state.popup_align);

    	styles.select(".flourish-panel h1, .flourish-panel h2, .flourish-panel ul li")
    		.style("text-align", instance._state.panel_align);

    	styles.select(".flourish-popup h2, .flourish-panel h2")
    		.style("font-size", "1em")
    		.style("margin", header_block ? "0" : "0 0 0.25em")
    		.style("opacity", "0.6")
    		.style("font-weight", "normal");

    	styles.select(".flourish-popup h2:empty, .flourish-panel h2:empty, .flourish-popup h1:empty, .flourish-panel h1:empty, .flourish-popup p:empty, .flourish-panel p:empty")
    		.style("display", "none");

    	styles.select(".flourish-popup p, .flourish-panel p")
    		.style("margin", "0")
    		.style("font-size", "inherit")
    		.style("font-weight", "normal");

    	styles.select(".flourish-popup table, .flourish-panel table")
    		.style("margin", "0")
    		.style("width", "100%")
    		.style("border-collapse", "collapse")
    		.style("table-layout", "auto");

    	styles.select(".flourish-popup table tr, .flourish-panel table tr")
    		.style("border-top", "1px solid #eee");

    	styles.select(".flourish-popup table tr:first-child, .flourish-panel table tr:first-child")
    		.style("border-top", "none");

    	styles.select(".flourish-popup table tr td, .flourish-panel table tr td")
    		.style("padding", "0.25em 0 0.25em 0")
    		.style("padding-inline-end", "0.25em")
    		.style("vertical-align", "top")
    		.style("font-size", "inherit")
    		.style("text-align", "start")
    		.style("font-weight", "normal")
    		.style("overflow", "hidden")
    		.style("word-break", "break-word")
    		.style("text-overflow", "ellipsis");

    	styles.select(".flourish-popup table tr:last-child td, .flourish-panel table tr:last-child td")
    		.style("padding-bottom", "0");

    	styles.select(".flourish-popup .data-heading")
    		.style("font-weight", instance._state.popup_list_label_weight)
    		.style("display", "inline-block");

    	styles.select(".flourish-panel .data-heading")
    		.style("font-weight", instance._state.panel_list_label_weight)
    		.style("display", "inline-block");


    	styles.select(".flourish-popup table tr td.table-col-value, .flourish-panel table tr td.table-col-value")
    		.style("text-align", "end")
    		.style("padding", "0.25em 0 0.25em 0")
    		.style("padding-inline-end", "0.25em");

    	styles.select(".flourish-popup table tr:last-child td.table-col-value, .flourish-panel table tr:last-child td.table-col-value")
    		.style("padding-bottom", "0");

    	styles.select(".flourish-popup ul, .flourish-panel ul")
    		.style("padding", "0")
    		.style("margin", "0");

    	styles.select(".flourish-popup ul li, .flourish-panel ul li")
    		.style("font-size", "inherit")
    		.style("list-style", "none");

    	document.head.querySelector("#popup-styles").innerHTML = styles.print();
    }

    function updateStyle(instance) {
    	var popup_el = instance.popup._getElement();
    	var popup_el_content = popup_el.querySelector(".flourish-popup-content");

    	popup_el_content.style.padding = "0";
    	popup_el_content.style.textAlign = instance._state.popup_align;
    	popup_el_content.style.color = instance._state.popup_text_color;
    	popup_el_content.style.fontSize = instance._state.popup_font_size + "rem";
    	popup_el_content.style.borderRadius = instance._state.popup_radius + "rem";
    	popup_el_content.addEventListener("click", function() { event.stopPropagation(); });

    	var panel_el = instance.panel._getElement();
    	var panel_el_inner = panel_el.querySelector(".flourish-panel-inner");
    	var panel_el_content = panel_el.querySelector(".flourish-panel-content");

    	var rgba = color(instance._state.panel_background);
    	panel_el_inner.style.background = "rgba(" + rgba.r + "," + rgba.g + "," + rgba.b + "," + instance._state.panel_background_opacity + ")";
    	panel_el_inner.style.borderRadius = instance._state.popup_radius + "rem";
    	panel_el_inner.style.boxShadow = instance._state.panel_position == "overlay" && instance._state.panel_shadow ? "0 0 1.5rem rgba(0,0,0,0.2)" : "";
    	panel_el_inner.addEventListener("click", function() { event.stopPropagation(); });

    	panel_el_content.style.padding = instance._state.panel_padding + "rem";
    	panel_el_content.style.textAlign = instance._state.panel_align;
    	panel_el_content.style.color = instance._state.panel_text_color;
    	panel_el_content.style.fontSize = instance._state.panel_font_size + "rem";
    	panel_el_content.style.boxSizing = "border-box";

    	var g = popup_el.querySelector(".flourish-popup-svg g");
    	g.style.fill = instance._state.popup_background;
    	g.style.opacity = instance._state.popup_background_opacity;

    	var closer = panel_el.querySelector(".flourish-panel-close path");
    	if (closer) closer.style.stroke = instance._state.panel_text_color;

    	if (instance._state.popup_shadow == false) g.removeAttribute("filter");
    	else g.setAttribute("filter", "url(#dropshadow-" + instance.popup.unique_id + ")");
    	g.querySelector("rect").setAttribute("rx", instance._state.popup_radius + "rem");
    	g.querySelector("path").style.display = (instance._state.popup_pointer ? "block" : "none");

    	appendStyles(instance);
    }

    function InfoPopup(state, panel_container, popup_container) {
    	var instance = this;
    	this._state = state;
    	this._popup_default_template = null;
    	this._panel_default_template = null;
    	this._title_key = "name";
    	this._subtitle_key = null;
    	this._first_load = true;
    	this._on_panel_close = null;
    	this._show_default_content_timer = null;
    	this._panel_container = panel_container || document.body;
    	this._popup_container = popup_container || document.body;
    	this._popup_directions = ["top", "bottom", "left", "right"];
    	this._getLockedPosition = function() { return null; };

    	for (var key in DEFAULTS) {
    		if (state[key] == undefined) state[key] = DEFAULTS[key];
    	}

    	this.panel = initPanel().container(this._panel_container).on("close", function() {
    		instance._state.locked_id = null;
    		instance.popup.hide();
    		if (typeof instance._on_panel_close == "function") instance._on_panel_close();
    	});
    	this.popup = Flourish_popup().container(this._popup_container).point(0, 0).draw().hide();
    }

    // ============ //
    // INIT METHODS //
    // ============ //

    InfoPopup.prototype.getLockedPosition = function(getLockedPositionFunction) {
    	if (typeof getLockedPositionFunction != "function") {
    		console.error("Invalid function passed to @flourish/info-popup getLockedPosition");
    	}
    	else this._getLockedPosition = getLockedPositionFunction;
    	return this;
    };

    // ====== //
    // UDPATE //
    // ====== //

    InfoPopup.prototype.update = function(callback) {
    	if (this._state.locked_id !== null && this._state.mode != "none") {
    		var selected = this._getLockedPosition(this._state.locked_id);
    		if (selected) this.click(selected[0], selected[1], this._state.locked_id, callback);
    		else console.warn("@flourish/info-popup: failed to return value from getLockedPosition function");
    	}
    	else this.clickout();
    };

    // ============= //
    // EVENT METHODS //
    // ============= //

    function disablePopupPointerEvents(instance) {
    	instance.popup._getElement().querySelector(".flourish-popup-content").style.pointerEvents = "none";
    }

    function enablePopupPointerEvents(instance) {
    	instance.popup._getElement().querySelector(".flourish-popup-content").style.pointerEvents = "auto";
    }

    InfoPopup.prototype.click = function(coords_or_node, d, id, callback) {
    	if (this._state.mode == "none") return;
    	var target = this._state.mode == "popup" ? "popup" : "panel";
    	if (this._checkIfPopupIsEmpty(d, target)) {
    		target === "panel" ? this.hidePanel() : this.hidePopup();
    		return;
    	}
    	// TODO: Check if popup content is empty
    	this._point(coords_or_node);
    	if (id != undefined) {
    		this._state.locked_id = id;
    		enablePopupPointerEvents(this);
    	}
    	else this._state.locked_id = null;
    	if (target == "panel") {
    		clearTimeout(this._show_default_content_timer);
    		this.popup.hide();
    		this._drawPanel(d, callback);
    	}
    	else if (target == "popup") {
    		this.panel.hide();
    		this._drawPopup(d, callback);
    	}
    };

    InfoPopup.prototype.clickout = function() {
    	this._state.locked_id = null;
    	if (this._state.mode == "both" || this._state.mode == "panel") {
    		this.popup.draw(); // call draw to resize constrainer, if necessary
    		this.popup.hide();
    		if (this._state.panel_position == "overlay" || !this._state.panel_side_fixed) {
    			this.panel.hide();
    		}
    		else this._showDefaultPanelContent();
    	}
    	if (this._state.mode == "popup") {
    		this.panel.hide();
    		this.popup.draw(); // call draw to resize constrainer, if necessary
    		this.popup.hide();
    	}
    };

    InfoPopup.prototype.touch = function(coords_or_node, d, id, callback) {
    	this.mouseover(coords_or_node, d, callback, true, id);
    };

    InfoPopup.prototype.mouseover = function(coords_or_node, d, callback, touch, touch_id) {
    	var target = this._state.mode == "panel" ? "panel" : "popup";
    	if (this._checkIfPopupIsEmpty(d, target, this._state.mode == "both")) {
    		target === "panel" ? this.hidePanel() : this.hidePopup();
    		return;
    	}
    	var instance = this;
    	if (this._state.mode == "both") {
    		this._point(coords_or_node);
    		this._drawPopup(d, callback, true);
    		touch ? enablePopupPointerEvents(this) : disablePopupPointerEvents(this);
    		if (touch) {
    			var popup_contents = instance.popup._getElement().querySelector(".flourish-popup-content");
    			popup_contents.onclick = function() {
    				instance.click(coords_or_node, d, touch_id, callback);
    			};
    		}
    	}
    	if (this._state.mode == "popup") {
    		if (this._state.locked_id !== null) return;
    		disablePopupPointerEvents(this);
    		this._point(coords_or_node);
    		this._drawPopup(d, callback);
    	}
    	if (this._state.mode == "panel") {
    		if (this._state.locked_id !== null || this._state.panel_position == "overlay") return;
    		if (!this._state.panel_side_fixed) return;
    		clearTimeout(this._show_default_content_timer);
    		this._point(coords_or_node);
    		this._drawPanel(d, callback);
    	}
    };

    InfoPopup.prototype.mouseout = function() {
    	if (this._state.mode == "both") {
    		this.popup.hide();
    	}
    	if (this._state.mode == "popup") {
    		if (this._state.locked_id !== null) return;
    		this.popup.hide();
    	}
    	if (this._state.mode == "panel") {
    		if (this._state.locked_id !== null) return;
    		if (this._state.panel_position == "overlay" || !this._state.panel_side_fixed) return;
    		this._showDefaultPanelContent();
    	}
    };

    // ======= //
    // GETTERS //
    // ======= //

    InfoPopup.prototype.locked = function() {
    	return this._state.locked_id;
    };

    InfoPopup.prototype.mode = function () {
    	return this._state.mode;
    };

    // ====================== //
    // DATA & CONTENT METHODS //
    // ====================== //

    InfoPopup.prototype.setColumnNames = function(column_names) {
    	this._column_names = column_names;

    	return this;
    };

    InfoPopup.prototype._showDefaultPanelContent = function () {
    	var instance = this;
    	clearTimeout(this._show_default_content_timer);
    	// This delays the return to the default content by 100ms, to avoid
    	// a "strobe" effect if you are quickly moving in and out of data points
    	// e.g. on a map
    	this._show_default_content_timer = setTimeout(function () {
    		instance.panel.html(instance._state.panel_side_default_content);
    		instance._drawPanel();
    	}, 100);
    	// We do, however, immediately call the drawPanel function to make sure
    	// the margins() measurement is correct, rather than stuck with the old
    	// values at the time of being called.
    	instance._drawPanel();
    };

    InfoPopup.prototype._checkIfPopupIsEmpty = function (d, target, teaser) {
    	var popup_content = target == "panel" ? getPanelHTML(this, d) : getPopupHTML(this, d, teaser);
    	return popup_content.trim() == "";
    };

    // =================== //
    // DRAW & HIDE METHODS //
    // =================== //

    InfoPopup.prototype.onPanelClose = function(f) {
    	this._on_panel_close = f;
    	return this;
    };

    InfoPopup.prototype._drawPopup = function(d, callback, teaser) {
    	if (d) this.popup.html(getPopupHTML(this, d, teaser));
    	updateStyle(this);
    	this.popup.draw();
    	if (callback) callback(this.popup._getElement(), d);
    	return this;
    };

    InfoPopup.prototype._drawPanel = function(d, callback) {
    	var instance = this;
    	updateStyle(instance);
    	this.panel
    		.open_duration(this._state.panel_open_duration)
    		.close_duration(this._state.panel_close_duration)
    		.width_overlay(this._state.panel_width_overlay)
    		.height_overlay(this._state.panel_height_overlay)
    		.vertical_position(this._state.panel_vertical_position)
    		.width_side(this._state.panel_width_side)
    		.height_side(this._state.panel_height_side)
    		.position(this._state.panel_position)
    		.max_width(this._state.panel_max_width)
    		.max_height(this._state.panel_max_height)
    		.closeable(this._state.panel_position == "overlay" || !this._state.panel_side_fixed);
    	if (d === undefined) this.panel.draw();
    	else this.panel.html(getPanelHTML(instance, d)).draw();
    	if (callback) callback(this.panel._getElement(), d);
    	return this;
    };

    InfoPopup.prototype.hidePanel = function() {
    	this.panel.hide();
    	return this;
    };

    InfoPopup.prototype.hidePopup = function () {
    	this.popup.hide();
    	return this;
    };

    // ================== //
    // POSITIONAL METHODS //
    // ================== //

    InfoPopup.prototype.popupDirections = function(value) {
    	if (!value) return this._popup_directions.slice();
    	this._popup_directions = value;
    	return this;
    };

    InfoPopup.prototype.margins = function() {
    	return this.panel.margins();
    };

    InfoPopup.prototype._getBiggestGap = function(node_bbox) {
    	var constrainer_bbox = this._popup_container.getBoundingClientRect();
    	var best_side, biggest_gap = 0, arrow_directions;
    	var gaps = {
    		"right": ((constrainer_bbox.width + constrainer_bbox.left) - (node_bbox.width + node_bbox.left)) / constrainer_bbox.width,
    		"bottom": ((constrainer_bbox.height + constrainer_bbox.top) - (node_bbox.height + node_bbox.top)) / constrainer_bbox.height,
    		"left": (node_bbox.left - constrainer_bbox.left) / constrainer_bbox.width,
    		"top": (node_bbox.top - constrainer_bbox.top) / constrainer_bbox.height,
    	};


    	var all_arrow_directions = {
    		"right": ["left", "leftFlexible", "topLeft", "bottomLeft", "bottomFlexible", "bottom", "topFlexible", "top", "bottomRight", "topRight", "rightFlexible", "right"],
    		"left": ["right", "rightFlexible", "topRight", "bottomRight", "top", "topFlexible", "bottom", "bottomFlexible", "bottomLeft", "topLeft", "leftFlexible", "left"],
    		"top": ["bottom", "bottomFlexible", "bottomRight", "bottomLeft", "rightFlexible", "leftFlexible", "right", "left", "topRight", "topLeft", "topFlexible", "top"],
    		"bottom": ["top", "topFlexible", "topLeft", "topRight", "left", "right", "leftFlexible", "rightFlexible", "bottomLeft", "bottomRight", "bottomFlexible", "bottom"]
    	};

    	for (var side in gaps) {
    		if (this._popup_directions.indexOf(side) < 0) continue;
    		if (gaps[side] > biggest_gap) {
    			biggest_gap = gaps[side];
    			best_side = side;
    			arrow_directions = all_arrow_directions[side];
    		}
    	}

    	var x = node_bbox.left, y = node_bbox.top;
    	if (best_side == "left" || best_side == "right") y += node_bbox.height * 0.5;
    	else if (best_side == "bottom") y += node_bbox.height;

    	if (best_side == "top" || best_side == "bottom") x += node_bbox.width * 0.5;
    	else if (best_side == "right") x += node_bbox.width;

    	return {
    		"side": best_side,
    		"arrow_directions": arrow_directions,
    		"x": x,
    		"y": y
    	};
    };

    // Point should not often be required by template authors, who
    // should generally use the click or mouseover methods
    InfoPopup.prototype._point = function(coords_or_node) {
    	var x, y, arrow_directions = this._popup_directions;
    	if (Array.isArray(coords_or_node)) {
    		x = coords_or_node[0];
    		y = coords_or_node[1];
    	}
    	else if (coords_or_node && coords_or_node.getBoundingClientRect) {
    		var node_rect = coords_or_node.getBoundingClientRect();
    		var best_side = this._getBiggestGap(node_rect);
    		x = best_side.x;
    		y = best_side.y;
    		arrow_directions = best_side.arrow_directions;
    	}
    	else {
    		console.warn("@flourish/info-popup: Invalid positional value passed in point function, should be a coordinates array, or a node. Current value is", coords_or_node);
    		return this;
    	}
    	this.panel.point(coords_or_node);
    	this.popup.directions(arrow_directions).point(x, y);
    	return this;
    };

    // ============== //
    // CONFIG METHODS //
    // ============== //

    InfoPopup.prototype.popupDefaultTemplate = function(template) {
    	if (template != undefined) {
    		this._popup_default_template = template;
    		return this;
    	}
    	else return this._popup_default_template;
    };

    InfoPopup.prototype.panelDefaultTemplate = function(template) {
    	if (template != undefined) {
    		this._panel_default_template = template;
    		return this;
    	}
    	else return this._panel_default_template;
    };

    InfoPopup.prototype.titleKey = function(key) {
    	if (key != undefined) {
    		this._title_key = key;
    		return this;
    	}
    	else return this._title_key;
    };

    InfoPopup.prototype.subtitleKey = function(key) {
    	if (key != undefined) {
    		this._subtitle_key = key;
    		return this;
    	}
    	else return this._subtitle_key;
    };

    // ==== //
    // INIT //
    // ==== //

    function index(state, panel_container, popup_container) {
    	return new InfoPopup(state, panel_container, popup_container);
    }

    return index;

})));
