import { select } from "d3-selection";
import { scaleLinear } from "d3-scale";
import { appendTo, format, getContainer, visible, autoTitle, _updateTitle, getDomain, small_gap } from "../common";
import { remToPx } from "../utils";
import { font_color, font_family, font_size, font_weight } from "../container";

var legend_count = 0;
var pixel_ratio = window.devicePixelRatio || 1;
var DEFAULTS = Object.freeze({
	show_legend: true,

	title_mode: "auto",
	title: "",

	color_band_width: 8,
	color_band_height: 1,
	color_band_radius: 3,

	binned_label_mode: "thresholds",
	binned_label_custom: "",

	legend_min: null,
	legend_max: null,

});

function ContinuousColorLegend(state_) {
	this._state = state_;
	for (var key in DEFAULTS) {	if (this._state[key] === undefined) this._state[key] = DEFAULTS[key]; }

	this._colorFunction = undefined;
	this._formatFunction = undefined;
	this._legend_domain = [];
	this._id = "fl-legend-continuous-color-" + legend_count;
	this._visible = true;
	this._marker_value = null;
	this._auto_title = "";

	this._container = select(document.createElement("div")).attr("class", "fl-legend-container").attr("id", this._id).style("display", "none");
	this._container.append("p").classed("fl-legend-title", true);
	this._container.append("div").classed("min label", true);
	this._container.append("div").classed("color-range-container", true);
	this._container.select(".color-range-container").append("canvas").classed("color-range", true);
	this._container.select(".color-range-container").append("canvas").classed("color-range-labels", true);
	this._container.append("div").classed("max label", true);

	legend_count++;

	return this;
}

// Common methods
ContinuousColorLegend.prototype.appendTo = appendTo;
ContinuousColorLegend.prototype.format = format;
ContinuousColorLegend.prototype.getContainer = getContainer;
ContinuousColorLegend.prototype.visible = visible;
ContinuousColorLegend.prototype.autoTitle = autoTitle;
ContinuousColorLegend.prototype._updateTitle = _updateTitle;

ContinuousColorLegend.prototype.data = function(items_, colorFunction_) {
	// items_ must be a 2-element or 3-element domain array [minValue, midValue, maxValue]
	// colorFunction_ must be a scale function with color range
	if (!items_ && !colorFunction_) return this._legend_domain.slice();

	var items = Array.isArray(items_) ? items_.slice() : [];

	this._legend_domain = getDomain(items, this._state);
	this._colorFunction = colorFunction_;

	return this;
};

ContinuousColorLegend.prototype.markerValue = function(value) {
	if (value === undefined) return this._marker_value;
	this._marker_value = value;
	return this;
};

ContinuousColorLegend.prototype.update = function() {
	var should_display = this._state.show_legend && this._visible && this._legend_domain.length > 0;

	this._container.style("display", should_display ? "" : "none");

	if (!should_display) return this;

	this._updateTitle();
	this._updateLegend();

	return this;
};

ContinuousColorLegend.prototype._updateLegend = function() {
	var domain = this._legend_domain;

	this._scale_type = "continuous";
	if (this._colorFunction.thresholds) this._scale_type = "binned";
	else if (domain.length > 2) this._scale_type = "diverging";

	var s = this._state;

	var w = remToPx(s.color_band_width);
	var h = remToPx(s.color_band_height);
	var label_w = w;

	this._container.style("display", "inline-flex")
		.style("align-items", "center");

	this._container.select(".color-range-container")
		.style("display", "inline-block");

	var canvas = this._container
		.select(".color-range")
		.attr("width", w * pixel_ratio)
		.attr("height", h * pixel_ratio)
		.style("border-radius", s.color_band_radius + "px")
		.style("width", w + "px")
		.style("height", h + "px")
		.style("display", "block");

	this._container
		.select(".color-range-labels")
		.attr("width", label_w * pixel_ratio)
		.style("width", label_w + "px")
		.style("display", this._scale_type == "continuous" ? "none" : "block")
		.node().getContext("2d").scale(pixel_ratio, pixel_ratio);

	// Update canvas
	var ctx = canvas.node().getContext("2d");
	ctx.scale(pixel_ratio, pixel_ratio);

	function xToVal(x) {
		return domain.min + (x / w) * (domain.max - domain.min);
	}

	for (var x = 0; x < w; x++) {
		var color = this._colorFunction(xToVal(x));
		ctx.fillStyle = color;
		ctx.strokeStyle = color;
		ctx.fillRect(x, 0, 1, h);
		ctx.strokeRect(x, 0, 1, h);
	}

	if (this._marker_value !== null) {
		var xScale = scaleLinear().domain([domain.min, domain.max]).range([0, w]);
		var x_marker = xScale(this.markerValue());
		var y_top = 0;
		var y_bottom = h;
		ctx.save();
		ctx.strokeStyle = "#FFFFFF";
		ctx.lineWidth = 3;
		ctx.beginPath();
		ctx.moveTo(x_marker, y_top);
		ctx.lineTo(x_marker, y_bottom);
		ctx.stroke();
		ctx.strokeStyle = "#000000";
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.moveTo(x_marker, y_top);
		ctx.lineTo(x_marker, y_bottom);
		ctx.stroke();
		ctx.restore();
	}

	this._updateLegendLabels();
};

ContinuousColorLegend.prototype._updateLegendLabels = function () {
	var label_canvas = this._container.select(".color-range-labels");
	var format = this._formatFunction;
	var domain = this._legend_domain;
	var s = this._state;

	this._container
		.select(".min.label")
		.style("display", this._scale_type == "continuous" ? "inline-block" : "none")
		.style("vertical-align", "middle")
		.style("user-select", "none")
		.style("line-height", "1.25em")
		.text(function () {
			return format ? format(domain.min) : domain.min;
		})
		.style("padding-inline-start", 0)
		.style("padding-inline-end", small_gap);

	this._container
		.select(".max.label")
		.style("display", this._scale_type == "continuous" ? "inline-block" : "none")
		.style("vertical-align", "middle")
		.style("user-select", "none")
		.style("line-height", "1.25em")
		.text(function () {
			return format ? format(domain.max) : domain.max;
		})
		.style("padding-inline-start", small_gap)
		.style("padding-inline-end", 0);

	var labels = [];
	var label_padding_start = 0;
	var label_padding_end = 0;
	if (this._scale_type === "diverging") labels = this._getDivergingLabels();
	else if (this._scale_type === "binned") labels = this._getBinnedLabels();

	if (labels.length) {
		var ctx = label_canvas.node().getContext("2d");
		ctx.textAlign = "center";
		ctx.textBaseline = "top";
		ctx.font = font_weight + " " + remToPx(font_size) + "px " + font_family;

		var prepLabel = (function () {
			var placed_labels = [];
			var band_width = remToPx(s.color_band_width);
			var inRange = getInRangeFunction([0, band_width]);
			var scale = scaleLinear().domain([domain.min, domain.max]).range([0, band_width]);

			return function (value) {
				var center = scale(value);

				if (!inRange(center)) return;

				var text = format ? format(value) : value;
				var half_width = (ctx.measureText(text).width / 2) + 1;
				var left = center - half_width;
				var right = center + half_width;

				var index = 0;
				var n = placed_labels.length;

				for (var i = 0; i < n; i++) {
					if (center > placed_labels[i].center) index++;
					else break;
				}

				var at_start = index === 0;
				var at_end = index === n;
				if (!at_start && placed_labels[index - 1].right > left) return;
				if (!at_end && placed_labels[index].left < right) return;
				if (at_start) label_padding_start = Math.abs(Math.min(0, left));
				if (at_end) label_padding_end = Math.max(0, right - band_width);

				placed_labels.splice(index, 0, { left: left, center: center, right: right });
				return { text: text, position: center };
			};
		})();

		var prepped_labels = labels.map(function (value) {
			return prepLabel(value);
		});

		var label_canvas_width = remToPx(s.color_band_width) + label_padding_start + label_padding_end;
		var label_h = Math.ceil(remToPx(font_size) * 0.95);
		var pixel_ratio = window.devicePixelRatio || 1;

		label_canvas
			.attr("width", label_canvas_width * pixel_ratio)
			.style("width", label_canvas_width + "px")
			.attr("height", label_h * pixel_ratio)
			.style("height", label_h + "px")
			.style("margin-top", small_gap);

		select(".color-range").style("margin-left", label_padding_start + "px");

		ctx.scale(pixel_ratio, pixel_ratio);
		ctx.textAlign = "center";
		ctx.textBaseline = "top";
		ctx.font = font_weight + " " + remToPx(font_size) + "px " + font_family;
		ctx.fillStyle = font_color;

		prepped_labels.forEach(function(label) {
			if (label) ctx.fillText(label.text, label.position + label_padding_start, 0);
		});
	}
};

ContinuousColorLegend.prototype._getDivergingLabels = function() {
	var domain = this._legend_domain;
	var inRange = getInRangeFunction(domain);
	var labels = [];

	if (inRange(domain.min)) labels.push(domain.min);
	if (inRange(domain.mid)) labels.push(domain.mid);
	if (inRange(domain.max)) labels.push(domain.max);

	return labels;
};

ContinuousColorLegend.prototype._getBinnedLabels = function () {
	var s = this._state;
	var domain = this._legend_domain;
	var inRange = getInRangeFunction(domain);
	var labels;

	if (s.binned_label_mode === "thresholds") {
		labels = this._colorFunction.thresholds.slice().filter(inRange);
		if (domain.min < labels[0]) labels.unshift(domain.min);
		if (domain.max > labels[labels.length - domain.length - 1]) labels.unshift(domain.max);
	}
	else if (s.binned_label_mode === "centers") {
		labels = this._colorFunction.centers.slice().filter(inRange);
		if (labels.length) {
			var thresholds = this._colorFunction.thresholds;
			var first_threshold = thresholds[0];
			var last_threshold = thresholds[thresholds.length - 1];
			if (first_threshold > domain.min) labels.unshift((domain.min + first_threshold) / 2);
			if (last_threshold < domain.max) labels.unshift((last_threshold + domain.max) / 2);
		}
		else labels.push((domain.min + domain.max) / 2);
	}
	else labels = s.binned_label_custom.split(";").map(parseFloat);

	return labels;
};

function getInRangeFunction(range) {
	var legend_max = -Infinity;
	var legend_min = Infinity;
	for (var i in range) {
		legend_max = Math.max(legend_max, range[i]);
		legend_min = Math.min(legend_min, range[i]);
	}
	return function (val) { return val >= legend_min && val <= legend_max; };
}

export default ContinuousColorLegend;
