import { select } from "d3-selection";
import { appendTo, format, getContainer, visible, autoTitle, _updateTitle, small_gap } from "../common";
import { remToPx, roundDown } from "../utils";

var legend_count = 0;
var DEFAULTS = Object.freeze({
	show_legend: true,

	title_mode: "auto",
	title: "",

	clip_height: 1,
	small_circle_size: 0.5,

	shape_fill: "#eeeeee",
	shape_stroke: "#555555",

});

function ContinuousSizeLegend(state_) {
	this._state = state_;
	for (var key in DEFAULTS) {	if (this._state[key] === undefined) this._state[key] = DEFAULTS[key]; }

	this._scaleFunction = undefined;
	this._formatFunction = undefined;
	this._id = "fl-legend-continuous-size-" + legend_count;
	this._visible = true;
	this._auto_title = "";

	this._container = select(document.createElement("div"))
		.attr("class", "fl-legend-container")
		.attr("id", this._id)
		.style("display", "none")
		.style("align-items", "center");

	this._container.append("p")
		.attr("class", "fl-legend-title");

	this._container.append("div")
		.classed("min label", true);

	var circles_container = this._container.append("div")
		.classed("circles", true);

	circles_container.append("canvas")
		.classed("min circle", true);

	circles_container.append("canvas")
		.classed("max circle", true);

	this._container.append("div")
		.classed("max label", true);

	legend_count++;

	return this;
}

// Common methods
ContinuousSizeLegend.prototype.appendTo = appendTo;
ContinuousSizeLegend.prototype.format = format;
ContinuousSizeLegend.prototype.autoTitle = autoTitle;
ContinuousSizeLegend.prototype._updateTitle = _updateTitle;
ContinuousSizeLegend.prototype.getContainer = getContainer;
ContinuousSizeLegend.prototype.visible = visible;


ContinuousSizeLegend.prototype.scale = function(scaleFunction_) {
	// scaleFunction_ must be a scale function with size (radius) range
	// domain and range are assumed to be [0, max] where max is a number > 0
	if (scaleFunction_ === undefined) return this._scaleFunction;

	this._scaleFunction = scaleFunction_;

	return this;
};

ContinuousSizeLegend.prototype.update = function() {
	var should_display = this._state.show_legend && this._visible;

	var h = Math.ceil(remToPx(this._state.clip_height));
	this._container
		.style("display", should_display ? "inline-flex" : "none")
		.style("align-items", "center")
		.style("min-height", h + "px");

	if (!should_display || !this._scaleFunction) return this;

	if (this._scaleFunction.domain()[0] !== 0) {
		console.warn("Non zero domain[0] in ContinuousSizeLegend");
	}

	if (this._scaleFunction.range()[0] !== 0) {
		console.warn("Non zero range[0] in ContinuousSizeLegend");
	}

	this._updateTitle();
	this._updateLegend();

	return this;
};

ContinuousSizeLegend.prototype._updateLegend = function() {
	var domain = this._scaleFunction.domain();
	var range = this._scaleFunction.range();
	var format = this._formatFunction;
	var s = this._state;
	var h = remToPx(s.clip_height);
	h = Math.ceil(Math.min(h, range[1] * 2));
	var pixel_ratio = window.devicePixelRatio || 1;

	var fill = s.shape_fill;
	var stroke = s.shape_stroke;

	this._container
		.style("min-height", h + "px");

	this._container.select(".circles")
		.style("display", "flex")
		.style("flex-wrap", "nowrap");

	// Calculate max circle size
	var val_max_unrounded = this._scaleFunction.invert(h/2);
	val_max_unrounded = Math.min(val_max_unrounded, domain[1]);
	var val_max = roundDown(val_max_unrounded) || 0;

	// Min circle
	var val_min = val_max * s.small_circle_size;
	var r_min = this._scaleFunction(val_min);
	var w_min = Math.ceil(2 * r_min) + 2;
	var canvas_min = this._container
		.select(".min.circle")
		.style("width", w_min + "px")
		.style("height", h + "px")
		.attr("width", w_min * pixel_ratio)
		.attr("height", h * pixel_ratio)
		.style("margin-right", "0.05rem");

	this._container
		.select(".min.label")
		.style("user-select", "none")
		.style("line-height", "1.25em")
		.text(function () {
			return format ? format(val_min) : val_min;
		})
		.style("padding-inline-start", 0)
		.style("padding-inline-end", small_gap);

	var ctx_min = canvas_min.node().getContext("2d");
	ctx_min.scale(pixel_ratio, pixel_ratio);
	ctx_min.fillStyle = fill;
	ctx_min.clearRect(0, 0, 2 * r_min, 2 * r_min);

	ctx_min.beginPath();
	ctx_min.fillStyle = stroke;
	ctx_min.arc(0.5 * w_min, 0.5 * h, r_min, 0, 2 * Math.PI);
	ctx_min.fill();

	ctx_min.beginPath();
	ctx_min.fillStyle = fill;
	ctx_min.arc(0.5 * w_min, 0.5 * h, Math.max(r_min - 1, 0), 0, 2 * Math.PI);
	ctx_min.fill();

	// Max circle
	var r_max = this._scaleFunction(val_max);
	var w_max = Math.ceil(2 * r_max) + 2;

	var canvas_max = this._container
		.select(".max.circle")
		.style("width", w_max + "px")
		.style("height", h + "px")
		.attr("width", w_max * pixel_ratio)
		.attr("height", h * pixel_ratio)
		.style("margin-left", "0.05rem");

	this._container
		.select(".max.label")
		.style("user-select", "none")
		.style("line-height", "1.25em")
		.text(function () {
			return format ? format(val_max) : val_max;
		})
		.style("padding-inline-start", small_gap)
		.style("padding-inline-end", 0);

	var ctx_max = canvas_max.node().getContext("2d");
	ctx_max.scale(pixel_ratio, pixel_ratio);
	ctx_max.clearRect(0, 0, 2 * r_max, 2 * r_max);

	// To ensure size of larger circle is accurate, draw two circles where the
	// outer (darker) one is the required size and the inside one slightly smaller
	// This gives the impression of a circle with darker stroke
	ctx_max.beginPath();
	ctx_max.fillStyle = stroke;
	ctx_max.arc(0.5 * w_max, 0.5 * h, r_max, 0, 2 * Math.PI);
	ctx_max.fill();

	ctx_max.beginPath();
	ctx_max.fillStyle = fill;
	ctx_max.arc(0.5 * w_max, 0.5 * h, Math.max(r_max - 1, 0), 0, 2 * Math.PI);
	ctx_max.fill();
};

export default ContinuousSizeLegend;
