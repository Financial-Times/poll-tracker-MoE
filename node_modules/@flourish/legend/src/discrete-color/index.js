import { select, event as d3_event } from "d3-selection";
import { appendTo, format, getContainer, visible, autoTitle, _updateTitle, small_gap } from "../common";
import { remToPx } from "../utils";

var legend_count = 0;
var DEFAULTS = Object.freeze({
	show_legend: true,

	title_mode: "auto",
	title: "",

	max_width: 25,

	swatch_width: 0.75,
	swatch_height: 1,
	swatch_radius: 3,
	legend_items_padding: 0.2,

	icon_height: 1,
	icon_color: "#777777",

	order_override: "",

	orientation: "horizontal",

});

function DiscreteColorLegend(state_) {
	this._state = state_;
	for (var key in DEFAULTS) {	if (this._state[key] === undefined) this._state[key] = DEFAULTS[key]; }

	this._colorFunction = undefined;
	this._formatFunction = undefined;
	this._legend_items = [];
	this._filtered_items = [];
	this._eventListeners = [];
	this._id = "fl-legend-discrete-color-" + legend_count;
	this._visible = true;
	this._auto_title = "";

	this._container = select(document.createElement("div")).attr("class", "fl-legend-container").attr("id", this._id);
	this._container.append("p").attr("class", "fl-legend-title");
	legend_count++;

	return this;
}

// Common methods
DiscreteColorLegend.prototype.appendTo = appendTo;
DiscreteColorLegend.prototype.format = format;
DiscreteColorLegend.prototype.getContainer = getContainer;
DiscreteColorLegend.prototype.visible = visible;
DiscreteColorLegend.prototype.autoTitle = autoTitle;
DiscreteColorLegend.prototype._updateTitle = _updateTitle;


DiscreteColorLegend.prototype.data = function(items_, colorFunction_) {
	this._colorFunction = colorFunction_;

	if (!items_ && !colorFunction_) return this._legend_items.slice();

	if (!colorFunction_) this._legend_items = Array.isArray(items_) ? items_.slice() : [];
	else if (!Array.isArray(items_)) this._legend_items = [];
	else {
		this._legend_items = items_.slice().map(function(legend_item, i) {
			var legend_item_label = typeof legend_item == "object" ? legend_item.label || "" : legend_item;
			return !legend_item_label ? null : {
				label: legend_item_label,
				color: colorFunction_(legend_item_label),
				index: i
			};
		}).filter(function(legend_item) { return legend_item !== null; });
	}
	return this;
};

DiscreteColorLegend.prototype.filtered = function(items_) {
	if (!items_) return this._filtered_items.slice();
	this._filtered_items = Array.isArray(items_) ? items_.slice() : [];
	return this;
};

DiscreteColorLegend.prototype.on = function(type, callback) {
	if (!this._container) return this;

	// Update list of event listeners, so we know if there are any interactions going on
	if (callback && this._eventListeners.indexOf(type) < 0) this._eventListeners.push(type);
	else if (!callback) this._eventListeners.splice(this._eventListeners.indexOf[type], 1);
	this._container.classed("interactive", this._eventListeners.length > 0);

	// Remove event listener if callback is empty
	if (!callback) this._container.on(type, null);
	else {
		this._container.on(type, function() {
			var t = d3_event.target, t_parent = t.parentNode;
			var item = t.classList.contains("fl-legend-item") ? t : (t_parent.classList.contains("fl-legend-item") ? t_parent : null);
			if (item) {
				var item_data = select(item).datum();
				callback.call(item, item_data, item_data.index);
			}
		});
	}

	return this;
};

DiscreteColorLegend.prototype.update = function() {
	var should_display = this._state.show_legend && this._visible && this._legend_items.length > 0;

	this._container.style("display", should_display ? "" : "none");

	if (!should_display) return this;

	this._updateTitle();
	this._updateLegend();

	return this;
};

function sortByOrderOverride(items, order_override_string) {
	// First build a lookup table from each of the overridden legend
	// labels to the index of its new position in the legend.
	var new_index_lookup = {};
	var overrides = order_override_string.split(/\s*\n\s*/);
	for (var i = 0; i < overrides.length; i++) {
		var override = overrides[i];
		new_index_lookup[override] = i;
	}
	// Now go through each of the original items and if it appears in
	// the lookup table, set it at its new position in sorted_items.
	var sorted_items = [];
	for (var old_index = 0; old_index < items.length; old_index++) {
		var item = items[old_index];
		var new_index = new_index_lookup[item.label];
		if (new_index === undefined) continue;
		sorted_items[new_index] = item;
	}
	// If there was any override that isn't a legend label (e.g. it's
	// mispelled), there'll be a "hole" in the sorted_items array, so
	// compact it before returning.
	return sorted_items.filter(function (item) { return item !== undefined; });
}

DiscreteColorLegend.prototype._updateLegend = function() {
	var _this = this;
	var format = this._formatFunction;
	this._container
		.style("max-width", remToPx(this._state.max_width) + "px")
		.style("display", "inline-flex")
		.style("flex-wrap", "wrap")
		.style("align-items", this._state.orientation == "horizontal" ? "center" : "start")
		.style("align-content", this._state.orientation == "horizontal" ? "center" : null)
		.style("flex-direction", this._state.orientation == "horizontal" ? null : "column");

	var legend_item_data;
	if (this._state.order_override.trim()) {
		legend_item_data = sortByOrderOverride(this._legend_items, this._state.order_override);
	}
	else {
		legend_item_data = this._legend_items;
	}

	var legend_items = this._container
		.selectAll(".fl-legend-item")
		.data(legend_item_data);

	var legend_items_enter = legend_items
		.enter()
		.append("div")
		.attr("class", "fl-legend-item");

	legend_items_enter
		.append("div")
		.attr("class", "fl-legend-swatch");

	legend_items_enter
		.append("svg")
		.attr("class", "fl-legend-icon")
		.append("path");

	legend_items_enter
		.append("p")
		.attr("class", "fl-legend-label");

	var legend_items_update = legend_items.merge(legend_items_enter);

	legend_items_update
		.style("display", this._state.orientation == "horizontal" ? "inline-flex" : "flex")
		.style("opacity", function(d) {
			return _this._filtered_items.indexOf(d.label) > -1 ? 0.2 : "";
		})
		.style("align-items", "center")
		.style("padding-inline-end", this._state.orientation == "horizontal" ? this._state.legend_items_padding + "rem" : 0)
		.style("padding-inline-start", 0);

	// Swatch
	legend_items_update.select(".fl-legend-swatch")
		.style("height", this._state.swatch_height + "rem")
		.style("width", this._state.swatch_width + "rem")
		.style("border-radius", this._state.swatch_radius + "px")
		.style("background-color", function(d) { return d.color; })
		// Only display if icon not defined
		.style("display", function(d) {
			return d.icon ? "none" : null;
		});

	// Icon
	legend_items_update.select(".fl-legend-icon")
		// Using Math.ceil on SVG width and height seems to prevent subtle cropping of the icon edges (particularly apparent in outline mode)
		.attr("height", Math.ceil(remToPx(this._state.icon_height)))
		.attr("width", function(d) {
			if (!d.icon) return 0;

			var w = d.icon.width;
			var h = d.icon.height;
			var stroke_width = d.outline ? h * d.stroke_thickness : 0;
			w += stroke_width;
			h += stroke_width;

			var aspect_ratio = w / h;
			var width_px = remToPx(_this._state.icon_height * aspect_ratio);
			return Math.ceil(width_px);
		})
		.style("margin-right", this._state.text_size * 0.25 + "rem")
		.style("display", function(d) {
			return d.icon ? "inline-block" : "none";
		})
		.select("path")
		.attr("d", function(d) {
			return d.icon ? d.icon.path_string : null;
		})
		.attr("transform", function(d) {
			if (!d.icon) return null;

			var h = d.icon.height;
			var stroke_width = d.outline ? h * d.stroke_thickness : 0;
			h += stroke_width;

			var svg_height = remToPx(_this._state.icon_height);
			var scale_factor = svg_height / h;

			var transform = "scale(" + scale_factor + ")";
			transform += "translate(" + 0.5 * stroke_width + "," + 0.5 * stroke_width + ")";

			return transform;
		})
		.style("fill", function(d) {
			if (d.outline) return "none";
			return d.color || _this._state.icon_color;
		})
		.style("stroke", function(d) {
			if (!d.outline) return "none";
			return d.color || _this._state.icon_color;
		})
		.style("stroke-width", function(d) {
			if (!d.outline) return 0;
			var stroke_width = d.icon.height * d.stroke_thickness;
			return stroke_width;
		});

	// Label
	legend_items_update.select(".fl-legend-label")
		.text(function(d) {
			return format ? format(d.label) : d.label;
		})
		.style("margin", 0)
		.style("user-select", "none")
		.style("padding-inline-end", 0)
		.style("padding-inline-start", small_gap);

	legend_items.exit().remove();

	this._legend_item_els = legend_items_update;

	return this;
};

export default DiscreteColorLegend;
