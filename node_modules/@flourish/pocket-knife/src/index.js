import { color } from "d3-color";
import { set as d3_set } from "d3-collection";

var getTextWidth = (function() {
	var context = document.createElement("canvas").getContext("2d");
	return function(text, font) {
		context.font = font || "10px sans-serif";
		var metrics = context.measureText(text);
		return metrics.width;
	};
})();

function isImage(string) {
	if (typeof string != "string") return false;
	return string.match(/^(https?:\/\/.+\.(jpg|jpeg|svg|png|gif|webp)$|data:image\/)/i) != null;
}

function isUrl(string) {
	if (typeof string != "string") return false;
	return string.match(/^(https?:\/\/|data:)/i) != null;
}

function hexToColor(hex_string, opacity) {
	if (typeof hex_string != "string") return false;
	var c = color(hex_string);
	c.opacity = opacity !== undefined ? opacity : 1;
	return c;
}

function hexToRgba(hex_string, opacity) {
	var c = hexToColor(hex_string, opacity);

	return c ? c.toString() : false;
}

function isPale(c) {
	if (!c) {
		console.warn("No valid color", c);
		return;
	}
	var rgb = color(c);
	// https://stackoverflow.com/questions/11867545/change-text-color-based-on-brightness-of-the-covered-background-area
	// With adjusted threshold
	return Math.round((rgb.r * 299) + (rgb.g * 587) + (rgb.b * 114)) / 1000 > 195;
}

function wrapStringToLines(text, font_styles, text_max_lines, max_width) {
	var lines = [];
	var max_line_width = 0;

	// TODO. Should this be just one canvas rather than one per label
	var canvas = document.createElement("canvas");
	var ctx = canvas.getContext("2d");
	ctx.font = font_styles;

	//  if everything fits in one line, so leave as a single string
	var text_width = ctx.measureText(text).width;
	if (text_width <= max_width) {
		lines.push(text);
		max_line_width = text_width;
	}

	// Otherwise…
	else {
		// Create array of words
		var words = text.trim().split(/\s+/g);
		// Loop through the words, adding them until they won't fit
		var current_line = "";
		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			var string = current_line + (current_line ? " " : "") + word;
			var string_width = ctx.measureText(string).width;
			// If the string including the next word fits, update the
			// current_line and the max_width
			if (string_width <= max_width) {
				current_line = string;
				max_line_width = Math.max(max_line_width, string_width);
			}
			// If we reach this point, the text has overflowed,
			// so should always result in a truncation or a new line
			else {
				var last_line = lines.length + 1 == text_max_lines;
				if (!last_line && current_line) {
					lines.push(current_line);
					var word_width = ctx.measureText(word).width;
					if (word_width <= max_width) {
						current_line = word;
						continue;
					}
				}
				// Truncate
				var remove_counter = 1;
				var truncated_string = string;
				do {
					truncated_string = string.substring(0, string.length - remove_counter) + "…";
					string_width = ctx.measureText(truncated_string).width;
				}
				while ((string_width > max_width) && (++remove_counter < string.length));
				max_line_width = Math.max(max_line_width, string_width);
				current_line = truncated_string;
				break;
			}
		}
		lines.push(current_line);
	}
	lines.widest_line = max_line_width;
	return lines;
}


function getUniqueValuesFromBinding(data, binding, index) {
	if (data.column_names[binding] === undefined) return [];

	var is_multi_col_binding = Array.isArray(data.column_names[binding]);

	var value_set = d3_set(data, function(d) {
		return is_multi_col_binding ? d[binding][index || 0] : d[binding];
	});

	var value_array = [];
	value_set.each(function(d) { value_array.push(d); });
	return value_array;
}

export { getTextWidth, isImage, isPale, isUrl, hexToColor, hexToRgba, wrapStringToLines, getUniqueValuesFromBinding };
